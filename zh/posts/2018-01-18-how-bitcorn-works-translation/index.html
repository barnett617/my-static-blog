<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>比特币协议是如何工作的（译） | Wilson's Blog</title>
<meta name=keywords content="其他"><meta name=description content="本文翻译自 13 年一篇关于比特币协议的深度解析文章"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/posts/2018-01-18-how-bitcorn-works-translation/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.659e049f7d2efb8a004f34ec6fb29b526477a978c7fb695f4c301f8864c325c5.css integrity="sha256-ZZ4En30u+4oATzTsb7KbUmR3qXjH+2lfTDAfiGTDJcU=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/posts/2018-01-18-how-bitcorn-works-translation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="比特币协议是如何工作的（译）"><meta property="og:description" content="本文翻译自 13 年一篇关于比特币协议的深度解析文章"><meta property="og:type" content="article"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/posts/2018-01-18-how-bitcorn-works-translation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-18T09:38:05+00:00"><meta property="article:modified_time" content="2018-01-18T09:38:05+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="比特币协议是如何工作的（译）"><meta name=twitter:description content="本文翻译自 13 年一篇关于比特币协议的深度解析文章"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://barnett617.github.io/wilson-blog/posts/"},{"@type":"ListItem","position":2,"name":"比特币协议是如何工作的（译）","item":"https://barnett617.github.io/wilson-blog/posts/2018-01-18-how-bitcorn-works-translation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"比特币协议是如何工作的（译）","name":"比特币协议是如何工作的（译）","description":"本文翻译自 13 年一篇关于比特币协议的深度解析文章\n","keywords":["其他"],"articleBody":"本文翻译自 13 年一篇关于比特币协议的深度解析文章\n成千上万篇文章为了解释比特币这一线上、点对点的货币而撰写。大多数文章对于其底层加密协议都只给出一些简短的解释，却忽略了很多细节。甚至那些文章常常掩盖重点进行更深入的研究。我这篇文章的目的是以一种清晰、容易理解的方式解释隐藏在比特币协议后面的主要思想。我们将从第一原则开始，对于比特币如何工作建立一个广义的理论上的理解，然后再深挖其细节，检查比特币交易的原始数据。\n以细节的方式理解协议是一项困难的工作。人们转而接受比特币，并从事投机关于如何通过比特币致富、比特币吧是否泡沫，比特币是否意味着税收结束的一天等等。这很有趣，但是严重限制你理解它。理解比特币的协议细节打开了难以进入的远景。特别是，理解比特币内建脚本语言的基础会使得使用比特币创造新的金融工具成为可能，比如智能合同。反过来，新的金融工具可以被用来创造新的市场并缔造人类行为新的集合形式。聊聊这些趣事吧！\n我会在后面的文章中描述比特币脚本和一些概念，比如智能合同。这篇文章集中解释比特币协议的核心。理解这篇文章你需要对公钥加密以及与其紧密关联的数字签名概念比较熟悉。我将同样假定你对加密散列概念熟悉。以上这些都没有特别难理解的。基本概念都会在大学的大一数学课程或者计算机课程中教授。这些概念很优雅，所以如果你对于他们不是很熟悉，我建议你先花一点时间熟悉一下。\n也许看上去比较神奇，比特币的基础是密码学。比特币不是一种货币？不是一种发送秘密信息的方式？事实上，比特币需要解决的事情大部分是安全事务——确保人们不能互相窃取，或者伪造等等。在原子世界我们通过一些设备，例如锁、保险箱、签名、银行金库实现安全。在比特世界我们通过加密实现安全。这也是为什么比特币的核心是加密协议。\n我在这篇文章中的策略是分阶段建立起比特币。我会通过解释一种非常简单的数字货币开始，所基于的思想几乎显而易见。我们将称其信息货币（Infocoin），以区分于比特币。当然，我们第一个版本的信息币会有很多不足，然后我们会经过多个迭代，每个迭代介绍仅仅一或两个新的想法。经过多个迭代后，我们将达到完整的比特币协议。我们将重新发明了比特币。\n这种策略比起我一次性解释整个比特币协议要慢。但是当你通过这样一次性解释的方式理解了比特币机制时，再去理解比特币为什么这样设计就会很困难。这种通过慢迭代的解释方式优势在于可以让你对于比特币每一个元素理解得更加犀利。\n最后，我应该提及对于比特币我也是个新手。我从 2011 年开始松散地关注（在 20 世纪 90 年代末开始关注加密数字货币），但直到今年早些时候才着重关注比特币协议的细节。所以我将非常感激对于我误解部分的指正。另外在本篇文章中我还包含了很多“留给读者的问题”——在我写作过程中对于新冒出的问题的一些笔记。你会发现这很有趣，但你也可以把它们全部跳过以免丢失全文的线索。\n第一步：签名意图信\n所以我们该如何设计一个数字货币呢？\n从表面上来看，数字货币听起来是不可能的。假设某个人，让我们称其 Alice，她有一些电子钱想花掉。如果 Alice 想使用一串比特字符作为钱，我们如何才能阻止她反复使用相同的比特字符串呢？否则将意味着会产生无穷无尽的钱。或者假如我们可以通过某种方式解决这个问题，但我们如何才能防止其他人伪造这样一串比特字符并用来偷取 Alice 的钱呢？\n这些只是众多问题中的两个，必须被克服以为了使用信息作为货币。\n作为信息币的第一个版本，让我们找到一个方法使得 Alice 可以使用一串字符（非常原始和不完整）作为货币的形式，以某种至少保证她的货币不会被伪造的方式。假设 Alice 想给 Bob 一个信息币。为了这么做，Alice 写下一行字符串“我，爱丽丝，给 Bob 一个信息币”。然后她用私钥给这条信息做了数字签名，并告知全世界 这段签过名的字符串。\n（顺便提一下，我使用首字母大写的 Infocoin 表示信息币协议及一般概念，用首字母小写的 infocoin 特指货币面值，类似用法很常见，虽然在比特币的世界不通用）\n这并不是一个令人非常影响深刻的数字货币原型。但它的确有一些优点。世界上的任何人（包括 Bob）可以使用 Alice 的公钥去确认 Alice 的确是“我，爱丽丝，给 Bob 一个信息币”这条信息签名的主人。没有其他人可以造出这条比特信息。但反过来，Alice 也可以说“不，我没说要给 Bob 一个信息币”。所以这个协议建立在 Alice 真的想给 Bob 一个信息币。同样的事实——没有其他人可以构造这样一条签名信息——也给予 Alice 一些防止其他人伪造的有限保护。当然，在 Alice 创建她的这条信息后也可能其他人复制了这条信息，这样的话伪造是可能的。但无法从头伪造。这两种属性——Alice 建立企图的部分和防止伪造的有限保护部分，是这个协议值得注意的特征。\n我在这个协议中没有（非常）准确地讲数字货币是什么。为了使其明确：特指这条信息本身，例如，这行比特字符串展示了数字货币“我，爱丽丝，给 Bob 一个信息币”。后面的协议类似，我们所有数字货币的形式只是会越来越复杂。\n使用序列号来使得货币被唯一标识 第一个版本的信息币的问题在于 Alice 可以一次又一次地继续向 Bob 发送相同的签名消息。假定 Bob 收到了十份“我，爱丽丝，给 Bob 一个信息币”这样的拷贝签名信息。意味着 Alice 向 Bob 发送了十个不同的信息币吗？她的信息是巧合复制出来的吗？可能她只是试图戏弄 Bob 使其相信她给了他十个不同的信息币，当这条信息向全世界证明才表示她真的企图传送一个信息币。\n我们想要的是一种使得信息币唯一的方式。它们需要一个标签或者序列号。Alice 将签名“我，爱丽丝，用序列号 8740348 给 Bob 一个信息币”这条信息。然后，随后，Alice 可以签名“我，爱丽丝，用序列号 8770431 给 Bob 一个信息币”消息，然后 Bob（还有其他人）将会知道这是另外一个信息币被传送了。\n使得这个方案工作，我们需要一个可信任的序列号源用于信息币。创建这样一个源的方法之一是引用一个银行。这个银行将为信息币提供序列号，并追溯谁拥有了哪一个信息币并确认交易的确合法。\n更详细地说，让我们假设 Alice 去银行并说“我想从我的账户提取一个信息币”。银行从她的账户余额中扣减一个信息币，并分配给她一个新的、之前从未使用过的序列号，让我们称其 1234567。然后当 Alice 想把她的信息比转移给 Bob 时，她签名“我，Alice，给 Bob 一个信息币，使用序列号 1234567”这条消息。但 Bob 并没有就这样接受这个信息币。而是联系了银行以确认：（a）这个序列号的信息币是否属于 Alice；（b）Alice 已经支付了这个信息币。如果这两者都是真的，然后 Bob 告诉银行他想接受这个信息币，于是银行更新他们的交易记录并展示这个序列号的信息币现在是 Bob 的财产，并不再属于 Alice。\n使每个人都集中于银行 上一个解决方案看上去很有前途。然而，事实证明，我们可以做一些更有野心的事情。我们完全可以消除银行的协议。这在很大程度上改变了货币的本质。这意味着不再有任何单一的组织管控货币。当你想到中央银行的巨大力量——控制着货币的供应量——这将是一个非常巨大的变化。\n这个想法是使得每个人（全体地）都是银行。特别是，我们假设每一个人都使用信息币保持着哪些信息币属于哪一个人的完整记录。你可以理解为这是一个展示所有的信息币交易的共享公共平台。我们称这个平台为区块链，因为那就被称为比特币的完整记录，一旦我们得到它。\n现在，假定 Alice 想转移一个信息币给 Bob。她签名了“我，Alice，给 Bob 一个信息币，以序列号 1234567”这条消息并把这条签名消息给了 Bob。Bob 可以用他拷贝的区块链去校验这的确是 Alice 给出的。如果校验成功，然后他把这笔交易中 Alice 发出的消息和他的接收消息广播给整个网络，于是每个人都更新他们的区块链拷贝。\n我们仍然有“序列号从哪来”这个问题，但这变得容易解决，所以我将推迟到后面讲解，在讨论比特币的部分。一个更具挑战的问题是，这个协议允许 Alice 通过支付她的信息币双倍来作弊。她发送“我，爱丽丝，给了 Bob 一个信息币，以序列号 1234567”给 Bob，同时发送“我，爱丽丝，给 Charlie 一个信息币，以序列号 1234567”给 Charlie。Bob 和 Charlie 都使用他们拷贝的区块链来检查这个信息币是 Alice 支付的。只要他们是同一时刻做这个验证（在他们有机会彼此听说之前），他们两个都会发现，是的，区块链显示这个信息币的确属于 Alice。于是他们都会接受这笔交易，并广播他们的接受。现在就有了问题，其他人该怎么更新他们的区块链呢？可能没有简单的方法来实现一个一致的共享事务平台。即使每个人都能达成一致的方式去更新他们的区块链，仍会有 Bob 或者 Charlie 将被欺骗的问题。\n乍一看 Alice 支付双份的问题难以解决。毕竟，如果 Alice 先向 Bob 发送消息，然后 Bob 可以确认这条消息，并告诉每个在网络内的人（包括 Charlie）去更新他们的区块链。一旦那发生了，Charlie 就不再会被 Alice 欺骗。所以最有可能只有非常短的一段时间内 Alice 可以支付出双份。然而，显然这样的一段时间是不可理喻的。更糟糕的是，有技术可以被 Alice 用来延长这一段时间。她可以，举个例子，利用网络流量分析发现 Bob 和 Charlie 沟通延迟很多的一段时间。或者她可以做些事情来故意破坏他们的通信。如果她能减慢通信甚至一点都将使得她支付双份更加容易。\n我们怎样才能解决这个双份支付的问题？明显的解决方法是当 Alice 向 Bob 发送一个信息币的时候，Bob 不应该试图独自确认交易。相反，他应该将可能的交易广播给信息币用户整个网络，并询问他们去判定这笔交易是否合法。如果他们集体决定这笔交易没问题，然后 Bob 可以接受这个信息币，并告诉每个人更新区块链。这种协议可以避免双份支付，因为如果 Alice 试图将她的信息币同时支付给 Bob 和 Charlie，其他人会察觉到，并且网络用户会告诉 Bob 和 Charlie 这笔交易有问题，于是交易将无法通过。\n更详细地，让我们假设 Alice 想要给 Bob 一个信息币。像之前那样，她签名“我，爱丽丝，给 Bob 一个信息币，以序列号 1234567”这条消息，并把这条签名消息发送给 Bob。同样如以前那样，Bob 做了一个明智的检查，使用他拷贝的区块链检查，的确，当前这个信息币属于爱丽丝。但在这个点上协议被修改了。Bob 并没有继续接受这笔交易。取而代之的是，他广播 Alice 的这条消息给整个网络。网络上的其他成员检查 Alice 是否拥有这个信息币。如果如此，他们广播消息“是的，Alice 拥有信息币 1234567，现在这条消息可以发送给 Bob”。一旦足够多的人广播这条消息，每个人都更新他们的区块链以显示信息币现在属于 Bob，交易将完成。\n目前这个协议有许多不准确的元素。例如，什么是“一旦足够多的人广播了这条消息”？这里的“足够”到底意味着什么？它可以意味着网络里的每一个人，因为我们无法预先知道谁在这个信息币网络里。出于同样的原因，它不能意味着网络内一些固定的用户。我们现在不试着使这些想法变准确。取而代之，在下一个部分我会指出一个严重的问题和方法按照所描述。解决那个问题将同时有良好的副作用可以使得上面的想法更加准确。\n工作证据（Proof-of-work） 假设 Alice 想要支付双份，以我刚描述的基于网络的协议。她可以通过接管信息币网络来这么做。让我们假设她使用了一个自动化系统建立了非常大量的独立身份，让我假设是十亿个，在信息币网络上。正如此前，她想支付双份，同时将一个信息币发送给 Bob 和 Charlie。但是当 Bob 和 Charlie 询问网络以验证他们对于交易的观点，Alice 的傀儡身份在网络中向 Bob 声称他们验证了这笔交易，并告诉 Charlie 他们验证了这笔交易，可能同时愚弄一个或二者同时去接受这笔交易。\n有一个聪明的方法可以避免这个问题，使用一个被称为工作证据的想法。这个想法是违反直觉的并且设计到两个概念的结合：（1）去（人工）使得对于网络用户验证交易变得从计算角度花费很大（昂贵）（原文：to (artificially) make it computationally costly for network users to validate transactions）；(2) 奖励那些试图帮助验证交易的人。奖励被使用，这样网络上的用户就会努力去帮忙验证交易。虽然那样会导致一个计算非常昂贵的过程。使得验证交易变得昂贵的收益是不再会受网络身份的某些人控制的影响，而只有通过总的计算力量才能施加在验证上（原文：The benefit of making it costly to validate transactions is that validation can no longer be influenced by the number of network identities someone controls, but only by the total computational power they can bring to bear on validation.）我们会看到，用一些聪明的设计我们可以让骗子欺骗需要巨大的计算资源，使得其不切实际。\n这是 Proof-of-work 的要点。但要真正理解其，我们需要深究细节。\n假定 Alice 向网络广播一条消息“我，爱丽丝，给 Bob 一个信息币，以序列号 1234567”。\n当别人在网络上听到这条消息，每个人将其添加进一个他们被告知的交易等待队列，但他们还尚未被网络所批准。举个例子，另一个网络用户名叫 David 可能有以下交易等待队列：\n我，Tom，给 Sue 一个信息币，以序列号 1201174 我，Sydney，给 Cynthia 一个信息币，以序列号 1295618 我，Alice，给 Bob 一个信息币，以序列号 1234567\nDavid 检查自己的区块链，并可以看到每一笔交易都是有效的。他想通过广播整个网络这个有效性来帮忙。\n然而，在此之前，作为验证协议的一部分，David 被要求去解决一个困难的计算难题——the proof-of-work。没有对于这个难题的解决，网络的其他人不会接受他对于这笔交易的验证。\nDavid 需要解决的是一个怎样的难题呢？为了解释它，让 h 作为一个固定的散列函数，被网络内的每一个人所知道——被建立在协议内。比特币使用著名的 SHA-256 散列函数，但是任何加密安全散列函数都可以。让我们给 David 的交易等待队列一个标签 l，这样它有了名字可以被用来谈及。假设 David 为 l 附上一个数字 x（称为 nonce）并为其组合求哈希。举个例子，如果我们使用 l=“Hello,world!\"(显然这不是一个交易清单，只是一个用于演示目的的字符串)和临时值（nonce）x=0（输出是一个十六进制）\nh(\"Hello,world!0\") = 1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64 David 需要解决的难题是——the proof-of-work——去找到一个临时值（nonce）x，这样当我们将 x 附加于 l 并求其组合的散列值，输出的哈希值以很长一段 0 开头。这里的困难可以被变得更加困难或更加简单通过改变解决这个困难所需要的 0 的数量。一个较为简单的 proof-of-work 难题可能在哈希值的头部只需要 3 个或 4 个 0，然而一个较为困难的 proof-of-work 难题可能需要更长的一串 0，比如 15 个连续的 0。在任何一种情况，上述找到合适的临时值尝试，用 x=0，都是一个失败，因为输出的开头根本就不含任何的 0。尝试用 x=1 也没有效果。\n未完待续\n原文链接：http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/\nproof-of-work\n","wordCount":"354","inLanguage":"zh","datePublished":"2018-01-18T09:38:05Z","dateModified":"2018-01-18T09:38:05Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://barnett617.github.io/wilson-blog/posts/2018-01-18-how-bitcorn-works-translation/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives/ title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>比特币协议是如何工作的（译）</h1><div class=post-meta><span title='2018-01-18 09:38:05 +0000 UTC'>2018-01-18 09:38:05</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;354 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/source/content/posts/2018-01-18-how-bitcorn-works-translation.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav></div></details></div><div class=post-content><p>本文翻译自 13 年一篇关于比特币协议的深度解析文章</p><p>成千上万篇文章为了解释比特币这一线上、点对点的货币而撰写。大多数文章对于其底层加密协议都只给出一些简短的解释，却忽略了很多细节。甚至那些文章常常掩盖重点进行更深入的研究。我这篇文章的目的是以一种清晰、容易理解的方式解释隐藏在比特币协议后面的主要思想。我们将从第一原则开始，对于比特币如何工作建立一个广义的理论上的理解，然后再深挖其细节，检查比特币交易的原始数据。</p><p>以细节的方式理解协议是一项困难的工作。人们转而接受比特币，并从事投机关于如何通过比特币致富、比特币吧是否泡沫，比特币是否意味着税收结束的一天等等。这很有趣，但是严重限制你理解它。理解比特币的协议细节打开了难以进入的远景。特别是，理解比特币内建脚本语言的基础会使得使用比特币创造新的金融工具成为可能，比如智能合同。反过来，新的金融工具可以被用来创造新的市场并缔造人类行为新的集合形式。聊聊这些趣事吧！</p><p>我会在后面的文章中描述比特币脚本和一些概念，比如智能合同。这篇文章集中解释比特币协议的核心。理解这篇文章你需要对公钥加密以及与其紧密关联的数字签名概念比较熟悉。我将同样假定你对加密散列概念熟悉。以上这些都没有特别难理解的。基本概念都会在大学的大一数学课程或者计算机课程中教授。这些概念很优雅，所以如果你对于他们不是很熟悉，我建议你先花一点时间熟悉一下。</p><p>也许看上去比较神奇，比特币的基础是密码学。比特币不是一种货币？不是一种发送秘密信息的方式？事实上，比特币需要解决的事情大部分是安全事务——确保人们不能互相窃取，或者伪造等等。在原子世界我们通过一些设备，例如锁、保险箱、签名、银行金库实现安全。在比特世界我们通过加密实现安全。这也是为什么比特币的核心是加密协议。</p><p>我在这篇文章中的策略是分阶段建立起比特币。我会通过解释一种非常简单的数字货币开始，所基于的思想几乎显而易见。我们将称其信息货币（Infocoin），以区分于比特币。当然，我们第一个版本的信息币会有很多不足，然后我们会经过多个迭代，每个迭代介绍仅仅一或两个新的想法。经过多个迭代后，我们将达到完整的比特币协议。我们将重新发明了比特币。</p><p>这种策略比起我一次性解释整个比特币协议要慢。但是当你通过这样一次性解释的方式理解了比特币机制时，再去理解比特币为什么这样设计就会很困难。这种通过慢迭代的解释方式优势在于可以让你对于比特币每一个元素理解得更加犀利。</p><p>最后，我应该提及对于比特币我也是个新手。我从 2011 年开始松散地关注（在 20 世纪 90 年代末开始关注加密数字货币），但直到今年早些时候才着重关注比特币协议的细节。所以我将非常感激对于我误解部分的指正。另外在本篇文章中我还包含了很多“留给读者的问题”——在我写作过程中对于新冒出的问题的一些笔记。你会发现这很有趣，但你也可以把它们全部跳过以免丢失全文的线索。</p><p>第一步：签名意图信</p><p>所以我们该如何设计一个数字货币呢？</p><p>从表面上来看，数字货币听起来是不可能的。假设某个人，让我们称其 Alice，她有一些电子钱想花掉。如果 Alice 想使用一串比特字符作为钱，我们如何才能阻止她反复使用相同的比特字符串呢？否则将意味着会产生无穷无尽的钱。或者假如我们可以通过某种方式解决这个问题，但我们如何才能防止其他人伪造这样一串比特字符并用来偷取 Alice 的钱呢？</p><p>这些只是众多问题中的两个，必须被克服以为了使用信息作为货币。</p><p>作为信息币的第一个版本，让我们找到一个方法使得 Alice 可以使用一串字符（非常原始和不完整）作为货币的形式，以某种至少保证她的货币不会被伪造的方式。假设 Alice 想给 Bob 一个信息币。为了这么做，Alice 写下一行字符串“我，爱丽丝，给 Bob 一个信息币”。然后她用私钥给这条信息做了数字签名，并告知全世界
这段签过名的字符串。</p><p>（顺便提一下，我使用首字母大写的 Infocoin 表示信息币协议及一般概念，用首字母小写的 infocoin 特指货币面值，类似用法很常见，虽然在比特币的世界不通用）</p><p>这并不是一个令人非常影响深刻的数字货币原型。但它的确有一些优点。世界上的任何人（包括 Bob）可以使用 Alice 的公钥去确认 Alice 的确是“我，爱丽丝，给 Bob 一个信息币”这条信息签名的主人。没有其他人可以造出这条比特信息。但反过来，Alice 也可以说“不，我没说要给 Bob 一个信息币”。所以这个协议建立在 Alice 真的想给 Bob 一个信息币。同样的事实——没有其他人可以构造这样一条签名信息——也给予 Alice 一些防止其他人伪造的有限保护。当然，在 Alice 创建她的这条信息后也可能其他人复制了这条信息，这样的话伪造是可能的。但无法从头伪造。这两种属性——Alice 建立企图的部分和防止伪造的有限保护部分，是这个协议值得注意的特征。</p><p>我在这个协议中没有（非常）准确地讲数字货币是什么。为了使其明确：特指这条信息本身，例如，这行比特字符串展示了数字货币“我，爱丽丝，给 Bob 一个信息币”。后面的协议类似，我们所有数字货币的形式只是会越来越复杂。</p><h5 id=使用序列号来使得货币被唯一标识>使用序列号来使得货币被唯一标识<a hidden class=anchor aria-hidden=true href=#使用序列号来使得货币被唯一标识>#</a></h5><p>第一个版本的信息币的问题在于 Alice 可以一次又一次地继续向 Bob 发送相同的签名消息。假定 Bob 收到了十份“我，爱丽丝，给 Bob 一个信息币”这样的拷贝签名信息。意味着 Alice 向 Bob 发送了十个不同的信息币吗？她的信息是巧合复制出来的吗？可能她只是试图戏弄 Bob 使其相信她给了他十个不同的信息币，当这条信息向全世界证明才表示她真的企图传送一个信息币。</p><p>我们想要的是一种使得信息币唯一的方式。它们需要一个标签或者序列号。Alice 将签名“我，爱丽丝，用序列号 8740348 给 Bob 一个信息币”这条信息。然后，随后，Alice 可以签名“我，爱丽丝，用序列号 8770431 给 Bob 一个信息币”消息，然后 Bob（还有其他人）将会知道这是另外一个信息币被传送了。</p><p>使得这个方案工作，我们需要一个可信任的序列号源用于信息币。创建这样一个源的方法之一是引用一个银行。这个银行将为信息币提供序列号，并追溯谁拥有了哪一个信息币并确认交易的确合法。</p><p>更详细地说，让我们假设 Alice 去银行并说“我想从我的账户提取一个信息币”。银行从她的账户余额中扣减一个信息币，并分配给她一个新的、之前从未使用过的序列号，让我们称其 1234567。然后当 Alice 想把她的信息比转移给 Bob 时，她签名“我，Alice，给 Bob 一个信息币，使用序列号 1234567”这条消息。但 Bob 并没有就这样接受这个信息币。而是联系了银行以确认：（a）这个序列号的信息币是否属于 Alice；（b）Alice 已经支付了这个信息币。如果这两者都是真的，然后 Bob 告诉银行他想接受这个信息币，于是银行更新他们的交易记录并展示这个序列号的信息币现在是 Bob 的财产，并不再属于 Alice。</p><h5 id=使每个人都集中于银行>使每个人都集中于银行<a hidden class=anchor aria-hidden=true href=#使每个人都集中于银行>#</a></h5><p>上一个解决方案看上去很有前途。然而，事实证明，我们可以做一些更有野心的事情。我们完全可以消除银行的协议。这在很大程度上改变了货币的本质。这意味着不再有任何单一的组织管控货币。当你想到中央银行的巨大力量——控制着货币的供应量——这将是一个非常巨大的变化。</p><p>这个想法是使得每个人（全体地）都是银行。特别是，我们假设每一个人都使用信息币保持着哪些信息币属于哪一个人的完整记录。你可以理解为这是一个展示所有的信息币交易的共享公共平台。我们称这个平台为区块链，因为那就被称为比特币的完整记录，一旦我们得到它。</p><p>现在，假定 Alice 想转移一个信息币给 Bob。她签名了“我，Alice，给 Bob 一个信息币，以序列号 1234567”这条消息并把这条签名消息给了 Bob。Bob 可以用他拷贝的区块链去校验这的确是 Alice 给出的。如果校验成功，然后他把这笔交易中 Alice 发出的消息和他的接收消息广播给整个网络，于是每个人都更新他们的区块链拷贝。</p><p>我们仍然有“序列号从哪来”这个问题，但这变得容易解决，所以我将推迟到后面讲解，在讨论比特币的部分。一个更具挑战的问题是，这个协议允许 Alice 通过支付她的信息币双倍来作弊。她发送“我，爱丽丝，给了 Bob 一个信息币，以序列号 1234567”给 Bob，同时发送“我，爱丽丝，给 Charlie 一个信息币，以序列号 1234567”给 Charlie。Bob 和 Charlie 都使用他们拷贝的区块链来检查这个信息币是 Alice 支付的。只要他们是同一时刻做这个验证（在他们有机会彼此听说之前），他们两个都会发现，是的，区块链显示这个信息币的确属于 Alice。于是他们都会接受这笔交易，并广播他们的接受。现在就有了问题，其他人该怎么更新他们的区块链呢？可能没有简单的方法来实现一个一致的共享事务平台。即使每个人都能达成一致的方式去更新他们的区块链，仍会有 Bob 或者 Charlie 将被欺骗的问题。</p><p>乍一看 Alice 支付双份的问题难以解决。毕竟，如果 Alice 先向 Bob 发送消息，然后 Bob 可以确认这条消息，并告诉每个在网络内的人（包括 Charlie）去更新他们的区块链。一旦那发生了，Charlie 就不再会被 Alice 欺骗。所以最有可能只有非常短的一段时间内 Alice 可以支付出双份。然而，显然这样的一段时间是不可理喻的。更糟糕的是，有技术可以被 Alice 用来延长这一段时间。她可以，举个例子，利用网络流量分析发现 Bob 和 Charlie 沟通延迟很多的一段时间。或者她可以做些事情来故意破坏他们的通信。如果她能减慢通信甚至一点都将使得她支付双份更加容易。</p><p>我们怎样才能解决这个双份支付的问题？明显的解决方法是当 Alice 向 Bob 发送一个信息币的时候，Bob 不应该试图独自确认交易。相反，他应该将可能的交易广播给信息币用户整个网络，并询问他们去判定这笔交易是否合法。如果他们集体决定这笔交易没问题，然后 Bob 可以接受这个信息币，并告诉每个人更新区块链。这种协议可以避免双份支付，因为如果 Alice 试图将她的信息币同时支付给 Bob 和 Charlie，其他人会察觉到，并且网络用户会告诉 Bob 和 Charlie 这笔交易有问题，于是交易将无法通过。</p><p>更详细地，让我们假设 Alice 想要给 Bob 一个信息币。像之前那样，她签名“我，爱丽丝，给 Bob 一个信息币，以序列号 1234567”这条消息，并把这条签名消息发送给 Bob。同样如以前那样，Bob 做了一个明智的检查，使用他拷贝的区块链检查，的确，当前这个信息币属于爱丽丝。但在这个点上协议被修改了。Bob 并没有继续接受这笔交易。取而代之的是，他广播 Alice 的这条消息给整个网络。网络上的其他成员检查 Alice 是否拥有这个信息币。如果如此，他们广播消息“是的，Alice 拥有信息币 1234567，现在这条消息可以发送给 Bob”。一旦足够多的人广播这条消息，每个人都更新他们的区块链以显示信息币现在属于 Bob，交易将完成。</p><p>目前这个协议有许多不准确的元素。例如，什么是“一旦足够多的人广播了这条消息”？这里的“足够”到底意味着什么？它可以意味着网络里的每一个人，因为我们无法预先知道谁在这个信息币网络里。出于同样的原因，它不能意味着网络内一些固定的用户。我们现在不试着使这些想法变准确。取而代之，在下一个部分我会指出一个严重的问题和方法按照所描述。解决那个问题将同时有良好的副作用可以使得上面的想法更加准确。</p><h5 id=工作证据proof-of-work>工作证据（Proof-of-work）<a hidden class=anchor aria-hidden=true href=#工作证据proof-of-work>#</a></h5><p>假设 Alice 想要支付双份，以我刚描述的基于网络的协议。她可以通过接管信息币网络来这么做。让我们假设她使用了一个自动化系统建立了非常大量的独立身份，让我假设是十亿个，在信息币网络上。正如此前，她想支付双份，同时将一个信息币发送给 Bob 和 Charlie。但是当 Bob 和 Charlie 询问网络以验证他们对于交易的观点，Alice 的傀儡身份在网络中向 Bob 声称他们验证了这笔交易，并告诉 Charlie 他们验证了这笔交易，可能同时愚弄一个或二者同时去接受这笔交易。</p><p>有一个聪明的方法可以避免这个问题，使用一个被称为工作证据的想法。这个想法是违反直觉的并且设计到两个概念的结合：（1）去（人工）使得对于网络用户验证交易变得从计算角度花费很大（昂贵）（原文：to (artificially) make it computationally costly for network users to validate transactions）；(2)
奖励那些试图帮助验证交易的人。奖励被使用，这样网络上的用户就会努力去帮忙验证交易。虽然那样会导致一个计算非常昂贵的过程。使得验证交易变得昂贵的收益是不再会受网络身份的某些人控制的影响，而只有通过总的计算力量才能施加在验证上（原文：The benefit of making it costly to validate transactions is that validation can no longer be influenced by the number of network identities someone controls, but only by the total computational power they can bring to bear on validation.）我们会看到，用一些聪明的设计我们可以让骗子欺骗需要巨大的计算资源，使得其不切实际。</p><p>这是 Proof-of-work 的要点。但要真正理解其，我们需要深究细节。</p><p>假定 Alice 向网络广播一条消息“我，爱丽丝，给 Bob 一个信息币，以序列号 1234567”。</p><p>当别人在网络上听到这条消息，每个人将其添加进一个他们被告知的交易等待队列，但他们还尚未被网络所批准。举个例子，另一个网络用户名叫 David 可能有以下交易等待队列：</p><p>我，Tom，给 Sue 一个信息币，以序列号 1201174
我，Sydney，给 Cynthia 一个信息币，以序列号 1295618
我，Alice，给 Bob 一个信息币，以序列号 1234567</p><p>David 检查自己的区块链，并可以看到每一笔交易都是有效的。他想通过广播整个网络这个有效性来帮忙。</p><p>然而，在此之前，作为验证协议的一部分，David 被要求去解决一个困难的计算难题——the proof-of-work。没有对于这个难题的解决，网络的其他人不会接受他对于这笔交易的验证。</p><p>David 需要解决的是一个怎样的难题呢？为了解释它，让 h 作为一个固定的散列函数，被网络内的每一个人所知道——被建立在协议内。比特币使用著名的 SHA-256 散列函数，但是任何加密安全散列函数都可以。让我们给 David 的交易等待队列一个标签 l，这样它有了名字可以被用来谈及。假设 David 为 l 附上一个数字 x（称为 nonce）并为其组合求哈希。举个例子，如果我们使用 l=&ldquo;Hello,world!"(显然这不是一个交易清单，只是一个用于演示目的的字符串)和临时值（nonce）x=0（输出是一个十六进制）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>h(&#34;Hello,world!0&#34;) =
</span></span><span class=line><span class=cl>	1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64
</span></span></code></pre></div><p>David 需要解决的难题是——the proof-of-work——去找到一个临时值（nonce）x，这样当我们将 x 附加于 l 并求其组合的散列值，输出的哈希值以很长一段 0 开头。这里的困难可以被变得更加困难或更加简单通过改变解决这个困难所需要的 0 的数量。一个较为简单的 proof-of-work 难题可能在哈希值的头部只需要 3 个或 4 个 0，然而一个较为困难的 proof-of-work 难题可能需要更长的一串 0，比如 15 个连续的 0。在任何一种情况，上述找到合适的临时值尝试，用 x=0，都是一个失败，因为输出的开头根本就不含任何的 0。尝试用 x=1 也没有效果。</p><p>未完待续</p><p>原文链接：<a href=http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/>http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/</a></p><p>proof-of-work</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://barnett617.github.io/wilson-blog/tags/%E5%85%B6%E4%BB%96/>其他</a></li></ul><nav class=paginav><a class=prev href=https://barnett617.github.io/wilson-blog/notes/2018-01-19-js-closure/><span class=title>« 上一页</span><br><span>js学习笔记——闭包</span>
</a><a class=next href=https://barnett617.github.io/wilson-blog/posts/2018-01-17-webpack-basic/><span class=title>下一页 »</span><br><span>webpack学习笔记</span></a></nav><script defer crossorigin=anonymous src=/wilson-blog/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share 比特币协议是如何工作的（译） on wechat" href=javascript:void(0) onclick=return!1 onmouseenter='const shareBtns=document.getElementsByClassName("share-buttons")[0];shareBtns&&(shareBtns.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onmouseleave='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 比特币协议是如何工作的（译） on x" href="https://x.com/intent/tweet/?text=%e6%af%94%e7%89%b9%e5%b8%81%e5%8d%8f%e8%ae%ae%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84%ef%bc%88%e8%af%91%ef%bc%89&amp;url=https%3a%2f%2fbarnett617.github.io%2fwilson-blog%2fposts%2f2018-01-18-how-bitcorn-works-translation%2f&amp;hashtags=%e5%85%b6%e4%bb%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>