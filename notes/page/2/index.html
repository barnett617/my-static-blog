<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes | Wilson's Blog</title>
<meta name=keywords content><meta name=description content="Notes - Wilson's Blog"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/notes/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.7822ca91becd3fe515c67241030e80de043ab22dea5278258d676181168c3c52.css integrity="sha256-eCLKkb7NP+UVxnJBAw6A3gQ6si3qUngljWdhgRaMPFI=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://barnett617.github.io/wilson-blog/notes/index.xml><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/notes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Notes"><meta property="og:description" content="Personal blogs and notes about web development and life"><meta property="og:type" content="website"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/notes/"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes"><meta name=twitter:description content="Personal blogs and notes about web development and life"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://barnett617.github.io/wilson-blog/notes/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Notes
<a href=/wilson-blog/notes/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>浅拷贝和深拷贝</h2></header><div class=entry-content><p>关于 js 浅拷贝和深拷贝
...</p></div><footer class=entry-footer><span title='2019-01-22 16:47:00 +0000 UTC'>2019-01-22 16:47:00</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;708 字</footer><a class=entry-link aria-label="post link to 浅拷贝和深拷贝" href=https://barnett617.github.io/wilson-blog/notes/2019-01-22-shallow-clone-and-deep-clone/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>js中的“拷贝”（第一篇）——js数据类型</h2></header><div class=entry-content><p>关于 js 数据类型
...</p></div><footer class=entry-footer><span title='2019-01-21 15:44:00 +0000 UTC'>2019-01-21 15:44:00</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;273 字</footer><a class=entry-link aria-label="post link to js中的“拷贝”（第一篇）——js数据类型" href=https://barnett617.github.io/wilson-blog/notes/2019-01-21-js-copy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JavaScript高级程序设计第3版笔记（一）</h2></header><div class=entry-content><p>函数表达式 定义函数方式 函数声明 function fun() {} 函数表达式 var fun = function () {}; 关键词 函数声明提升 执行代码前会先读取函数声明，所以在函数声明前也可以调用函数
test(); function test() { alert("test"); } // ok 匿名函数（lambda 函数） 函数表达式同其他表达式，使用前需先声明，否则报错
test(); function test() { alert("test"); } // 报错 递归 经典阶乘
function factorial(num) { if (num &lt;= 1) { return 1; } else { return num * factorial(num - 1); } } 如下会使这个函数报错
// 把factorial()函数保存在another变量中 var another = factorial; // 把变量factorial置空 factorial = null; // 调用another()必须执行factorial(),而factorial不再是函数 alert(another(4)); 解决：使用arguments....</p></div><footer class=entry-footer><span title='2018-09-03 18:54:18 +0000 UTC'>2018-09-03 18:54:18</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;152 字</footer><a class=entry-link aria-label="post link to JavaScript高级程序设计第3版笔记（一）" href=https://barnett617.github.io/wilson-blog/notes/2018-09-03-js-note/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>前端基础知识整理——jQuery选择器</h2></header><div class=entry-content><p>关于 jQuery 选择器的整理
...</p></div><footer class=entry-footer><span title='2018-02-23 20:01:25 +0000 UTC'>2018-02-23 20:01:25</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;270 字</footer><a class=entry-link aria-label="post link to 前端基础知识整理——jQuery选择器" href=https://barnett617.github.io/wilson-blog/notes/2018-02-23-js-basic-about-jquery-selector/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Angular学习笔记</h2></header><div class=entry-content><p>关于 Angular 学习整理
...</p></div><footer class=entry-footer><span title='2018-02-22 22:36:27 +0000 UTC'>2018-02-22 22:36:27</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;78 字</footer><a class=entry-link aria-label="post link to Angular学习笔记" href=https://barnett617.github.io/wilson-blog/notes/2018-02-22-angular4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HTML5语义提升篇</h2></header><div class=entry-content><p>关于 HTML5 中语义方面的改变
...</p></div><footer class=entry-footer><span title='2018-02-16 15:54:37 +0000 UTC'>2018-02-16 15:54:37</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;195 字</footer><a class=entry-link aria-label="post link to HTML5语义提升篇" href=https://barnett617.github.io/wilson-blog/notes/2018-02-16-html5-sementical/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HTML5基础回顾</h2></header><div class=entry-content><p>HTML5 作为如今前端必备“新”技术，理应成为前端基础的必备技能之一
...</p></div><footer class=entry-footer><span title='2018-02-16 15:09:48 +0000 UTC'>2018-02-16 15:09:48</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;130 字</footer><a class=entry-link aria-label="post link to HTML5基础回顾" href=https://barnett617.github.io/wilson-blog/notes/2018-02-16-html-basic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于hexo阅读次数统计及访问次数插件使用</h2></header><div class=entry-content><p>前一段时间换域名，发现博客的访问次数不显示了。一开始没时间关注，最近闲了，研究一下到底是怎么回事，发现原来当初这里不是基于本地配置，而是使用 leancloud 进行统计，查阅到一篇很易懂的教程，顺便整理了一下 PV 和 UV 的统计
...</p></div><footer class=entry-footer><span title='2018-02-13 14:46:31 +0000 UTC'>2018-02-13 14:46:31</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;23 字</footer><a class=entry-link aria-label="post link to 关于hexo阅读次数统计及访问次数插件使用" href=https://barnett617.github.io/wilson-blog/notes/2018-02-13-hexo-reading-count/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux常用命令(长期更新)</h2></header><div class=entry-content><p>记录一下常用到的 linux 命令（包含相应 Windows 中的操作）
...</p></div><footer class=entry-footer><span title='2018-02-07 20:42:57 +0000 UTC'>2018-02-07 20:42:57</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;33 字</footer><a class=entry-link aria-label="post link to linux常用命令(长期更新)" href=https://barnett617.github.io/wilson-blog/notes/2018-02-07-linux-basic-commands/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VMware使用macOS如何全屏</h2></header><div class=entry-content><p>如何解决 VMware 安装 VMware Tools 后仍不能全屏显示的问题
...</p></div><footer class=entry-footer><span title='2018-02-07 14:10:45 +0000 UTC'>2018-02-07 14:10:45</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;26 字</footer><a class=entry-link aria-label="post link to VMware使用macOS如何全屏" href=https://barnett617.github.io/wilson-blog/notes/2018-02-07-vmware-macos-max-window/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于浏览器缓存</h2></header><div class=entry-content><p>探讨浏览器缓存相关
...</p></div><footer class=entry-footer><span title='2018-02-02 14:38:49 +0000 UTC'>2018-02-02 14:38:49</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;142 字</footer><a class=entry-link aria-label="post link to 关于浏览器缓存" href=https://barnett617.github.io/wilson-blog/notes/2018-02-02-browser-cache/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于域名</h2></header><div class=entry-content><p>探析域名
概念 域名（简称“网域”），与互联网上的一个物理 IP 关联
是电子邮件地址中@符号之后和网址中 www.之后的唯一名称
子域名 子域名也是域名，隶属于较大的网域
例如：mail.google.com、www.google.com和docs.google.com都是域名google.com的子域名
域名所有者可以创建子域名，为顶级域名下的网页或服务提供简单好记的地址
裸网域 就是不含“www”前缀的网域地址。例如 google.com，而不是www.google.com
主域名 所注册的域名，可在账号中添加其他域名
辅助域名 主域名之外，可为账号添加其他域名，让相应网域中的用户可使用其他服务
网域别名 可用作其他网域的别名的域名
可为账号添加一个域名作为网域别名，从而为网域中每位用户提供一个采用该域名别名的电子邮件地址
发送至用户任一地址的邮件均会递送到用户的同一个电子邮件收件箱
IP 地址 一个域名可能有一个或多个关联的 IP 地址</p></div><footer class=entry-footer><span title='2018-01-25 15:09:24 +0000 UTC'>2018-01-25 15:09:24</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;27 字</footer><a class=entry-link aria-label="post link to 关于域名" href=https://barnett617.github.io/wilson-blog/notes/2018-01-25-domain/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于DNS</h2></header><div class=entry-content><p>探析 DNS
DNS 概念 Domain Name System，域名系统
本质 整理和识别各个域名的网络电话簿
将域名转换为托管该网站的计算机的物理 IP
MX 记录 概念 Mail Exchange，邮件交换记录
作用 将一个网域的电子邮件定向到托管该网域用户账号的服务器
设置 一个网域可定义多条 MX 记录，每条记录有不同的优先级。
如果邮件通过最高优先级记录无法递送，则采用第二优先级，以此类推
TXT 记录 作用 为网域之外的来源提供文本信息的一种 DNS 记录
文本类型 人工可读文本
机器可读文本
CNAME 记录 规范名称记录
作用 将一个别名关联到另一个真正的或规范的域名
A 记录 地址记录（主机记录），Address
作用 将一个域名关联到托管该网域服务的计算机的物理 IP
NS 记录 作用 用于确定哪些服务器为一个网域传达 DNS 信息
网域通常有主要的和辅助的域名服务器记录
TTL 生存时间，Time To Live
作用 决定对该记录所做的后续更改需要多少秒才会生效
推荐值 3600（即 1 个小时）
让整个互联网中的服务器每小时检查一次该记录的更新情况
原因 较短的 TTL 在之前的有效期到期后才会生效
若想快速还原一项更改，则可设置较短的 TTL 值（如 300,5 分钟）...</p></div><footer class=entry-footer><span title='2018-01-25 14:46:04 +0000 UTC'>2018-01-25 14:46:04</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;84 字</footer><a class=entry-link aria-label="post link to 关于DNS" href=https://barnett617.github.io/wilson-blog/notes/2018-01-25-dns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习笔记（下）</h2></header><div class=entry-content><p>继设计模式学习笔记（上）
15 抽象工厂模式 场景 不同数据库在 SQL 的具体实现上有差距，若存在系统中使用 SQL 语句上过多的使用专门的某种数据库的 SQL 语句，在迁移数据库时，会导致很多 SQL 在新的数据库中不能运行。
解决 使用原生 SQL 语句
实例 class User { private int _id; public int ID { get { return _id; } set { _id = value; } } private string _name;; public string Name { get { return _name; } set { _name = value; } } } 模式解释 工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类
效果 由于多态的存在，声明 User 接口的对象事先不知道在访问哪个数据库，却可以在运行时正常，达到业务逻辑与数据访问解耦
抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类
实际使用步骤 先通过抽象工厂创建一个具体工厂，再通过具体工厂生产特定实现的产品对象...</p></div><footer class=entry-footer><span title='2018-01-24 15:56:32 +0000 UTC'>2018-01-24 15:56:32</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;211 字</footer><a class=entry-link aria-label="post link to 设计模式学习笔记（下）" href=https://barnett617.github.io/wilson-blog/notes/2018-01-24-design-pattern-02/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习笔记（上）</h2></header><div class=entry-content><p>关于 Java 设计模式的学习
继承 两个类之间是 is-a 的关系可以考虑用继承 而两个类之间是 has-a，表示某个角色具有某一项责任，不适合用继承 例如：飞机场有飞机，但是飞机不能去继承飞机场
多态 多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行
特点：（子替父演戏实例）
子类以父类身份出现 子类在工作时以自己的方式实现 子类以父类身份出现时，子类特有的属性和方法不可以使用 多态原理 当方法被调用时，无论对象是否被转换成其父类，都只有位于对象继承最末端的方法实现会被调用。 即父类的抽象方法是按照其运行时类型而非编译时类型进行动态绑定调用的
抽象类 不能实例化 抽象方法必须被子类重写 若类包含抽象方法，则类必须定义为抽象类 总结：抽象类代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的。
在一个继承关系树里，树叶节点应为具体类，树枝节点均应为抽象类。
例如：动物是抽象类，猫是具体类，而当猫划分品种时，比如包含金丝猫和其他品种，那猫应该是树枝，也应是抽象类。
接口 接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。
一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。
声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式（没有具体实现）
所以接口不能实例化、不能有构造方法和字段、不能有修饰符、不能声明为抽象的或静态的
实现接口的类必须实现接口中所有方法和属性
区分抽象类和接口 抽象 类是对对象的抽象
抽象类是对类的抽象
接口是对行为的抽象
对象是否有相似关联 若行为跨越不同类的对象，可使用接口
对于相似的类对象，用继承抽象类
设计角度 抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类
接口根本不知道子类的存在，方法如何实现不确认，预先定义
通过重构改善既有代码的设计 所有抽象类往往通过重构得来
面向对象设计（OOD） 可维护
可复用
可拓展
灵活性好
UML 关联
聚合（弱拥有）：A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分
组合（强拥有）：严格的整体与部分的关系
依赖
简单工厂 用单独的类考虑创造实例的过程
策略模式 官方定义 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
解释 所有的算法完成相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
优势 另外策略模式简化了单元测试，因为每个算法有独立的类，可以通过自己的接口单独测试。...</p></div><footer class=entry-footer><span title='2018-01-24 15:53:31 +0000 UTC'>2018-01-24 15:53:31</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;219 字</footer><a class=entry-link aria-label="post link to 设计模式学习笔记（上）" href=https://barnett617.github.io/wilson-blog/notes/2018-01-24-design-pattern-01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用vmware安装macOS</h2></header><div class=entry-content><p>虽然类似这样的文章网上一搜一大把，但应 youngwa 邀，还是决定重新整理一下个人安装的详细流程及相关资源链接，以备后用。
资源准备 macOS 系统镜像 8G 左右 cdr 后缀 点击下载
vmware 推荐版本 12（自行安装）
vmware 补丁（用于添加 macOS 类镜像）点击下载
操作步骤 下载以上三个资源 安装 VMware 安装补丁，补充 VMware 关于镜像类型的选择（若不安装补丁，则没有 macOS 镜像的选项），安装 unlock，右击使用管理员权限打开 win-install.cmd 新建虚拟机，选择 macOS 类型镜像，并做相应配置 配置好后打开虚拟机的 vmx 文件，手动修改配置（搜索 smc）在 smc.present = “TRUE"后添加一行 smc.version = 0 启动虚拟机进行系统安装 完成即可（历时一个小时左右，视宿主机内存及硬盘配置而定） 注意事项 需要理解 linux 分区概念（不理解也可以将虚拟机分配的全部空间用作一个分区，在实用工具选项中选择磁盘工具，设置后关闭，进行系统安装）
注意点 安装 macOS 和安装其他系统镜像类型的虚拟机没什么大的区别，主要在于以下几点：
为 VMware 安装补丁，拓展镜像类型（实用 unlock） 修改 vmx，虚拟机配置文件，添加 smc.version = 0</p></div><footer class=entry-footer><span title='2018-01-23 12:04:14 +0000 UTC'>2018-01-23 12:04:14</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;61 字</footer><a class=entry-link aria-label="post link to 使用vmware安装macOS" href=https://barnett617.github.io/wilson-blog/notes/2018-01-23-install-macos-using-vmware/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>js学习笔记——一些常用的高级属性</h2></header><div class=entry-content><p>MSDN 学习 js 高级教程 note
构造函数 使用构造函数定义类型（type） 概念 构造函数是一个为 Object 初始化一个特定类型的函数
使用 new 关键字调用构造函数
这里有一些 js 内建对象和自定义对象的例子
var myObject = new Object(); var myBirthday = new Date(1993, 11, 12); var myCar = new Car(); 构造函数包含 this 关键字，它是对新创建的空对象的引用（reference）
它通过创建属性并为他们赋初始值来初始化新对象
构造函数将返回对所创建对象的引用
function Circle(xPoint, yPoint, radius) { this.x = xPoint; this.y = yPoint; this.radius = radius; } var aCircle = new Circle(5, 11, 99); 使用自定义构造函数创建的所有对象的类型都是 object
js 只有 6 中类型：object、function、string、number、boolean、undefined
typeof操作符以字符串形式返回类型信息
var index = 5; var result = typeof index === "number"; var description = "abc"; var result = typeof description === "string"; true true 为声明和未声明的变量测试 undefined 数据类型...</p></div><footer class=entry-footer><span title='2018-01-20 14:11:34 +0000 UTC'>2018-01-20 14:11:34</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;395 字</footer><a class=entry-link aria-label="post link to js学习笔记——一些常用的高级属性" href=https://barnett617.github.io/wilson-blog/notes/2018-01-20-js-advanced/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>js学习笔记——变量作用域</h2></header><div class=entry-content><p>js 变量作用域探析
背景 var o = {}; o.fun = test(); o.fun(); function test() { var fn = function () { console.log(this); }; return fn; } {fun: ƒ} 由于对这个程序的输出结果感到不解，于是决定深入了解 js 作用域究竟是什么个东西
参考：https://msdn.microsoft.com/zh-cn/library/bzt2dkta(v=vs.94).aspx
变量作用域 又要谈到 js 的两个范围：全局和局部
函数之外声明的变量就是全局变量，可在整个程序中访问和修改
函数内声明的变量是局部变量，每当执行程序时都会创建和销毁该变量（所以称临时变量），并且无法通过函数之外的任何代码访问该变量（MSDN 如是说）
js 不支持块范围（通过一组大括号定义新范围），于是就只有全局（函数外）和局部（函数内），以函数划分的这两种范围
js 范围 var aNumber = 100; tweak(); function tweak() { document.write(aNumber); if (false) { var aNumber = 123; } } undefined 虽然 if（false），var aNumber = 123 不会执行，但是 js 在执行函数 tweak()时，会查找所有变量声明，var aNumber 被扫描到，js 使用初始值undefined创建变量，即使使用一个值声明变量 var aNumber = 123，但 aNumber 变量的初始值仍为undefined，仅当执行包含声明的行（var aNumber = 123）时才会使用已声明的值。...</p></div><footer class=entry-footer><span title='2018-01-20 10:53:32 +0000 UTC'>2018-01-20 10:53:32</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;213 字</footer><a class=entry-link aria-label="post link to js学习笔记——变量作用域" href=https://barnett617.github.io/wilson-blog/notes/2018-01-20-js-parameter-scope/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>js学习笔记——this关键字</h2></header><div class=entry-content><p>js 关键字 this 用法解析
解释 函数运行时自动生成的一个内部对象，只能在函数内部使用（想起了 Python 函数的 self）
function test() { this.x = 1; } 函数使用场合不同，this 的值会发生变化
但 this 总指的是调用函数的那个对象
使用场景 纯粹函数调用（全局调用）
函数作为对象方法的调用
作为构造函数调用
apply 调用
1.纯粹函数调用 全局性调用，this 代表全局对象 Global
function test() { this.x = 1; alert(this.x); } test(); 1 var x = 1; function test() { alert(this.x); } test(); 1 不会报错，因为相当于 alert(Global.x)
var x = 1; function test() { this.x = 0; } test(); alert(x); 0 test()之后相当于将全局变量的 x 重新赋值 0，Global....</p></div><footer class=entry-footer><span title='2018-01-19 18:22:06 +0000 UTC'>2018-01-19 18:22:06</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;227 字</footer><a class=entry-link aria-label="post link to js学习笔记——this关键字" href=https://barnett617.github.io/wilson-blog/notes/2018-01-19-js-this/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>js学习笔记——局部变量和全局变量</h2></header><div class=entry-content><p>js 的局部变量和全局变量
大纲 如何声明局部变量和全局变量 js 变量作用域基于特有的作用域链 js 没有块级作用域（ES5-） 函数中声明的变量在整个函数中都有定义 声明局部变量和全局变量 全局变量——定义在函数外的变量 局部变量——函数内部声明的变量 var a = "global"; function getLocal() { var a = "local"; console.log(a); } getLocal(); console.log(a); local global a = "global"; function getLocal() { a = "local"; console.log(a); b = "local"; console.log(b); } getLocal(); console.log(a); console.log(b); local local local local 疑问：
函数外的 a 为什么变成 local？
函数外为什么可以访问 b？
解析：
函数体内部，局部变量优先级比同名全局变量高
函数体内声明变量不使用 var，会暴露在全局上下文中，和现有变量冲突，并覆盖同名全局变量
变量作用域链 每当 js 执行时会有一个对应的执行环境被创建（每一个方法在自己独有的执行环境中执行）
执行环境中的重要部分——函数的调用对象（存储相应函数的局部变量）
函数的执行环境包含了调用对象，调用对象的属性就是函数的局部变量，每个函数在这样的执行环境中执行。函数之外的代码在另一个环境中执行，包含了全局变量。
作用域链 对象组成的列表或链...</p></div><footer class=entry-footer><span title='2018-01-19 16:34:02 +0000 UTC'>2018-01-19 16:34:02</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;345 字</footer><a class=entry-link aria-label="post link to js学习笔记——局部变量和全局变量" href=https://barnett617.github.io/wilson-blog/notes/2018-01-19-js-variables/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://barnett617.github.io/wilson-blog/notes/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://barnett617.github.io/wilson-blog/notes/page/3/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>