<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Webpack on Wilson&#39;s Blog</title>
    <link>https://barnett617.github.io/wilson-blog/tags/webpack/</link>
    <description>Recent content in Webpack on Wilson&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans-CN</language>
    <lastBuildDate>Wed, 17 Jan 2018 11:41:10 +0000</lastBuildDate>
    <atom:link href="https://barnett617.github.io/wilson-blog/tags/webpack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>webpack学习笔记</title>
      <link>https://barnett617.github.io/wilson-blog/posts/2018-01-17-webpack-basic/</link>
      <pubDate>Wed, 17 Jan 2018 11:41:10 +0000</pubDate>
      <guid>https://barnett617.github.io/wilson-blog/posts/2018-01-17-webpack-basic/</guid>
      <description>关于 Webpack 基础使用的整理
背景 网站由网页模式进化成 Webapp 模式
网站运行在高级浏览器中，使用 HTML5、CSS3、ES6 等新技术
webapp 通常是单页面应用（每一个视图通过异步方式加载，导致页面初始化和使用过程会加载更多的 js 代码）
前端开发基于多语言、多层次编码和组织工作，交付基于浏览器，需要保证代码和资源在浏览器端快速优雅的加载和更新，亟需模块化系统
传统方式 &amp;lt;script src=&amp;#34;module1.js&amp;#34;&amp;gt;&amp;lt;/scrpti&amp;gt; &amp;lt;script src=&amp;#34;module2.js&amp;#34;&amp;gt;&amp;lt;/scrpti&amp;gt; &amp;lt;script src=&amp;#34;module3.js&amp;#34;&amp;gt;&amp;lt;/scrpti&amp;gt; ... 弊端 全局作用域（定义在 window 对象下）下易造成变量冲突
文件只能按照脚本引入的顺序加载
需要主观解决模块和代码库的依赖关系
大型项目中资源难以管理，长期积累导致代码库混乱不堪
CommonJS 服务端的 Node.js 遵循 CommonJS 规范
核心思想 允许模块通过 require 方法来同步加载要依赖的其他模块 通过 exports 或 module.exports 导出需要暴露的接口 require(&amp;#34;module&amp;#34;); require(&amp;#34;../file.js&amp;#34;); exports.doStuff = function() {}; module.exports = someValue; 优势 服务端模块便于重用 NPM 中已有大量可用模块包（20w） 简单易用 缺陷 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 ES6 模块 ES6 标准增加了 js 语言层面的模块体系定义
ES6 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</description>
    </item>
  </channel>
</rss>
