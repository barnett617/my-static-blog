<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.120.4"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wilson's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="Personal blogs and notes about web development and life"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.d6284f01cb1f2b7f9d227d153ada9aeb304f496ff910df67a394db7c75330f65.css integrity="sha256-1ihPAcsfK3+dIn0VOtqa6zBPSW/5EN9no5TbfHUzD2U=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://barnett617.github.io/wilson-blog/index.xml><link rel=alternate type=application/json href=https://barnett617.github.io/wilson-blog/index.json><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/><link rel=alternate hreflang=en href=https://barnett617.github.io/wilson-blog/en/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Wilson's Blog"><meta property="og:description" content="Personal blogs and notes about web development and life"><meta property="og:type" content="website"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wilson's Blog"><meta name=twitter:description content="Personal blogs and notes about web development and life"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Wilson's Blog","url":"https://barnett617.github.io/wilson-blog/","description":"Personal blogs and notes about web development and life","thumbnailUrl":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico","sameAs":["https://juejin.cn/user/1644525123025933/posts?sort=popular","https://www.zhihu.com/people/magi617/answers/by_votes","https://www.douban.com/people/DavidMe/?_i=14468907ISm58V","https://github.com/barnett617"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>每年九月份给自己的一份健康警告</h2></header><div class=entry-content><p>从百度拇指医生某热心网友总结那里引用来，觉得写得很不错，有参考意义，特此记录下来
”为什么每年九月份过敏鼻炎就严重“
”因为天气冷热温差比较大。 因为是过敏鼻炎，也可能是你的过敏原在秋季比较丰富。具体你要去医院查过敏原。 我过敏性鼻炎，每天早上起来打喷嚏，流鼻涕，流眼泪，眼睛痒痛充血，如遇天气干燥就容易流鼻血，部分时候会引起头痛。过敏原比较悲催，很普遍， 甲醛、尘螨、灰尘、温度变化都比较敏感。 吃的药基本没什么用。 弄点抗过敏的药就可以了，我现在连喷剂都不太管用。以下是我经过很多测试得到的一些经验，效果挺好，但是也要自己注意保养。
【忌口】辛辣、羊肉、海鲜、避免喝冰水
【温度】要注意保暖。洗脸用温水，尽量喝温水。最好少吹空调
【清洗鼻腔】因为会对某些物质过敏，因此每天清洗一下鼻腔就很有必要了。 每天自制生理盐水冲鼻子，配方： 500ML 38 度的温水+4.5g 无碘盐+4.5g 小苏打。 如果觉得麻烦也可以去淘宝买现成的洗鼻盐。 清洗鼻子的设备，淘宝也有卖的，一种是专门用于洗鼻子的洗鼻机。另一种是洗牙的机器，但是也有洗鼻的喷头。其实就是一个水泵往鼻子里打水，具体方法参见说明书吧。 控制水温 37-38 度才会舒服，太冷会呛到，太热会烫坏鼻粘膜，弄个专门测液体温度的温度计，这种温度计就是厨房用针式的那种。
【坚持锻炼】再有就是坚持锻炼身体会有很大的帮助，提高自身的抵抗力最重要。我是打羽毛球和爬山，我们爬的都是野山，景区效果不好，爬山效果比较明显，山里空气很好。
【避免的运动类型】不要游泳，不要下海。 游泳池水进入鼻腔没有好处。 下海游泳要禁止，会使体温降低，如果海水进入鼻腔会导致非常严重的过敏反应。 下海游泳本人亲身经历过，非常痛苦。
【防止揉眼睛】 眼睛痒痛最麻烦的是夜里不自主的揉眼睛，这样会更严重得结膜炎。我的方法是购买一个 3M 的实验室防护眼镜。它周围是软的，相对还算舒服。有效避免自己揉眼睛，目前没有更好的方法，总不能把自己的手捆起来吧！
【药物】对我而言基本没什么用。抗过敏药:氯雷他定或者扑尔敏。缓解眼睛：双氯芬酸钠滴眼液。喷剂：丙酸倍氯米松鼻喷雾剂（少用，只有特别难受的时候用用吧）。头痛只能吃点去痛片了。其他遵医嘱（其实大夫也没办法）
关键时刻，网民的建议也是有效的，感谢互联网让同病相怜的人可以分享彼此之间的感受和应对措施。</p></div><footer class=entry-footer><span title='2017-09-18 14:10:33 +0000 UTC'>2017-09-18 14:10:33</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;33 字</footer><a class=entry-link aria-label="post link to 每年九月份给自己的一份健康警告" href=https://barnett617.github.io/wilson-blog/posts/2017-09-18-health-tip/></a></article><article class=post-entry><header class=entry-header><h2>关于写博客的一些想法</h2></header><div class=entry-content><p>写博客的好处在于，能够对所学、所做、所想之事有所记录，返璞归真，互联网花了那么多的精力将传统办公进化到无纸办公，人们从纸质书籍的阅读习惯变成了碎片化学习。
能够在这样的环境中圈出自己的一亩三分田，经营自己的博客，对自己既是记录，也是肯定，还能在经营博客的过程中更加认识自己。</p></div><footer class=entry-footer><span title='2017-08-21 23:08:33 +0000 UTC'>2017-08-21 23:08:33</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;2 字</footer><a class=entry-link aria-label="post link to 关于写博客的一些想法" href=https://barnett617.github.io/wilson-blog/notes/2017-08-21-thinking/></a></article><article class=post-entry><header class=entry-header><h2>在Vultr上搭建ss，包含最简版centos7安装过程中的各种坑解决</h2></header><div class=entry-content><p>在 Vultr 上搭建 ss，包含最简版 centos7 安装过程中的各种坑解决
检查是否安装 python 安装 pip pip install shadowsocks pip install M2Crypto M2Crypto 安装前置条件：安装 pcre，然后安装 swig(直接安装 pcre，去安装 swig 会提示 pcre 未安装，即使 pcre 已安装->解决方案，安装 pcre-devel，在发现这个问题之前卡住很久) ...</p></div><footer class=entry-footer><span title='2017-08-16 20:14:53 +0000 UTC'>2017-08-16 20:14:53</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;129 字</footer><a class=entry-link aria-label="post link to 在Vultr上搭建ss，包含最简版centos7安装过程中的各种坑解决" href=https://barnett617.github.io/wilson-blog/posts/2017-08-16-setup-ss-using-vultr-and-centos7/></a></article><article class=post-entry><header class=entry-header><h2>关于python科学计算库numpy学习总结</h2></header><div class=entry-content><p>关于 python 科学计算库 numpy 学习总结
本文中部分 print 输出可能会报错，原因为 python3 的 print 通过函数方式使用，与 python2 中的 print 通过解释执行不同，需要使用 print()进行控制台打印
安装 numpy python3 -m pip install -U pip 更新 pip pip install numpy
安装方式 II pip install ipython ipython –pylab
pylab 模式下会自动导入 SciPy,NumPy,Matplotlib 模块
引入 numpy import numpy as py
使用 numpy arange()函数用于创建同类型多维数组（homogeneous multidimensional array）
用 arange 创建的数组使用 type()查看类型为 ndarray
reshape()函数用于重新构造数组成为其他维度数组
例如：np.arange(20).reshape(4,5)
[[0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]...</p></div><footer class=entry-footer><span title='2017-08-15 14:20:49 +0000 UTC'>2017-08-15 14:20:49</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;401 字</footer><a class=entry-link aria-label="post link to 关于python科学计算库numpy学习总结" href=https://barnett617.github.io/wilson-blog/posts/2017-08-15-python-numpy/></a></article><article class=post-entry><header class=entry-header><h2>mysql远端数据库与本地数据库间导入导出</h2></header><div class=entry-content><p>mysql 远端数据库与本地数据库间导入导出
远程数据库导出 mysqldump -hxxx -uxxx -pxxx 数据库名 > 脚本名.sql sz 脚本名.sql（SecureCRT 将文件下载到本地） 本地数据库导入 若直接用 navicat 运行本脚本，失败 打开 cmd，进入本地数据库，mysql -uxxxx -pxxxx，use 创建好的数据库 source 脚本名.sql，可以将 2MB 以上的 sql 脚本导入 成功执行，完成远端数据库到本地的克隆</p></div><footer class=entry-footer><span title='2017-08-12 16:35:16 +0000 UTC'>2017-08-12 16:35:16</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;29 字</footer><a class=entry-link aria-label="post link to mysql远端数据库与本地数据库间导入导出" href=https://barnett617.github.io/wilson-blog/posts/2017-08-12-mysql-remote-and-local-data-export/></a></article><article class=post-entry><header class=entry-header><h2>关于Linux启动文件rc.local的解惑</h2></header><div class=entry-content><p>rc.local 是 Linux 启动程序在 login 程序前执行的最后一个脚本，有的服务器中在 rc.local 中可能会有一句 touch /var/lock/subsys/local，这是干什么的呢，在百度中没找到，最终在Linuxquestions.org 论坛成功找到满意的解答。
touch 首先要了解 touch 这个命令是做什么用的，在此用于创建一个不存在的文件，详细了解请见Linux touch 命令
解释 /var/lock/subsys/local 这个文件的存在证明 rc.local 这个脚本已经执行过了，目的在于避免这个脚本重复执行，除非这个文件不存在时，它才失效，也就是当系统关闭（shut down）时会发生，翻译的不是很好，原文是
What this does is create a lock file that tells the system that ’local’ is up and running already. It prevents the script from being run twice, as it will fail until the lockfile is removed, which will happen when you shut down.
Typically this is used with bigger services such as database servers and so forth to make sure they are not started twice....</p></div><footer class=entry-footer><span title='2017-08-05 01:23:14 +0000 UTC'>2017-08-05 01:23:14</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;185 字</footer><a class=entry-link aria-label="post link to 关于Linux启动文件rc.local的解惑" href=https://barnett617.github.io/wilson-blog/posts/2017-08-05-linux-rc-local-file/></a></article><article class=post-entry><header class=entry-header><h2>java零碎知识点整理（3）</h2></header><div class=entry-content><p>关于 java 字符串 String 以及 Hashcode 的一些整理
hashcode 即是对象地址的十进制形式，而 equals 方法即是在比较两个对象的 hashcode 是否相等
package com.test.wx.testequals; public class TestEquals { public static void testEquals() { String a = "a"; String b = "a"; boolean result = a.equals(b); System.out.println(result); // true System.out.println(a.hashCode() == b.hashCode()); // true } public static void testEqual() { String a = "a"; String b = "a"; if (a == b) { // true System.out.println("true"); System.out.println(a.hashCode() == b.hashCode()); } else { System....</p></div><footer class=entry-footer><span title='2017-02-08 15:01:26 +0000 UTC'>2017-02-08 15:01:26</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;219 字</footer><a class=entry-link aria-label="post link to java零碎知识点整理（3）" href=https://barnett617.github.io/wilson-blog/notes/2017-02-08-java-basic-03/></a></article><article class=post-entry><header class=entry-header><h2>正则表达式——学习笔记</h2></header><div class=entry-content><p>一些常用正则表达式的整理
非打印字符 1. \t (table)制表符 等价于\x09和\cl 2. \n (line feed)换行符 等价于\x0a和\cJ 3. \v (vertical)垂直制表符 等价于\x0b和\cK 4. \f (form feed)换页符 等价于\x0c和\cL 5. \r (rarriage return)回车符 等价于\x0d和\cM 6. \s (str)匹配任何空白字符，包括空格、制表符、换页符等） 等价于[\f\n\r\t\v] 7. \S匹配任何非空白字符 等价于[^\f\n\r\t\v] 特殊字符 1. ^ 表示匹配输入字符串的开始位置，若在方括号中使用，则表示不接受该字符集合（例如上述\S的等价匹配） 2. $ 匹配输入字符串的结尾，若设置了RegExp对象的Multiline属性，则$也匹配\n或\r 3. ? 匹配前面的子表达式0-1次，或指明一个非贪婪限定符 4. + 匹配前面的子表达式1-n次 5. * 匹配前面的子表达式0-n次 6. . 匹配除换行符（\n）外的任何单字符（相当于windows系统中的?） 7. () 标记一个子表达式的开始和结束位置，子表达式可供以后使用 8. [ 标记一个中括号表达式的开始（）用于字符集合 9. { 标记限定符表达式的开始 10. \ 将下一个字符标记为特殊字符、或原义字符、或后向引用、或八进制转义符 上述所有特殊字符，若要匹配其本身，都需要在其前面加反斜杠来转义使用
限定符 限定符表示给定组件出现多少次才能满足匹配
1. * 0-n次 2. + 1-n次 3....</p></div><footer class=entry-footer><span title='2017-02-07 22:06:19 +0000 UTC'>2017-02-07 22:06:19</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;113 字</footer><a class=entry-link aria-label="post link to 正则表达式——学习笔记" href=https://barnett617.github.io/wilson-blog/notes/2017-02-07-regexp/></a></article><article class=post-entry><header class=entry-header><h2>python零碎知识点整理——注释</h2></header><div class=entry-content><p>python 零碎知识点整理——注释
单行注释 python 的单行注释用#，可在任意位置添加（单独一行或语句/表达式后面，python 是解释型语言，逐行按序解释代码）
多行注释 多行注释使用三个单引号或双引号 这实际上是多行字符串的书写方式，并非 python 本身提倡的多行注释
编码声明注释 出现在 python 脚本第一行或第二行（其他行则无效）的含有 coding:xxx 的注释被认为是对编码方式的声明，详见python 官方文档
从 python3 开始，python 默认使用 utf-8 编码（python3 以前使用 ascii 编码）
平台注释 使 python 程序运行在 windows 平台上，需要在 python 文件的最前面加上#!/usr/bin/python，这说明了程序用的环境的路径</p></div><footer class=entry-footer><span title='2017-02-07 22:05:20 +0000 UTC'>2017-02-07 22:05:20</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;35 字</footer><a class=entry-link aria-label="post link to python零碎知识点整理——注释" href=https://barnett617.github.io/wilson-blog/posts/2017-02-07-python-comment/></a></article><article class=post-entry><header class=entry-header><h2>java零碎知识点整理（2）</h2></header><div class=entry-content><p>构造器（构造方法）
在类实例化时被调用，对实例对象进行初始化
package com.test.wx.testinit; public class Color { int red, green, blue; /** * 以下这个方法不是构造器，构造器没有“void”这个返回值 */ void Color() { red = 10; green = 10; blue = 10; } /** * 这才是正确的构造器，会在类实例化一个对象时被调用，对对象进行初始化 */ Color() { red = 10; green = 10; blue = 10; } void printColor() { System.out.println("red:"+red+"green:"+green+"blue:"+blue); } public static void main(String[] args) { Color color = new Color(); color.printColor(); // red:0green:0blue:0 } } 修饰符（关键字）
final/abstract
abstract 不能与 final 同时使用，abstract类为抽象类，包含抽象的方法待实现，需要其他类继承该类，对抽象方法进行具体实现，而final修饰的类表示该类不可被继承，二者相违背。</p></div><footer class=entry-footer><span title='2017-02-07 20:01:52 +0000 UTC'>2017-02-07 20:01:52</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;72 字</footer><a class=entry-link aria-label="post link to java零碎知识点整理（2）" href=https://barnett617.github.io/wilson-blog/notes/2017-02-07-java-basic-02/></a></article><article class=post-entry><header class=entry-header><h2>java零碎知识点整理（1）</h2></header><div class=entry-content><p>字符串相关方法、数据类型转换、正则表达式
package com.test.wx.teststr; import java.util.regex.Matcher; import java.util.regex.Pattern; public class TestString { public static void intToString() { int i = 10; Integer j = 11; int k = 12; Integer l = 13; String iStr = String.valueOf(i); // String iStr2 = (String)j; // String iStr3 = (String)k; String iStr4 = String.valueOf(l); System.out.println(iStr); System.out.println(iStr4); } public static void indexOfTest() { String quote = "An *onion* a day keeps everyone away!"; int startBound = quote....</p></div><footer class=entry-footer><span title='2017-02-07 17:27:54 +0000 UTC'>2017-02-07 17:27:54</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;256 字</footer><a class=entry-link aria-label="post link to java零碎知识点整理（1）" href=https://barnett617.github.io/wilson-blog/notes/2017-02-07-java-basic-01/></a></article><article class=post-entry><header class=entry-header><h2>windows删除“找不到该项目”的文件</h2></header><div class=entry-content><p>windows 删除“找不到该项目”的文件该怎么办
编写一个自动删除脚本，内容如下：
右键，新建文本文件 重命名为 del.bat 编辑内容：del /F /A /Q \?%1（第一行） rd /S /Q \?%1（第二行） 把要删除的文件直接拖到该脚本上即可删除
原理
方法采纳自百度经验删除文件时提示“找不到该项目”，怎么解决? del 为 windows 删除文件的命令，rd 为 windows 删除目录的命令，/F 为强制删除参数，/A 为根据文件属性删除文件，/Q 为安静删除模式参数（删除全局通配符时不需要确认），后面的\?即为全局通配符（UNC），？表示一个字符，在此仅为"."，即当前电脑</p></div><footer class=entry-footer><span title='2017-02-06 11:47:56 +0000 UTC'>2017-02-06 11:47:56</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;28 字</footer><a class=entry-link aria-label="post link to windows删除“找不到该项目”的文件" href=https://barnett617.github.io/wilson-blog/notes/2017-02-06-windows-missing-file/></a></article><article class=post-entry><header class=entry-header><h2>IDEA2016配置运行基于Maven的Git项目</h2></header><div class=entry-content><p>IDEA2016 配置运行基于 Maven 的 Git 项目
一、IDEA&amp;Maven&amp;Git 作用 IDEA（项目容器） Maven（管理 Jar 和项目打包） Git（版本控制） 二、从远程 clone git 项目 使用工具 clone 下 git 项目
可能问题： 直接通过 git bash 上 git clone 时可能失败
问题解决：使用 TortoiseGit（有时候 TortoiseGit 也可能失败，可能和 gitblit 服务器有关）。
可能项目由多个 module 相互依赖
从 Git 直接 clone 下的项目，未编译，即不含 target 或 out 文件夹（gitignore 中限制编译后的文件被 Git 管理）
但有 pom.xml 文件（Idea 导入基于 Maven 的项目依赖该文件，即导入项目时需找到 pom.xml 文件）
三、将 clone 到本地的 Maven 项目使用 IDEA 编辑（导入或打开） 如果一个项目有多个相互依赖的 module 组成（各自 module 分别有 pom....</p></div><footer class=entry-footer><span title='2016-12-27 20:22:56 +0000 UTC'>2016-12-27 20:22:56</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;179 字</footer><a class=entry-link aria-label="post link to IDEA2016配置运行基于Maven的Git项目" href=https://barnett617.github.io/wilson-blog/posts/2016-12-27-config-idea-for-maven-projects-with-git/></a></article><article class=post-entry><header class=entry-header><h2>Maven学习</h2></header><div class=entry-content><p>Maven 学习
一、什么是 Maven Apache Maven 是一个软件项目管理和综合工具，基于项目对象模型（POM——Project Object Model），Maven 可以从一个中心资料片管理项目构建，报告和文件。
Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。
二、核心 Maven 项目的结构和内容在一个 XML 文件中声明，pom.xml 项目对象模型（POM），这是整个 Maven 系统的基本单元。
三、特性 Apache Maven 是一种创新的软件项目管理工具，提供了一个项目对象模型（POM）文件的新概念来管理项目的构建，相关性和文档。最强大的功能就是能够自动下载项目依赖库。
四、安装配置 JDK（若未按照默认安装在 C 盘，则 PATH 中需要将 jdk 的 bin 目录放在PATH 开头） Maven 根目录（添加 M2_HOME、MAVEN_HOME 都指向 Maven 安装文件夹） 添加到环境变量（添加%M2_HOME%\bin 到 PATH） 验证环境变量配置（mvn -version） 五、启用代理访问 若公司存在防火墙，并使用HTTP 代理服务器阻止用户直接连接到互联网（若使用代理，Maven 将无法下载任何依赖），则需要在 Maven 配置文件（setting.xml）中设置代理服务器，设置完成后保存（无需重启，Maven 是一个批处理文件，调用时会重新读取配置文件）
六、本地仓库 默认本地存储文件夹为用户目录下到.m2 目录，可在配置文件（setting.xml）中修改默认仓库位置，并重新命名</p></div><footer class=entry-footer><span title='2016-12-20 09:28:04 +0800 +0800'>2016-12-20 09:28:04</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;57 字</footer><a class=entry-link aria-label="post link to Maven学习" href=https://barnett617.github.io/wilson-blog/posts/2016-12-20-maven-basic/></a></article><article class=post-entry><header class=entry-header><h2>ECMAScript6(ECMAScript2015)学习笔记</h2></header><div class=entry-content><p>ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在2015 年发布的，所以又称 ECMAScript 2015。
一、ES6 简介 ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在2015 年发布的，所以又称 ECMAScript 2015。
即 ES6 === ES2015
二、ES6 转码器 Babel是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。（chrome 已支持 ES6 解释，亲测可用）大家可以选择自己习惯的工具来使用使用 Babel，具体过程可直接在Babel 官网查看：
三、常用特性 let / const（与传统 var 对比） class / extends / super（面向对象） arrow functions（箭头函数） template string（模板字符串） destructing（解构） default（默认值） rest / arguments（函数参数） 四、特性详解 （1）let 与 var 类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。
var name = "tom"; while (true) { var name = "bar"; console....</p></div><footer class=entry-footer><span title='2016-12-16 15:34:31 +0000 UTC'>2016-12-16 15:34:31</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;734 字</footer><a class=entry-link aria-label="post link to ECMAScript6(ECMAScript2015)学习笔记" href=https://barnett617.github.io/wilson-blog/posts/2016-12-15-es6-learning/></a></article><article class=post-entry><header class=entry-header><h2>Java基础算法（插入、选择、冒泡、快排）</h2></header><div class=entry-content><p>Java 基础算法（插入、选择、冒泡、快排）
一、直接插入排序 1、原理 从待排序的数中选出一个来，插入到前面的合适位置。
2、适用场景 基本有序的数据
3、代码实现 static int data[] = {12, 6, 17, 108, 97, 93, 256, 1024}; public static void insertSort() { int tmp, i = 0; // 遍历数组 for(int j = 0; j&lt;data.length; j++) { // 依次取出每个数放入tmp tmp = data[j]; // 将取出的数与之前面一个比较 i = j - 1; // 若小于前面一个数，则将前面一个数后移（覆盖取出来的这个数的位置） while(i >= 0 && tmp &lt; data[i]) { data[i+1] = data[i]; // 继续和再前面一个数比较 i--; } // 将取出的数插入 data[i+1] = tmp; System....</p></div><footer class=entry-footer><span title='2016-12-15 23:20:37 +0000 UTC'>2016-12-15 23:20:37</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;346 字</footer><a class=entry-link aria-label="post link to Java基础算法（插入、选择、冒泡、快排）" href=https://barnett617.github.io/wilson-blog/notes/2016-12-15-java-basic-sort-algorithms/></a></article><article class=post-entry><header class=entry-header><h2>可复用面向对象软件基础——设计模式（六）之原型模式</h2></header><div class=entry-content><p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。
一、原型模式（Prototype） /** * 原型类，实现可复制接口 * @author barnett * */ public class Prototype implements Cloneable { /** * 复制方法，调用父类的复制方法 */ public Object clone() throws CloneNotSupportedException { Prototype prototype = (Prototype) super.clone(); return prototype; } } 很简单，一个原型类，只需要实现Cloneable接口，覆写 clone 方法，此处 clone 方法可以改成任意的名称，因为 Cloneable 接口是个空接口，你可以任意定义实现类的方法名，如 cloneA 或者 cloneB。
因为此处的重点是 super.clone()这句话，super.clone()调用的是 Object 的 clone()方法，而在 Object 类中，clone()是 native 的。
二、深浅复制 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。
public class PrototypeDeepAndThinClone implements Cloneable, Serializable { private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; // 浅复制 public Object clone() throws CloneNotSupportedException { Prototype prototype = (Prototype) super....</p></div><footer class=entry-footer><span title='2016-12-15 21:06:11 +0000 UTC'>2016-12-15 21:06:11</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;177 字</footer><a class=entry-link aria-label="post link to 可复用面向对象软件基础——设计模式（六）之原型模式" href=https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-06/></a></article><article class=post-entry><header class=entry-header><h2>可复用面向对象软件基础——设计模式（五）之建造者模式</h2></header><div class=entry-content><p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的。
代码实现 /** * 发送接口，有一个发送方法待实现 * @author barnett * */ public interface Sender { public void send(); } /** * 2、邮件发送类，实现发送接口，实现其发送方法，用以发送邮件 * @author barnett * */ public class MailSender implements Sender { @Override public void send() { System.out.println("I am MailSender!"); } } /** * 短信发送类，实现了发送接口的发送方法，用以发送短信 * @author barnett * */ public class SmsSender implements Sender { @Override public void send() { System.out.println("I am SmsSender!"); } } /** * 3、建造者类 * @author barnett * */ public class Builder { // 用以存储生产出的多个发送器 private List&lt;Sender> list = new ArrayList&lt;Sender>(); /** * 用于生产邮件发送器，当该方法被调用时会生产多个邮件发送器放入集合 * @param count 生产个数 */ public void produceMailSender(int count) { for(int i=0; i&lt;count; i++) { list....</p></div><footer class=entry-footer><span title='2016-12-15 20:22:46 +0000 UTC'>2016-12-15 20:22:46</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;164 字</footer><a class=entry-link aria-label="post link to 可复用面向对象软件基础——设计模式（五）之建造者模式" href=https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-05/></a></article><article class=post-entry><header class=entry-header><h2>可复用面向对象软件基础——设计模式（四）之单例模式</h2></header><div class=entry-content><p>单例对象（Singleton）是一种常用的设计模式。在 Java 应用中，单例对象能保证在一个 JVM 中，该对象只有一个实例存在。
单例模式优势 某些类创建繁琐，对于一些大型对象，系统开销大 省去 new 操作符，降低系统内存使用频率，减轻 GC 压力 保证某些核心类独立控制系统整个流程（控制其不可实例多个） 简版单例类 public class Singleton { // 持有私有静态实例，防止被引用，此处赋值为null，目的为实现延迟加载 private static Singleton instance = null; // 私有构造方法，防止被实例化 private Singleton() { } // 静态工厂方法 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } // 如果该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() { return instance; } } 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对 getInstance 方法加synchronized关键字，如下：
// 静态工厂方法 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } 但是，synchronized 关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用 getInstance()，都要对对象上锁。...</p></div><footer class=entry-footer><span title='2016-12-15 19:57:13 +0000 UTC'>2016-12-15 19:57:13</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;295 字</footer><a class=entry-link aria-label="post link to 可复用面向对象软件基础——设计模式（四）之单例模式" href=https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-04/></a></article><article class=post-entry><header class=entry-header><h2>可复用面向对象软件基础——设计模式（三）之抽象工厂模式</h2></header><div class=entry-content><p>一、工厂方法模式缺陷 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须修改工厂类，这违背了设计模式六大原则第一条闭包原则。
所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
二、抽象工厂模式实现 /** * 1、邮寄接口，有一个抽象邮寄方法待实现 * @author barnett * */ public interface Sender { public void send(); } /** * 2、实现类，邮件邮寄类实现邮寄接口，实现其邮寄的方法 * @author barnett * */ public class MailSender implements Sender { @Override public void send() { System.out.println("I am MailSender!"); } } /** * 短信邮寄类实现邮寄接口，实现其邮寄方法 * @author barnett * */ public class SmsSender implements Sender { @Override public void send() { System.out.println("I am SmsSender!"); } } /** * 3、提供器接口，返回邮寄对象，其生产方法待实现 * 工厂依靠实现该接口，生产产品（Sender） * @author barnett * */ public interface Provider { public Sender produce(); } /** * 4、工厂，邮件邮寄工厂，负责专门生产邮件邮寄实例 * @author barnett * */ public class SendMailFactory implements Provider { @Override public Sender produce() { return new MailSender(); } } /** * 短信邮寄工厂，专门生产短信邮寄实例 * @author barnett * */ public class SendSmsFactory implements Provider { @Override public Sender produce() { return new SmsSender(); } } /** * 5、测试类 * @author barnett * */ public class Test { public static void main(String[] args) { // 实例一个邮件工厂(因其实现了提供器接口，可返回一个具有专门生产某种产品生产方法的实例） Provider provider = new SendMailFactory(); // 通过该实例生产产品 Sender sender = provider....</p></div><footer class=entry-footer><span title='2016-12-15 16:59:43 +0000 UTC'>2016-12-15 16:59:43</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;188 字</footer><a class=entry-link aria-label="post link to 可复用面向对象软件基础——设计模式（三）之抽象工厂模式" href=https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-03/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://barnett617.github.io/wilson-blog/page/6/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://barnett617.github.io/wilson-blog/page/8/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>