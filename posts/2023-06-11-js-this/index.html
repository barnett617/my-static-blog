<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript的this关键字 | Wilson's Blog</title>
<meta name=keywords content="JavaScript"><meta name=description content="关于JavaScript的关键字this的原理的学习"><meta name=author content><link rel=canonical href=https://www.fexapp.org/posts/2023-06-11-js-this/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.7822ca91becd3fe515c67241030e80de043ab22dea5278258d676181168c3c52.css integrity="sha256-eCLKkb7NP+UVxnJBAw6A3gQ6si3qUngljWdhgRaMPFI=" rel="preload stylesheet" as=style><link rel=icon href=https://www.fexapp.org/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.fexapp.org/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.fexapp.org/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://www.fexapp.org/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://www.fexapp.org/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.fexapp.org/posts/2023-06-11-js-this/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JavaScript的this关键字"><meta property="og:description" content="关于JavaScript的关键字this的原理的学习"><meta property="og:type" content="article"><meta property="og:url" content="https://www.fexapp.org/posts/2023-06-11-js-this/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-11T00:42:00+00:00"><meta property="article:modified_time" content="2023-06-11T00:42:00+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="JavaScript的this关键字"><meta name=twitter:description content="关于JavaScript的关键字this的原理的学习"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.fexapp.org/posts/"},{"@type":"ListItem","position":2,"name":"JavaScript的this关键字","item":"https://www.fexapp.org/posts/2023-06-11-js-this/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript的this关键字","name":"JavaScript的this关键字","description":"关于JavaScript的关键字this的原理的学习","keywords":["JavaScript"],"articleBody":" 本文为历史博客迁移\n我们先看一下MDN对于this的定义：this 值是当前执行代码的环境对象\n其中有几个关键词需要捕捉：【当前】、【环境】、【对象】\n如果不能彻底搞清js中this的机制，可能js使用者只能用两种方式和它打交道：\n【1】是记住this的四种场景 【2】是使用js所提供的手段来使this指向变得可控\n四种场景 一、全局环境 如果在全局执行环境使用this，那它毋庸置疑是在指向全局对象，至于这个全局对象具体值是什么，要决定于环境。比如在浏览器中的全局对象是window，在nodejs环境中却又叫作global。\n不过现在js有了无视环境的统一调用全局this的方式，即一个叫作globalThis的对象，其在不同的环境下就是不同环境所对应的全局对象。\n二、函数环境 非严格模式全局环境直接调用函数\nvar func = function () { console.log(this); console.log(this === globalThis); // true }; func(); 严格模式全局环境直接调用函数\nvar func = function () { \"use strict\"; console.log(this); // undefined }; func(); 那么这里要提到另外两个知识点：apply 和 call，它们可以把 this 的值从一个环境传到另一个环境，为什么要有这样的东西呢，或者说怎么理解它们的存在呢。举个例子：\nfunction say() { var intro = \"hello world\"; console.log(this.intro); } say(); // undefined var tom = { name: \"Tom\", intro: \"Hello, I am Tom\", }; var jerry = { name: \"jerry\", intro: \"Hello, I am Jerry\", }; say.call(tom); // Hello, I am Tom 我们来品一品这个例子，现在我们想弄清楚这样几件事情：\nthis 是什么来着？ 为什么要用 this call 是干嘛的 不用 this 怎么办 this 是什么来着？ 首先，this是什么来着？当前执行代码的环境对象，我们可以简记为当前环境（也有其他地方专业称呼其为执行上下文，但那样很明显不利于理解）\n为什么要用 this 接着，我们为什么要用this。当然就是因为它的定位，它是js提供给我们在任意地方获取当前环境的一个对象。听起来它好像是一个动态的对象，在任何时候你想要访问当前环境都能通过它拿到。js不是有着复杂的各种关系链么，什么原型链啊，作用域链啊，各种嵌套关联，会让你觉得乱糟糟的，但是this永远都保持着自己明确的定位，无论你所处怎样复杂的关系链中，它都能给到你当前环境。\n这样看来，我们是不是应该重新认识this，抛开以前的偏见，它其实是js提供给你的一个工具，而不是为了把你弄晕的。\n我们拿这个例子说明，有一个打招呼方法叫say，它输出的是当前环境的自我介绍，这是say方法的声明内容，但这里只是声明了这个函数是做什么的，具体它输出的是什么，还得看函数执行时的当前环境是什么。比如直接执行，那么当前环境是什么，是全局。全局对象没有自我介绍intro，所以输出的就是undefined。\ncall 是干嘛的 那么，call是干嘛的？上面说了，它是用来将this的值从一个环境传到另一个环境的。听起来还是有点晦涩难懂，但感觉上好像做了偷梁换柱的事情，有点闭包里提到的打破阴阳两界的味儿了。\n那么我们结合例子看看能不能探究一下call是做啥的，say.call(tom)输出了tom的自我介绍，诶？首先，我们拿到了say方法的输出，说明say方法被执行了，但是say.call(tom)没有看出say方法的执行，说明在say.call内部执行了say方法。另外，执行结果表示执行say的时候当前环境是tom，因为say的功能是输出当前环境的自我介绍嘛，Hello, I am Tom是 tom 的自我介绍，这不就等同于当前环境 = tom吗。\n于是我们探究出say.call(tom)做了两件事情：\n执行了say方法 执行say方法时的当前环境是tom 这就是call干的事情。\n不用 this 怎么办 那么最后，如果不用this，有没有别的方法达到同样的效果。我们很自然会想到通过给函数增加参数，来获取外部信息，连通函数内外部，在函数内访问函数外的变量。如下：\nfunction say(intro) { console.log(intro); } say(); // undefined var handler = say; handler(); // undefined var tom = { name: \"Tom\", intro: \"Hello, I am Tom\", }; var jerry = { name: \"jerry\", intro: \"Hello, I am Jerry\", }; say(tom.intro); // Hello, I am Tom 虽然输出结果和上面一样，但这样好像总是差点味儿。既然存在this这样的东西，那么一定有它的道理，我们看看有没有什么this不可取代的地方。\n首先，函数的功能变掉了，原来的函数是“输出当前环境的自我介绍”，现在是输出“入参的自我介绍”，原来的输出决定于函数调用时的当前环境，现在变成传参就有结果，不传就没结果。\n另外，对比say.call(tom)和say(tom.intro)，之前传给call的是一个对象，函数会自动从对象中取出intro，因为输出的是当前环境的自我介绍，即this.intro，那么传入的对象便是this。但say(tom.intro)传入的则需是自我介绍本身，因为say函数输出的正是参数本身。\n这样看来，使用参数的函数是不是相较于使用this的要有失灵活一些，this虽包含着不确定性，但是却能灵活“动态”地提供当前环境。相比之下，函数传参是更加充满确定性和可控性，函数输出能够一眼看出来龙去脉的。对于二者的使用当然是要“因地制宜，择优录取”。\n最后我们做一个对于call的总结，我们可以巧妙地理解其为以下几点：\ncall 是函数对象才有的方法（因为call是调用的意思，函数才能被调用） call 也是打电话、招呼的意思，所以func.call(obj)可以理解为函数func呼叫obj来应援 func找obj应援，obj自然会成为“座上宾”，所以 func 被执行时的当前环境就是obj 当前环境（this）是一个对象，所以call的参数应该是一个对象，所以这里用obj来表示 三、对象方法被调用 当函数作为对象的方法被调用时，this 即是调用方法的对象。例如：\nvar obj = { name: \"obj\", sayHello: function () { console.log(this.name + \"'s method says hello\"); }, }; function sayHello() { console.log(\"funciton declaration says hello\"); } var exp = function () { console.log(\"function expression says hello\"); }; obj.sayHello(); sayHello(); exp(); // obj's method says hello // funciton declaration says hello // function expression says hello 这里也就区分了函数和方法叫法的区别，函数就是通过函数声明或函数表达式声明的普通函数，而叫作方法是因为函数作为对象的一个属性而存在（函数在 js 被认定为一等公民，可以同变量一样作为属性、参数、函数返回值等）\n四、new 使用new调用函数时，是把函数当作构造函数在调用，此时的this会指向构造出来的新对象（实例）。例如：\nfunction classA() { this.from = \"A\"; } var instance = new classA(); console.log(instance.from); // A 这里函数内部在操作this并向其添加属性from，然后使用new调用，则执行函数classA时，其内部的this即是instance，于是instance便在诞生之初就有了from属性。\n原生提供的可控方法 bind 既然每次函数执行时的当前环境都可能变化，充满着不确定性，那么有没有什么办法把它捆着不动，那就是bind方法，bind意为“绑定”，其效果也如其名，一旦绑定，不会再被修改。但bind方法很明确自己的任务只是绑定当前环境，至于函数何时执行、怎么执行不归其管，这区别于call和 apply 在指定了当前环境后还把函数执行了。\n我们需要记住bind的特性只有两个：\n一经绑定，不再修改 只作绑定，不会执行 实例如下：\nfunction func() { console.log(this.intro); } var tom = { name: \"Tom\", intro: \"I am Tom\", }; var jerry = { name: \"Jerry\", intro: \"I am Jerry\", }; var tomFunc = func.bind(tom); var jerryFunc = tomFunc.bind(jerry); tomFunc(); // I am Tom jerryFunc(); // I am Tom 箭头函数 先看 MDN 中关于箭头函数的“权威解释“：”在箭头函数中，this 与封闭词法环境的 this 保持一致“，虽然言简意赅，但是晦涩难懂且包含专业名词，什么是”封闭词法环境“？？\n我们先来捕捉一些箭头函数的特性，然后从其特性推断出其是一个怎样的东西\n没有自己的 this 指针 不能用作构造器 没有 prototype 属性 不绑定 Arguments 对象 没有自己的 super 其实把”箭头函数的 this 与封闭词法环境的 this 保持一致“转而描述为”箭头函数的 this 总与其被创建时的环境一致“会更好理解一点。举例如下：\nvar globalObject = this; var foo = () =\u003e this; console.log(foo() === globalObject); // true // 接着上面的代码 // 作为对象的一个方法调用 var obj = { foo: foo }; console.log(obj.foo() === globalObject); // true // 尝试使用call来设定this console.log(foo.call(obj) === globalObject); // true // 尝试使用bind来设定this foo = foo.bind(obj); console.log(foo() === globalObject); // true 总结一下箭头函数，谨记一点即可“当创建一个箭头函数的时候，就确定这个箭头函数的 this 和创建时所在作用域的 this 一致了”。\n附录 call 的模拟实现 call 的实现依赖如下：\n通过 this 获取调用 call 方法的对象（即要修改 this 的函数） 通过 arguments 获取调用 call 方法时传递的参数 通过 eval 动态解析字符串以实现修改 this 后的函数执行时访问 call 接收到的不确定参数 var tom = { name: \"Tom\", func: function (type, desc) { if (type \u0026\u0026 desc) { return this.name + \" is a \" + desc + \" \" + type; } else { return \"Just \" + this.name; } }, }; var jerry = { name: \"Jerry\", }; var me = { name: \"me\", }; var print = console.log; print(tom.func(\"cat\", \"big\")); print(tom.func.call(jerry, \"mouse\", \"small\")); print(tom.func.call(me)); // Tom is a big cat // Jerry is a small mouse // Just me Function.prototype.myCall = function (obj) { // 参数分别判空处理 if (!obj) obj = globalThis; // this是调用本函数的函数 obj.func = this; // 要换用指定的this(这里的obj)去执行要被执行的函数(func) // 并且传入指定参数(args) // 函数执行结果是返回函数的返回值 var result; if (!arguments[1]) { result = obj.func(); } else { var params = []; for (var i = 1; i \u003c arguments.length; i++) { params.push(\"arguments[\" + i + \"]\"); } result = eval(\"obj.func(\" + params + \")\"); // eval解析出的结果如：obj.func(arguments[1], arguments[2], ...) } delete obj.func; return result; // 执行结束要去掉新捆绑的属性 }; print(tom.func(\"cat\", \"big\")); print(tom.func.myCall(jerry, \"mouse\", \"small\")); print(tom.func.myCall(me)); // Tom is a big cat // Jerry is a small mouse // Just me apply 的模拟实现 apply 实现与 call 类似，但 apply 获取的参数是以一个数组整体的形式存在的，而 call 获取到的是不确定数量的参数。\nvar tom = { name: \"Tom\", func: function (type, desc) { if (type \u0026\u0026 desc) { return this.name + \" is a \" + desc + \" \" + type; } else { return \"Just \" + this.name; } }, }; var jerry = { name: \"Jerry\", }; var me = { name: \"me\", }; var print = console.log; print(tom.func(\"cat\", \"big\")); print(tom.func.apply(jerry, [\"mouse\", \"small\"])); print(tom.func.apply(me)); // Tom is a big cat // Jerry is a small mouse // Just me // 区别于call方法，apply方法的第二个参数是一个数组 Function.prototype.myApply = function (thisObj, args) { if (!thisObj) thisObj = globalThis; thisObj.func = this; var result; if (!args) { result = thisObj.func(); } else { // params用于组装参数字符串，以备eval解析使用 var params = []; for (var i = 0; i \u003c args.length; i++) { params.push(\"args[\" + i + \"]\"); } result = eval(\"thisObj.func(\" + params + \")\"); // 解析结果如 thisObj.func(args[0], args[1], ...) } delete thisObj.func; return result; }; print(tom.func(\"cat\", \"big\")); print(tom.func.myApply(jerry, [\"mouse\", \"small\"])); print(tom.func.myApply(me)); // Tom is a big cat // Jerry is a small mouse // Just me bind 的模拟实现 bind 的实现依赖如下：\n因为最终新函数要使用新绑定的 this 进行执行，所以需要依赖于 call 或 apply 如果内部把参数处理为数组形式，则可仅依赖 apply，如果参数为零散方式则依赖 call 至于绑定时所作的参数处理也可以不依赖于 call 或 apply 操作，通过遍历方式完成 var tom = { name: \"Tom\", func: function (type, desc, log) { if (type \u0026\u0026 desc) { if (log) { console.log(log); } return this.name + \" is a \" + desc + \" \" + type; } else { return \"Just \" + this.name; } }, }; var jerry = { name: \"Jerry\", }; var me = { name: \"me\", }; var print = console.log; print(tom.func(\"cat\", \"big\")); print(tom.func.bind(jerry, \"mouse\", \"small\")(\"Jerry comes at \" + new Date())); print(tom.func.bind(me)()); // Tom is a big cat // Jerry comes at Fri Apr 24 2020 18:48:32 GMT+0800 (GMT+08:00) // Jerry is a small mouse // Just me // bind函数接收第一个参数用于作为新绑定的this,后续可选参数作为绑定时传入该函数的参数 // 返回一个绑定后的函数,该函数并不立即调用,并且在以后的调用时仍可传入新的参数 Function.prototype.myBind = function () { // 调用bind的this即是要改变this的函数 var func = this; // 拷贝一份参数,arguments是一个类数组,无法直接调用数组的方法 var args = Array.prototype.slice.call(arguments); // 参数第一个是调用当前函数的this对象 // 这里从arguments中获取调用bind函数的this,也可以直接从函数形参中取 var object = args.shift(); // 首选确定bind函数返回的是一个函数,而不是什么确定的值 // 因为js中函数是一等公民,所以可以想象为同样返回了一个变量,只不过这个变量可以执行 // 这里会产生闭包,当bind函数返回后,bind函数内的变量仍未被回收,并且在外部新函数调用时可以访问到 return function () { // 这里的arguments已经是调用新函数时传入的新参数 // 新的函数被执行时要有使用新this和新参数执行的结果返回 // 因为最终执行时调用了apply，所以没有对新this做判空处理，由apply内部去做 return func.apply( object, args.concat(Array.prototype.slice.call(arguments)) ); }; }; print(tom.func(\"cat\", \"big\")); print(tom.func.myBind(jerry, \"mouse\", \"small\")(\"Jerry comes at \" + new Date())); print(tom.func.myBind(me)()); print(tom.func.myBind()()); // Tom is a big cat // Jerry comes at Fri Apr 24 2020 18:48:32 GMT+0800 (GMT+08:00) // Jerry is a small mouse // Just me // Just undefined 代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/4-this/index.md\n","wordCount":"990","inLanguage":"zh","datePublished":"2023-06-11T00:42:00Z","dateModified":"2023-06-11T00:42:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.fexapp.org/posts/2023-06-11-js-this/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://www.fexapp.org/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.fexapp.org/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://www.fexapp.org/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.fexapp.org/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://www.fexapp.org/archives title=时间线><span>时间线</span></a></li><li><a href=https://www.fexapp.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://www.fexapp.org/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://www.fexapp.org/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">JavaScript的this关键字</h1><div class=post-meta><span title='2023-06-11 00:42:00 +0000 UTC'>2023-06-11 00:42:00</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;990 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2023-06-11-js-this.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#四种场景>四种场景</a><ul><li><a href=#一全局环境>一、全局环境</a></li><li><a href=#二函数环境>二、函数环境</a></li><li><a href=#三对象方法被调用>三、对象方法被调用</a></li><li><a href=#四new>四、new</a></li></ul></li><li><a href=#原生提供的可控方法>原生提供的可控方法</a><ul><li><a href=#bind>bind</a></li><li><a href=#箭头函数>箭头函数</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#call-的模拟实现>call 的模拟实现</a></li><li><a href=#apply-的模拟实现>apply 的模拟实现</a></li><li><a href=#bind-的模拟实现>bind 的模拟实现</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>本文为历史博客迁移</p></blockquote><p>我们先看一下<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this>MDN</a>对于<code>this</code>的定义：this 值是<code>当前执行代码的环境对象</code></p><p>其中有几个关键词需要捕捉：【当前】、【环境】、【对象】</p><p>如果不能彻底搞清<code>js</code>中<code>this</code>的机制，可能<code>js</code>使用者只能用两种方式和它打交道：</p><p>【1】是记住<code>this</code>的四种场景
【2】是使用<code>js</code>所提供的手段来使<code>this</code>指向变得可控</p><h2 id=四种场景>四种场景<a hidden class=anchor aria-hidden=true href=#四种场景>#</a></h2><h3 id=一全局环境>一、全局环境<a hidden class=anchor aria-hidden=true href=#一全局环境>#</a></h3><p>如果在全局执行环境使用<code>this</code>，那它毋庸置疑是在指向<code>全局对象</code>，至于这个全局对象具体值是什么，要决定于环境。比如在浏览器中的全局对象是<code>window</code>，在<code>nodejs</code>环境中却又叫作<code>global</code>。</p><p>不过现在<code>js</code>有了无视环境的统一调用全局<code>this</code>的方式，即一个叫作<code>globalThis</code>的对象，其在不同的环境下就是不同环境所对应的全局对象。</p><h3 id=二函数环境>二、函数环境<a hidden class=anchor aria-hidden=true href=#二函数环境>#</a></h3><p>非严格模式全局环境直接调用函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>func</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span> <span class=o>===</span> <span class=nx>globalThis</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>func</span><span class=p>();</span>
</span></span></code></pre></div><p>严格模式全局环境直接调用函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>func</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;use strict&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>func</span><span class=p>();</span>
</span></span></code></pre></div><p>那么这里要提到另外两个知识点：apply 和 call，它们可以把 this 的值从一个环境传到另一个环境，为什么要有这样的东西呢，或者说怎么理解它们的存在呢。举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>say</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>intro</span> <span class=o>=</span> <span class=s2>&#34;hello world&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>intro</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>say</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tom</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>intro</span><span class=o>:</span> <span class=s2>&#34;Hello, I am Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerry</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>intro</span><span class=o>:</span> <span class=s2>&#34;Hello, I am Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>say</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>tom</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Hello, I am Tom
</span></span></span></code></pre></div><p>我们来品一品这个例子，现在我们想弄清楚这样几件事情：</p><ol><li>this 是什么来着？</li><li>为什么要用 this</li><li>call 是干嘛的</li><li>不用 this 怎么办</li></ol><h4 id=this-是什么来着>this 是什么来着？<a hidden class=anchor aria-hidden=true href=#this-是什么来着>#</a></h4><p>首先，<code>this</code>是什么来着？<code>当前执行代码的环境对象</code>，我们可以简记为<code>当前环境</code>（也有其他地方专业称呼其为<code>执行上下文</code>，但那样很明显不利于理解）</p><h4 id=为什么要用-this>为什么要用 this<a hidden class=anchor aria-hidden=true href=#为什么要用-this>#</a></h4><p>接着，我们为什么要用<code>this</code>。当然就是因为它的定位，它是<code>js</code>提供给我们在任意地方获取<code>当前环境</code>的一个对象。听起来它好像是一个动态的对象，在任何时候你想要访问当前环境都能通过它拿到。<code>js</code>不是有着复杂的各种关系链么，什么<a href=../2023-06-11-js-inherit>原型链</a>啊，作用域链啊，各种嵌套关联，会让你觉得乱糟糟的，但是<code>this</code>永远都保持着自己明确的定位，无论你所处怎样复杂的关系链中，它都能给到你<code>当前环境</code>。</p><p>这样看来，我们是不是应该重新认识<code>this</code>，抛开以前的偏见，它其实是<code>js</code>提供给你的一个<code>工具</code>，而不是为了把你弄晕的。</p><p>我们拿这个例子说明，有一个打招呼方法叫<code>say</code>，它输出的是当前环境的自我介绍，这是<code>say</code>方法的声明内容，但这里只是声明了这个函数是做什么的，具体它输出的是什么，还得看函数执行时的<code>当前环境</code>是什么。比如直接执行，那么当前环境是什么，是全局。全局对象没有自我介绍<code>intro</code>，所以输出的就是<code>undefined</code>。</p><h4 id=call-是干嘛的>call 是干嘛的<a hidden class=anchor aria-hidden=true href=#call-是干嘛的>#</a></h4><p>那么，<code>call</code>是干嘛的？上面说了，它是用来将<code>this</code>的值从一个环境传到另一个环境的。听起来还是有点晦涩难懂，但感觉上好像做了偷梁换柱的事情，有点<a href=../2023-06-11-js-closure>闭包</a>里提到的打破阴阳两界的味儿了。</p><p>那么我们结合例子看看能不能探究一下<code>call</code>是做啥的，<code>say.call(tom)</code>输出了<code>tom</code>的自我介绍，诶？首先，我们拿到了<code>say</code>方法的输出，说明<code>say</code>方法被执行了，但是<code>say.call(tom)</code>没有看出<code>say</code>方法的执行，说明在<code>say.call</code>内部执行了<code>say</code>方法。另外，执行结果表示执行<code>say</code>的时候当前环境是<code>tom</code>，因为<code>say</code>的功能是输出当前环境的自我介绍嘛，<code>Hello, I am Tom</code>是 tom 的自我介绍，这不就等同于<code>当前环境 = tom</code>吗。</p><p>于是我们探究出<code>say.call(tom)</code>做了两件事情：</p><ol><li>执行了<code>say</code>方法</li><li>执行<code>say</code>方法时的当前环境是<code>tom</code></li></ol><p>这就是<code>call</code>干的事情。</p><h4 id=不用-this-怎么办>不用 this 怎么办<a hidden class=anchor aria-hidden=true href=#不用-this-怎么办>#</a></h4><p>那么最后，如果不用<code>this</code>，有没有别的方法达到同样的效果。我们很自然会想到通过给函数增加参数，来获取外部信息，连通函数内外部，在函数内访问函数外的变量。如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>say</span><span class=p>(</span><span class=nx>intro</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>intro</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>say</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>handler</span> <span class=o>=</span> <span class=nx>say</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>handler</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tom</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>intro</span><span class=o>:</span> <span class=s2>&#34;Hello, I am Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerry</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>intro</span><span class=o>:</span> <span class=s2>&#34;Hello, I am Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>say</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>intro</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Hello, I am Tom
</span></span></span></code></pre></div><p>虽然输出结果和上面一样，但这样好像总是差点味儿。既然存在<code>this</code>这样的东西，那么一定有它的道理，我们看看有没有什么<code>this</code>不可取代的地方。</p><p>首先，函数的功能变掉了，原来的函数是“输出当前环境的自我介绍”，现在是输出“入参的自我介绍”，原来的输出决定于函数调用时的当前环境，现在变成传参就有结果，不传就没结果。</p><p>另外，对比<code>say.call(tom)</code>和<code>say(tom.intro)</code>，之前传给<code>call</code>的是一个对象，函数会自动从对象中取出<code>intro</code>，因为输出的是当前环境的自我介绍，即<code>this.intro</code>，那么传入的对象便是<code>this</code>。但<code>say(tom.intro)</code>传入的则需是自我介绍本身，因为<code>say</code>函数输出的正是参数本身。</p><p>这样看来，使用参数的函数是不是相较于使用<code>this</code>的要有失灵活一些，<code>this</code>虽包含着不确定性，但是却能灵活“动态”地提供<code>当前环境</code>。相比之下，函数传参是更加充满确定性和可控性，函数输出能够一眼看出来龙去脉的。对于二者的使用当然是要“因地制宜，择优录取”。</p><p>最后我们做一个对于<code>call</code>的总结，我们可以巧妙地理解其为以下几点：</p><ol><li>call 是函数对象才有的方法（因为<code>call</code>是调用的意思，函数才能被调用）</li><li>call 也是打电话、招呼的意思，所以<code>func.call(obj)</code>可以理解为函数<code>func</code>呼叫<code>obj</code>来应援</li><li><code>func</code>找<code>obj</code>应援，<code>obj</code>自然会成为“座上宾”，所以 func 被执行时的<code>当前环境</code>就是<code>obj</code></li><li>当前环境（this）是一个对象，所以<code>call</code>的参数应该是一个对象，所以这里用<code>obj</code>来表示</li></ol><h3 id=三对象方法被调用>三、对象方法被调用<a hidden class=anchor aria-hidden=true href=#三对象方法被调用>#</a></h3><p>当函数作为对象的方法被调用时，this 即是调用方法的对象。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;obj&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>sayHello</span><span class=o>:</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34;&#39;s method says hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>sayHello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;funciton declaration says hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>exp</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;function expression says hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>sayHello</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>sayHello</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>exp</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// obj&#39;s method says hello
</span></span></span><span class=line><span class=cl><span class=c1>// funciton declaration says hello
</span></span></span><span class=line><span class=cl><span class=c1>// function expression says hello
</span></span></span></code></pre></div><p>这里也就区分了<code>函数</code>和<code>方法</code>叫法的区别，函数就是通过函数声明或函数表达式声明的普通函数，而叫作<code>方法</code>是因为函数作为对象的一个属性而存在（函数在 js 被认定为一等公民，可以同变量一样作为属性、参数、函数返回值等）</p><h3 id=四new>四、new<a hidden class=anchor aria-hidden=true href=#四new>#</a></h3><p>使用<code>new</code>调用函数时，是把函数当作<code>构造函数</code>在调用，此时的<code>this</code>会指向构造出来的新对象（实例）。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>classA</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>from</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>classA</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance</span><span class=p>.</span><span class=nx>from</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// A
</span></span></span></code></pre></div><p>这里函数内部在操作<code>this</code>并向其添加属性<code>from</code>，然后使用<code>new</code>调用，则执行函数<code>classA</code>时，其内部的<code>this</code>即是<code>instance</code>，于是<code>instance</code>便在诞生之初就有了<code>from</code>属性。</p><h2 id=原生提供的可控方法>原生提供的可控方法<a hidden class=anchor aria-hidden=true href=#原生提供的可控方法>#</a></h2><h3 id=bind>bind<a hidden class=anchor aria-hidden=true href=#bind>#</a></h3><p>既然每次函数执行时的当前环境都可能变化，充满着不确定性，那么有没有什么办法把它捆着不动，那就是<code>bind</code>方法，<code>bind</code>意为“绑定”，其效果也如其名，一旦绑定，不会再被修改。但<code>bind</code>方法很明确自己的任务只是绑定当前环境，至于函数何时执行、怎么执行不归其管，这区别于<a href=#call-%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84>call</a>和 apply 在指定了当前环境后还把函数执行了。</p><p>我们需要记住<code>bind</code>的特性只有两个：</p><ol><li>一经绑定，不再修改</li><li>只作绑定，不会执行</li></ol><p>实例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>intro</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tom</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>intro</span><span class=o>:</span> <span class=s2>&#34;I am Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerry</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>intro</span><span class=o>:</span> <span class=s2>&#34;I am Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tomFunc</span> <span class=o>=</span> <span class=nx>func</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>tom</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerryFunc</span> <span class=o>=</span> <span class=nx>tomFunc</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>jerry</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>tomFunc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// I am Tom
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>jerryFunc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// I am Tom
</span></span></span></code></pre></div><h3 id=箭头函数>箭头函数<a hidden class=anchor aria-hidden=true href=#箭头函数>#</a></h3><p>先看 MDN 中关于箭头函数的“权威解释“：”在箭头函数中，this 与封闭词法环境的 this 保持一致“，虽然言简意赅，但是晦涩难懂且包含专业名词，什么是”封闭词法环境“？？</p><p>我们先来捕捉一些箭头函数的特性，然后从其特性推断出其是一个怎样的东西</p><ol><li>没有自己的 this 指针</li><li>不能用作构造器</li><li>没有 prototype 属性</li><li>不绑定 Arguments 对象</li><li>没有自己的 super</li></ol><p>其实把”箭头函数的 this 与封闭词法环境的 this 保持一致“转而描述为”箭头函数的 this 总与其被创建时的环境一致“会更好理解一点。举例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>globalObject</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>foo</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>foo</span><span class=p>()</span> <span class=o>===</span> <span class=nx>globalObject</span><span class=p>);</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 接着上面的代码
</span></span></span><span class=line><span class=cl><span class=c1>// 作为对象的一个方法调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>foo</span><span class=o>:</span> <span class=nx>foo</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>obj</span><span class=p>.</span><span class=nx>foo</span><span class=p>()</span> <span class=o>===</span> <span class=nx>globalObject</span><span class=p>);</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 尝试使用call来设定this
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>foo</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span> <span class=o>===</span> <span class=nx>globalObject</span><span class=p>);</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 尝试使用bind来设定this
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>foo</span> <span class=o>=</span> <span class=nx>foo</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>foo</span><span class=p>()</span> <span class=o>===</span> <span class=nx>globalObject</span><span class=p>);</span> <span class=c1>// true
</span></span></span></code></pre></div><p>总结一下箭头函数，谨记一点即可“当创建一个箭头函数的时候，就确定这个箭头函数的 this 和创建时所在作用域的 this 一致了”。</p><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=call-的模拟实现>call 的模拟实现<a hidden class=anchor aria-hidden=true href=#call-的模拟实现>#</a></h3><p>call 的实现依赖如下：</p><ol><li>通过 this 获取调用 call 方法的对象（即要修改 this 的函数）</li><li>通过 arguments 获取调用 call 方法时传递的参数</li><li>通过 eval 动态解析字符串以实现修改 this 后的函数执行时访问 call 接收到的不确定参数</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tom</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>func</span><span class=o>:</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>type</span><span class=p>,</span> <span class=nx>desc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>type</span> <span class=o>&amp;&amp;</span> <span class=nx>desc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34; is a &#34;</span> <span class=o>+</span> <span class=nx>desc</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=nx>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=s2>&#34;Just &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerry</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>me</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;me&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>print</span> <span class=o>=</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>(</span><span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>jerry</span><span class=p>,</span> <span class=s2>&#34;mouse&#34;</span><span class=p>,</span> <span class=s2>&#34;small&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>me</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// Tom is a big cat
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry is a small mouse
</span></span></span><span class=line><span class=cl><span class=c1>// Just me
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nb>Function</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>myCall</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>obj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 参数分别判空处理
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>obj</span><span class=p>)</span> <span class=nx>obj</span> <span class=o>=</span> <span class=nx>globalThis</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// this是调用本函数的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>obj</span><span class=p>.</span><span class=nx>func</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 要换用指定的this(这里的obj)去执行要被执行的函数(func)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 并且传入指定参数(args)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 函数执行结果是返回函数的返回值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>var</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>arguments</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=nx>obj</span><span class=p>.</span><span class=nx>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>params</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>arguments</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>params</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&#34;arguments[&#34;</span> <span class=o>+</span> <span class=nx>i</span> <span class=o>+</span> <span class=s2>&#34;]&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;obj.func(&#34;</span> <span class=o>+</span> <span class=nx>params</span> <span class=o>+</span> <span class=s2>&#34;)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// eval解析出的结果如：obj.func(arguments[1], arguments[2], ...)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=nx>obj</span><span class=p>.</span><span class=nx>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 执行结束要去掉新捆绑的属性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>(</span><span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myCall</span><span class=p>(</span><span class=nx>jerry</span><span class=p>,</span> <span class=s2>&#34;mouse&#34;</span><span class=p>,</span> <span class=s2>&#34;small&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myCall</span><span class=p>(</span><span class=nx>me</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// Tom is a big cat
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry is a small mouse
</span></span></span><span class=line><span class=cl><span class=c1>// Just me
</span></span></span></code></pre></div><h3 id=apply-的模拟实现>apply 的模拟实现<a hidden class=anchor aria-hidden=true href=#apply-的模拟实现>#</a></h3><p>apply 实现与 call 类似，但 apply 获取的参数是以一个数组整体的形式存在的，而 call 获取到的是不确定数量的参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tom</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>func</span><span class=o>:</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>type</span><span class=p>,</span> <span class=nx>desc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>type</span> <span class=o>&amp;&amp;</span> <span class=nx>desc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34; is a &#34;</span> <span class=o>+</span> <span class=nx>desc</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=nx>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=s2>&#34;Just &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerry</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>me</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;me&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>print</span> <span class=o>=</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>(</span><span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=nx>jerry</span><span class=p>,</span> <span class=p>[</span><span class=s2>&#34;mouse&#34;</span><span class=p>,</span> <span class=s2>&#34;small&#34;</span><span class=p>]));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=nx>me</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// Tom is a big cat
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry is a small mouse
</span></span></span><span class=line><span class=cl><span class=c1>// Just me
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 区别于call方法，apply方法的第二个参数是一个数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Function</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>myApply</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>thisObj</span><span class=p>,</span> <span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>thisObj</span><span class=p>)</span> <span class=nx>thisObj</span> <span class=o>=</span> <span class=nx>globalThis</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>thisObj</span><span class=p>.</span><span class=nx>func</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=nx>thisObj</span><span class=p>.</span><span class=nx>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// params用于组装参数字符串，以备eval解析使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>params</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>args</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>params</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&#34;args[&#34;</span> <span class=o>+</span> <span class=nx>i</span> <span class=o>+</span> <span class=s2>&#34;]&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;thisObj.func(&#34;</span> <span class=o>+</span> <span class=nx>params</span> <span class=o>+</span> <span class=s2>&#34;)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 解析结果如 thisObj.func(args[0], args[1], ...)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=nx>thisObj</span><span class=p>.</span><span class=nx>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>(</span><span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myApply</span><span class=p>(</span><span class=nx>jerry</span><span class=p>,</span> <span class=p>[</span><span class=s2>&#34;mouse&#34;</span><span class=p>,</span> <span class=s2>&#34;small&#34;</span><span class=p>]));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myApply</span><span class=p>(</span><span class=nx>me</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Tom is a big cat
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry is a small mouse
</span></span></span><span class=line><span class=cl><span class=c1>// Just me
</span></span></span></code></pre></div><h3 id=bind-的模拟实现>bind 的模拟实现<a hidden class=anchor aria-hidden=true href=#bind-的模拟实现>#</a></h3><p>bind 的实现依赖如下：</p><ol><li>因为最终新函数要使用新绑定的 this 进行执行，所以需要依赖于 call 或 apply</li><li>如果内部把参数处理为数组形式，则可仅依赖 apply，如果参数为零散方式则依赖 call</li><li>至于绑定时所作的参数处理也可以不依赖于 call 或 apply 操作，通过遍历方式完成</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tom</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>func</span><span class=o>:</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>type</span><span class=p>,</span> <span class=nx>desc</span><span class=p>,</span> <span class=nx>log</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>type</span> <span class=o>&amp;&amp;</span> <span class=nx>desc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>log</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>log</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34; is a &#34;</span> <span class=o>+</span> <span class=nx>desc</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=nx>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=s2>&#34;Just &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jerry</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Jerry&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>me</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;me&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>print</span> <span class=o>=</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>(</span><span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>jerry</span><span class=p>,</span> <span class=s2>&#34;mouse&#34;</span><span class=p>,</span> <span class=s2>&#34;small&#34;</span><span class=p>)(</span><span class=s2>&#34;Jerry comes at &#34;</span> <span class=o>+</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>()));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>me</span><span class=p>)());</span>
</span></span><span class=line><span class=cl><span class=c1>// Tom is a big cat
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry comes at Fri Apr 24 2020 18:48:32 GMT+0800 (GMT+08:00)
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry is a small mouse
</span></span></span><span class=line><span class=cl><span class=c1>// Just me
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// bind函数接收第一个参数用于作为新绑定的this,后续可选参数作为绑定时传入该函数的参数
</span></span></span><span class=line><span class=cl><span class=c1>// 返回一个绑定后的函数,该函数并不立即调用,并且在以后的调用时仍可传入新的参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Function</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>myBind</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 调用bind的this即是要改变this的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>var</span> <span class=nx>func</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 拷贝一份参数,arguments是一个类数组,无法直接调用数组的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>var</span> <span class=nx>args</span> <span class=o>=</span> <span class=nb>Array</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>slice</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>arguments</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 参数第一个是调用当前函数的this对象
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这里从arguments中获取调用bind函数的this,也可以直接从函数形参中取
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>var</span> <span class=nx>object</span> <span class=o>=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>shift</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 首选确定bind函数返回的是一个函数,而不是什么确定的值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 因为js中函数是一等公民,所以可以想象为同样返回了一个变量,只不过这个变量可以执行
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这里会产生闭包,当bind函数返回后,bind函数内的变量仍未被回收,并且在外部新函数调用时可以访问到
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里的arguments已经是调用新函数时传入的新参数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 新的函数被执行时要有使用新this和新参数执行的结果返回
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 因为最终执行时调用了apply，所以没有对新this做判空处理，由apply内部去做
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>func</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nx>object</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>args</span><span class=p>.</span><span class=nx>concat</span><span class=p>(</span><span class=nb>Array</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>slice</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>arguments</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>(</span><span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myBind</span><span class=p>(</span><span class=nx>jerry</span><span class=p>,</span> <span class=s2>&#34;mouse&#34;</span><span class=p>,</span> <span class=s2>&#34;small&#34;</span><span class=p>)(</span><span class=s2>&#34;Jerry comes at &#34;</span> <span class=o>+</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>()));</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myBind</span><span class=p>(</span><span class=nx>me</span><span class=p>)());</span>
</span></span><span class=line><span class=cl><span class=nx>print</span><span class=p>(</span><span class=nx>tom</span><span class=p>.</span><span class=nx>func</span><span class=p>.</span><span class=nx>myBind</span><span class=p>()());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Tom is a big cat
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry comes at Fri Apr 24 2020 18:48:32 GMT+0800 (GMT+08:00)
</span></span></span><span class=line><span class=cl><span class=c1>// Jerry is a small mouse
</span></span></span><span class=line><span class=cl><span class=c1>// Just me
</span></span></span><span class=line><span class=cl><span class=c1>// Just undefined
</span></span></span></code></pre></div><p>代码仓库见: <a href=https://github.com/barnett617/codehub/blob/main/front-end/src/4-this/index.md>https://github.com/barnett617/codehub/blob/main/front-end/src/4-this/index.md</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.fexapp.org/tags/javascript/>JavaScript</a></li></ul><nav class=paginav><a class=prev href=https://www.fexapp.org/posts/2023-06-11-js-promise/><span class=title>« 上一页</span><br><span>JavaScript的Promise学习</span>
</a><a class=next href=https://www.fexapp.org/posts/2023-06-11-js-debounce-and-throttle/><span class=title>下一页 »</span><br><span>JavaScript的防抖和节流</span></a></nav><script async crossorigin=anonymous src=/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share JavaScript的this关键字 on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript的this关键字 on x" href="https://x.com/intent/tweet/?text=JavaScript%e7%9a%84this%e5%85%b3%e9%94%ae%e5%ad%97&amp;url=https%3a%2f%2fwww.fexapp.org%2fposts%2f2023-06-11-js-this%2f&amp;hashtags=JavaScript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.fexapp.org/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>