<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>可复用面向对象软件基础——设计模式（一）之总览 | Wilson's Blog</title>
<meta name=keywords content="设计模式"><meta name=description content="一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类
（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。"><meta name=author content><link rel=canonical href=https://fexapp.org/posts/2016-12-15-design-pattern-01/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.7822ca91becd3fe515c67241030e80de043ab22dea5278258d676181168c3c52.css integrity="sha256-eCLKkb7NP+UVxnJBAw6A3gQ6si3qUngljWdhgRaMPFI=" rel="preload stylesheet" as=style><link rel=icon href=https://fexapp.org/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fexapp.org/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fexapp.org/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://fexapp.org/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://fexapp.org/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://fexapp.org/posts/2016-12-15-design-pattern-01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="可复用面向对象软件基础——设计模式（一）之总览"><meta property="og:description" content="一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类
（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。"><meta property="og:type" content="article"><meta property="og:url" content="https://fexapp.org/posts/2016-12-15-design-pattern-01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-12-15T10:43:05+00:00"><meta property="article:modified_time" content="2017-07-13T20:20:20+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="可复用面向对象软件基础——设计模式（一）之总览"><meta name=twitter:description content="一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类
（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fexapp.org/posts/"},{"@type":"ListItem","position":2,"name":"可复用面向对象软件基础——设计模式（一）之总览","item":"https://fexapp.org/posts/2016-12-15-design-pattern-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"可复用面向对象软件基础——设计模式（一）之总览","name":"可复用面向对象软件基础——设计模式（一）之总览","description":"一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类\n（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。","keywords":["设计模式"],"articleBody":"一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类\n（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。\nLSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。\n（3）依赖倒转原则 这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n（4）接口隔离原则 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思。\n从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。\n（5）迪米特法则（最少知道原则） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。\n（6）合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承。\n","wordCount":"82","inLanguage":"zh","datePublished":"2016-12-15T10:43:05Z","dateModified":"2017-07-13T20:20:20Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fexapp.org/posts/2016-12-15-design-pattern-01/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://fexapp.org/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fexapp.org/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://fexapp.org/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://fexapp.org/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://fexapp.org/archives title=时间线><span>时间线</span></a></li><li><a href=https://fexapp.org/search/ title=搜索><span>搜索</span></a></li><li><a href=https://fexapp.org/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://fexapp.org/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">可复用面向对象软件基础——设计模式（一）之总览</h1><div class=post-meta><span title='2016-12-15 10:43:05 +0000 UTC'>2016-12-15 10:43:05</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;82 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2016-12-15-design-pattern-01.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#一设计模式特点>一、设计模式特点</a></li><li><a href=#二设计模式宗旨>二、设计模式宗旨</a></li><li><a href=#三设计模式分类232>三、设计模式分类（23+2）</a><ul><li><a href=#1创建型模式>（1）创建型模式</a></li><li><a href=#2结构型模式>（2）结构型模式</a></li><li><a href=#3行为型模式>（3）行为型模式</a></li><li><a href=#4其他>（4）其他</a></li></ul></li><li><a href=#四设计模式原则6-项>四、设计模式原则（6 项）</a></li><li><a href=#五原则详解>五、原则详解</a><ul><li><a href=#1开闭原则>（1）开闭原则</a></li><li><a href=#2里氏代换原则>（2）里氏代换原则</a></li><li><a href=#3依赖倒转原则>（3）依赖倒转原则</a></li><li><a href=#4接口隔离原则>（4）接口隔离原则</a></li><li><a href=#5迪米特法则最少知道原则>（5）迪米特法则（最少知道原则）</a></li><li><a href=#6合成复用原则>（6）合成复用原则</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=一设计模式特点>一、设计模式特点<a hidden class=anchor aria-hidden=true href=#一设计模式特点>#</a></h2><ol><li>反复使用</li><li>分类编目</li><li>经验总结</li></ol><h2 id=二设计模式宗旨>二、设计模式宗旨<a hidden class=anchor aria-hidden=true href=#二设计模式宗旨>#</a></h2><ol><li>代码重用</li><li>使代码易于理解</li><li>保证代码可靠性</li></ol><h2 id=三设计模式分类232>三、设计模式分类（23+2）<a hidden class=anchor aria-hidden=true href=#三设计模式分类232>#</a></h2><ol><li>创建型（5 种）</li><li>结构型（7 种）</li><li>行为型（11 种）</li><li>其他（2 种）</li></ol><h3 id=1创建型模式>（1）创建型模式<a hidden class=anchor aria-hidden=true href=#1创建型模式>#</a></h3><ol><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造者模式</li><li>原型模式</li></ol><h3 id=2结构型模式>（2）结构型模式<a hidden class=anchor aria-hidden=true href=#2结构型模式>#</a></h3><ol><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ol><h3 id=3行为型模式>（3）行为型模式<a hidden class=anchor aria-hidden=true href=#3行为型模式>#</a></h3><ol><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代子模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ol><h3 id=4其他>（4）其他<a hidden class=anchor aria-hidden=true href=#4其他>#</a></h3><ol><li>并发型模式</li><li>线程池模式</li></ol><h2 id=四设计模式原则6-项>四、设计模式原则（6 项）<a hidden class=anchor aria-hidden=true href=#四设计模式原则6-项>#</a></h2><ol><li>开闭原则（Open Close Principle）</li><li>里氏代换原则（Liskov Substitution Principle）</li><li>依赖倒转原则（Dependence Inversion Principle）</li><li>接口隔离原则（Interface Segregation Principle）</li><li>迪米特法则（最少知道原则）（Demeter Principle）</li><li>合成复用原则（Composite Reuse Principle）</li></ol><h2 id=五原则详解>五、原则详解<a hidden class=anchor aria-hidden=true href=#五原则详解>#</a></h2><h3 id=1开闭原则>（1）开闭原则<a hidden class=anchor aria-hidden=true href=#1开闭原则>#</a></h3><blockquote><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到<strong>接口和抽象类</strong></p></blockquote><h3 id=2里氏代换原则>（2）里氏代换原则<a hidden class=anchor aria-hidden=true href=#2里氏代换原则>#</a></h3><blockquote><p>里氏代换原则（LSP）是<strong>面向对象</strong>设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。</p><p>LSP 是<strong>继承复用</strong>的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></blockquote><h3 id=3依赖倒转原则>（3）依赖倒转原则<a hidden class=anchor aria-hidden=true href=#3依赖倒转原则>#</a></h3><blockquote><p>这个是开闭原则的基础，具体内容：针对<strong>接口编程</strong>，<strong>依赖于抽象</strong>而不依赖于具体。</p></blockquote><h3 id=4接口隔离原则>（4）接口隔离原则<a hidden class=anchor aria-hidden=true href=#4接口隔离原则>#</a></h3><blockquote><p>这个原则的意思是：使用<strong>多个</strong>隔离的<strong>接口</strong>，比使用单个接口要好。还是一个<strong>降低</strong>类之间的<strong>耦合度</strong>的意思。</p><p>从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：<strong>降低依赖，降低耦合。</strong></p></blockquote><h3 id=5迪米特法则最少知道原则>（5）迪米特法则（最少知道原则）<a hidden class=anchor aria-hidden=true href=#5迪米特法则最少知道原则>#</a></h3><blockquote><p>为什么叫最少知道原则，就是说：一个<strong>实体</strong>应当<strong>尽量少</strong>的与<strong>其他实体</strong>之间发生<strong>相互作用</strong>，使得系统功能<strong>模块相对独立</strong>。</p></blockquote><h3 id=6合成复用原则>（6）合成复用原则<a hidden class=anchor aria-hidden=true href=#6合成复用原则>#</a></h3><blockquote><p>原则是尽量使用<strong>合成/聚合</strong>的方式，而不是使用继承。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://fexapp.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></li></ul><nav class=paginav><a class=prev href=https://fexapp.org/posts/2016-12-15-design-pattern-02/><span class=title>« 上一页</span><br><span>可复用面向对象软件基础——设计模式（二）之工厂方法模式</span>
</a><a class=next href=https://fexapp.org/posts/2016-11-02-ssh-web-05/><span class=title>下一页 »</span><br><span>基于SSH三大框架的员工管理系统</span></a></nav><script async crossorigin=anonymous src=/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share 可复用面向对象软件基础——设计模式（一）之总览 on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 可复用面向对象软件基础——设计模式（一）之总览 on x" href="https://x.com/intent/tweet/?text=%e5%8f%af%e5%a4%8d%e7%94%a8%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%bd%af%e4%bb%b6%e5%9f%ba%e7%a1%80%e2%80%94%e2%80%94%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%80%ef%bc%89%e4%b9%8b%e6%80%bb%e8%a7%88&amp;url=https%3a%2f%2ffexapp.org%2fposts%2f2016-12-15-design-pattern-01%2f&amp;hashtags=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://fexapp.org/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>