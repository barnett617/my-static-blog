<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>git学习总结 | Wilson's Blog</title>
<meta name=keywords content="git"><meta name=description content="对于 Git 学习的一些整理，包含常用命令整理"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/posts/2017-11-17-git-learning/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.659e049f7d2efb8a004f34ec6fb29b526477a978c7fb695f4c301f8864c325c5.css integrity="sha256-ZZ4En30u+4oATzTsb7KbUmR3qXjH+2lfTDAfiGTDJcU=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/posts/2017-11-17-git-learning/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="git学习总结"><meta property="og:description" content="对于 Git 学习的一些整理，包含常用命令整理"><meta property="og:type" content="article"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/posts/2017-11-17-git-learning/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-11-17T09:54:33+00:00"><meta property="article:modified_time" content="2017-11-17T09:54:33+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="git学习总结"><meta name=twitter:description content="对于 Git 学习的一些整理，包含常用命令整理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://barnett617.github.io/wilson-blog/posts/"},{"@type":"ListItem","position":2,"name":"git学习总结","item":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-git-learning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"git学习总结","name":"git学习总结","description":"对于 Git 学习的一些整理，包含常用命令整理\n","keywords":["git"],"articleBody":"对于 Git 学习的一些整理，包含常用命令整理\n个人觉得，对于一些开源工具，最好的学习资源还是其官网，我们就先来分析一波 Git 究竟是做什么的。\n概念解析 git 官网的定义是：Git 是一种免费并且开源的分布式版本控制系统，被设计用来快速高效地处理堆积成大工程的每一块小部分。（个人翻译，不喜勿喷）\nGit 简单易用、占用空间小并且性能优越。它远超过一些伴有类似廉价的本地分支、方便的阶段区域和多工作流特点的配置管理工具（SCM，Software Configuration Management），比如 SVN、CVS、Perforce 和 ClearCase 这些。\nGit 允许同一组下的人们同一时刻在相同的文档上工作（通常是代码），并且不会踩到其他人的脚趾（形容两个人同时在相同的文档上工作也不会发生冲突）\n特性 小而快速（Small and Fast）\n分布式（Distributed,这也是它比 SVN 优势明显的地方）\n数据保证（Data Assurance）\n分阶段区域（Staging Area）\n免费并开源（Free and Open Source）\n教程 初级教程：Try Git\n高级教程：gitreal\n官方书籍：Pro Git\n使用步骤（包含常见命令） 1.初始化\ngit init init 命令会创建一系列 git 结构的文件\n仅对一个制定目录创建 git 结构时使用，用于将某个目录交给 git 管理\n2.查看 git 状态\ngit status 可在任何时间阶段使用， 以查看当前 git 管理下的文件状态\n3.将文件交予 git 管理\ngit add filename 对于在 git init 后的目录里的每一个文件都有 tracked 和 untracked 两种状态，也就是是否被 git 追溯（管理）\n对于每一个文件，要么通过 git add 交由 git 管理，要么加入 ignore 行列，不然新创建的文件就会处于不受 git 管理的“游离”状态。\n当对于新创建的文件操作 git add 之后，文件就会处于 Staging Area（阶段区域），在 commit 之前还尚未放进 git 的仓库（repository），所以在文件到仓库之前，我们可以将文件添加（add）进或是移出 Staging Area（暂存区）\n当然我们也可以对文件进行批量添加到暂存区，比如 git add ‘*.txt’来将所有后缀为 txt 的文件添加进暂存区（注意引号）\n4.将暂存区的文件提交到仓库\ngit commit -m \"提交注释\" 5.查看提交历史\ngit log 6.将本地仓库与远端仓库建立关联 为了将本地仓库推到远端 Github 服务器中（Push local Repo to Github Server），我们需要添加一个远端仓库（add a remote repository）\ngit remote add origin `Remote Repository URL` 这条命令初学者看起来晦涩难懂，我也是研究了很多遍才大致理解，首先这与普通的 git add 不同的是，git add 是将本地新建的文件添加到 git 的暂存区，而 git remote add 是表示添加一个远端仓库，与本地的仓库建立关联。\n默认取名 origin，直观易懂，后面的 URL 也就是远端仓库的地址，虽然在远端（Github）创建仓库的时候我们创建了名字，但现在毕竟本地还没有那个仓库，所以相当于先在本地创建一个空名字，以备和远端的实体仓库对应。\n当你使用 git remote 命令时，可以看到你 add 的“虚拟”远端仓库，它们的地址就是你 add 时最后的 URL\n7.将本地仓库内容推到远端\ngit push -u origin master 我们表示远端仓库的代号是 origin，默认的本地分支名是 master，-u 是告诉 git 去记住这两个参数（origin master），这样下次提交就可以简化为 git push\n经过上面的 7 个步骤，我们就完成了在本地创建 git 仓库，并创建文件交由 git 管理，并将本地仓库与远端仓库进行关联，再将本地仓库的文件上推到远端仓库\n接下来是关于远端发生变更，本地来查看（比如其他人 fork 了你的仓库，并且 commit 了内容，并 pull request）\n8.将远端仓库的最新文件拉到本地\ngit pull origin master 看懂 git push origin master 再来看这条命令就好理解一些，git pull 是拉（下载）代码，也就是从远端往本地拉，然而其实本地的 origin 其实就是一个关联了远端仓库的钩子，你从 origin 拉代码就是从远端仓库拉代码，而拉下来的代码要放在哪个分支，这里选择了 master 主干分支\n9.对比拉下来的远端仓库最新代码和本地的区别\ngit diff HEAD HEAD 是一个指针，指向我们最新 commit 的地方，不加 HEAD，默认也是与 HEAD 对比\n其他命令 10.使用 diff 命令对比暂存区文件之间的区别\ngit diff --staged 前面提到过 git add 命令是将文件添加入暂存区，即 add to stage\n11.回撤 add 行为\ngit reset 我们可以通过 git add 将文件交由 git 管理，同样也可以通过 git reset 将文件脱离 git 管理，即移出暂存区（unstage file）。 当执行完 git reset somefile 后，somefile 会脱离 git 管理，但文件依旧会在那里。\n12.Undo\ngit checkout -- somefile（注意破折号与文件名之间有一个空格，否则会提示“未定义的选项‘--文件名’”） 可以通过 git checkout 命令将文件恢复成它们上一次提交前的样子\n13.创建分支（branch out）\ngit branch branchname 当需要在主分支之外开发新功能或者修改 bug，需要拉另外的分支以与主分支分离，来进行提交，当工作完成后可以再将其分支合并回主分支（merge back to master） 当直接输入 git branch 命令是查看当前分支情况，当 git branch 后面加任意名字即为创建新的分支\n14.切换分支\ngit checkout branchname 15.清除文件\ngit rm filename git rm 命令不仅会删除你本地的实体文件，还会同时将这些删除行为追溯到 git（stage these removal） 删除时同样可以使用通配符（wildcard）来一次清扫多个文件，例如 git rm ‘*.txt’ 当然这些删除行为也需要通过 commit 来通知仓库，尽管是删除文件，但对于 git 来说都是新增一次操作 此时在新建的分支，将所有的文件删除并提交，仅是对本分支的操作，当切换到主分支时，主分支依然是原样（分支相当于对主分支的拷贝，然而实际实现并不是通过拷贝实现）\n16.合并分支\ngit merge branchname git merge 是将输入的分支合并到当前分支，一般是切回到主分支，执行合并命令，来将其他某一个分支合并到主分支\n17.删除分支\ngit branch -d branchname 当分支合并回主分支后，就没用了，可以进行删除\n使用场景 1.先在本地通过 git 创建工程，然后上传到远程新建的空仓库(Github)\n2.在远端仓库（Github）创建文件或工程，克隆到本地，进行修改后再提交到远端仓库\n3.fork 其他人的仓库，若符合工程结构，则下载到本地可直接运行，修改，提交\n参考链接：\ngit 官网 ","wordCount":"330","inLanguage":"zh","datePublished":"2017-11-17T09:54:33Z","dateModified":"2017-11-17T09:54:33Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-git-learning/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>git学习总结</h1><div class=post-meta><span title='2017-11-17 09:54:33 +0000 UTC'>2017-11-17 09:54:33</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;330 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2017-11-17-git-learning.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#概念解析>概念解析</a></li><li><a href=#特性>特性</a></li><li><a href=#教程>教程</a></li><li><a href=#使用步骤包含常见命令>使用步骤（包含常见命令）</a></li><li><a href=#使用场景>使用场景</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>对于 Git 学习的一些整理，包含常用命令整理</p><p>个人觉得，对于一些开源工具，最好的学习资源还是其官网，我们就先来分析一波 Git 究竟是做什么的。</p><h3 id=概念解析>概念解析<a hidden class=anchor aria-hidden=true href=#概念解析>#</a></h3><p>git 官网的定义是：Git 是一种免费并且开源的分布式版本控制系统，被设计用来快速高效地处理堆积成大工程的每一块小部分。（个人翻译，不喜勿喷）</p><p>Git 简单易用、占用空间小并且性能优越。它远超过一些伴有类似廉价的本地分支、方便的阶段区域和多工作流特点的配置管理工具（SCM，Software Configuration Management），比如 SVN、CVS、Perforce 和 ClearCase 这些。</p><p>Git 允许同一组下的人们同一时刻在相同的文档上工作（通常是代码），并且不会踩到其他人的脚趾（形容两个人同时在相同的文档上工作也不会发生冲突）</p><h3 id=特性>特性<a hidden class=anchor aria-hidden=true href=#特性>#</a></h3><ul><li><p>小而快速（Small and Fast）</p></li><li><p>分布式（Distributed,这也是它比 SVN 优势明显的地方）</p></li><li><p>数据保证（Data Assurance）</p></li><li><p>分阶段区域（Staging Area）</p></li><li><p>免费并开源（Free and Open Source）</p></li></ul><h3 id=教程>教程<a hidden class=anchor aria-hidden=true href=#教程>#</a></h3><p>初级教程：Try Git</p><p>高级教程：gitreal</p><p>官方书籍：Pro Git</p><h3 id=使用步骤包含常见命令>使用步骤（包含常见命令）<a hidden class=anchor aria-hidden=true href=#使用步骤包含常见命令>#</a></h3><p>1.初始化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git init
</span></span></code></pre></div><p>init 命令会创建一系列 git 结构的文件</p><p>仅对一个制定目录创建 git 结构时使用，用于将某个目录交给 git 管理</p><p>2.查看 git 状态</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git status
</span></span></code></pre></div><p>可在任何时间阶段使用， 以查看当前 git 管理下的文件状态</p><p>3.将文件交予 git 管理</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git add filename
</span></span></code></pre></div><p>对于在 git init 后的目录里的每一个文件都有 tracked 和 untracked 两种状态，也就是<strong>是否被 git 追溯（管理）</strong></p><p>对于每一个文件，要么通过 git add 交由 git 管理，要么加入 ignore 行列，不然新创建的文件就会处于不受 git 管理的“游离”状态。</p><p>当对于新创建的文件操作 git add 之后，文件就会处于 Staging Area（阶段区域），在 commit 之前还尚未放进 git 的仓库（repository），所以在文件到仓库之前，我们可以将文件添加（add）进或是移出 Staging Area（暂存区）</p><p>当然我们也可以对文件进行批量添加到暂存区，比如 git add &lsquo;*.txt&rsquo;来将所有后缀为 txt 的文件添加进暂存区（注意引号）</p><p>4.将暂存区的文件提交到仓库</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git commit -m &#34;提交注释&#34;
</span></span></code></pre></div><p>5.查看提交历史</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git log
</span></span></code></pre></div><p>6.将本地仓库与远端仓库建立关联
为了将本地仓库推到远端 Github 服务器中（Push local Repo to Github Server），我们需要添加一个远端仓库（add a remote repository）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git remote add origin `Remote Repository URL`
</span></span></code></pre></div><p>这条命令初学者看起来晦涩难懂，我也是研究了很多遍才大致理解，首先这与普通的 git add 不同的是，git add 是将本地新建的文件添加到 git 的暂存区，而 git remote add 是表示添加一个远端仓库，与本地的仓库建立关联。</p><p>默认取名 origin，直观易懂，后面的 URL 也就是远端仓库的地址，虽然在远端（Github）创建仓库的时候我们创建了名字，但现在毕竟本地还没有那个仓库，所以相当于先在本地创建一个空名字，以备和远端的实体仓库对应。</p><blockquote><p>当你使用 git remote 命令时，可以看到你 add 的“虚拟”远端仓库，它们的地址就是你 add 时最后的 URL</p></blockquote><p>7.将本地仓库内容推到远端</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git push -u origin master
</span></span></code></pre></div><p>我们表示远端仓库的代号是 origin，默认的本地分支名是 master，-u 是告诉 git 去记住这两个参数（origin master），这样下次提交就可以简化为 git push</p><hr><p>经过上面的 7 个步骤，我们就完成了在本地创建 git 仓库，并创建文件交由 git 管理，并将本地仓库与远端仓库进行关联，再将本地仓库的文件上推到远端仓库</p><hr><p>接下来是关于远端发生变更，本地来查看（比如其他人 fork 了你的仓库，并且 commit 了内容，并 pull request）</p><p>8.将远端仓库的最新文件拉到本地</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git pull origin master
</span></span></code></pre></div><p>看懂 git push origin master 再来看这条命令就好理解一些，git pull 是拉（下载）代码，也就是从远端往本地拉，然而其实本地的 origin 其实就是一个关联了远端仓库的钩子，你从 origin 拉代码就是从远端仓库拉代码，而拉下来的代码要放在哪个分支，这里选择了 master 主干分支</p><p>9.对比拉下来的远端仓库最新代码和本地的区别</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git diff HEAD
</span></span></code></pre></div><p>HEAD 是一个指针，指向我们最新 commit 的地方，不加 HEAD，默认也是与 HEAD 对比</p><h4 id=其他命令>其他命令<a hidden class=anchor aria-hidden=true href=#其他命令>#</a></h4><p>10.使用 diff 命令对比暂存区文件之间的区别</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git diff --staged
</span></span></code></pre></div><p>前面提到过 git add 命令是将文件添加入暂存区，即 add to stage</p><p>11.回撤 add 行为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git reset
</span></span></code></pre></div><p>我们可以通过 git add 将文件交由 git 管理，同样也可以通过 git reset 将文件脱离 git 管理，即移出暂存区（unstage file）。
当执行完 git reset somefile 后，somefile 会脱离 git 管理，但文件依旧会在那里。</p><p>12.Undo</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git checkout -- somefile（注意破折号与文件名之间有一个空格，否则会提示“未定义的选项‘--文件名’”）
</span></span></code></pre></div><p>可以通过 git checkout 命令将文件恢复成它们上一次提交前的样子</p><p>13.创建分支（branch out）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git branch branchname
</span></span></code></pre></div><p>当需要在主分支之外开发新功能或者修改 bug，需要拉另外的分支以与主分支分离，来进行提交，当工作完成后可以再将其分支合并回主分支（merge back to master）
当直接输入 git branch 命令是查看当前分支情况，当 git branch 后面加任意名字即为创建新的分支</p><p>14.切换分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git checkout branchname
</span></span></code></pre></div><p>15.清除文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git rm filename
</span></span></code></pre></div><p>git rm 命令不仅会删除你本地的实体文件，还会同时将这些删除行为追溯到 git（stage these removal）
删除时同样可以使用通配符（wildcard）来一次清扫多个文件，例如 git rm &lsquo;*.txt&rsquo;
当然这些删除行为也需要通过 commit 来通知仓库，尽管是删除文件，但对于 git 来说都是新增一次操作
此时在新建的分支，将所有的文件删除并提交，仅是对本分支的操作，当切换到主分支时，主分支依然是原样（分支相当于对主分支的拷贝，然而实际实现并不是通过拷贝实现）</p><p>16.合并分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git merge branchname
</span></span></code></pre></div><p>git merge 是将输入的分支合并到当前分支，一般是切回到主分支，执行合并命令，来将其他某一个分支合并到主分支</p><p>17.删除分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git branch -d branchname
</span></span></code></pre></div><p>当分支合并回主分支后，就没用了，可以进行删除</p><h3 id=使用场景>使用场景<a hidden class=anchor aria-hidden=true href=#使用场景>#</a></h3><p>1.先在本地通过 git 创建工程，然后上传到远程新建的空仓库(Github)</p><p>2.在远端仓库（Github）创建文件或工程，克隆到本地，进行修改后再提交到远端仓库</p><p>3.fork 其他人的仓库，若符合工程结构，则下载到本地可直接运行，修改，提交</p><p>参考链接：</p><ul><li>git 官网</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://barnett617.github.io/wilson-blog/tags/git/>git</a></li></ul><nav class=paginav><a class=prev href=https://barnett617.github.io/wilson-blog/posts/2017-11-17-markdown-programmer/><span class=title>« 上一页</span><br><span>Markdown语法学习整理</span>
</a><a class=next href=https://barnett617.github.io/wilson-blog/posts/2017-11-16-centos-iptables-and-firewalld/><span class=title>下一页 »</span><br><span>关于centos的iptables以及firewalld的总结</span></a></nav><script defer crossorigin=anonymous src=/wilson-blog/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share git学习总结 on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git学习总结 on x" href="https://x.com/intent/tweet/?text=git%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93&amp;url=https%3a%2f%2fbarnett617.github.io%2fwilson-blog%2fposts%2f2017-11-17-git-learning%2f&amp;hashtags=git"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>