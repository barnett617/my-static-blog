<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何设计良好的API并且为什么这很重要（译） | Wilson's Blog</title>
<meta name=keywords content="API"><meta name=description content="本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享
API 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会
为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量
好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑
通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/posts/2018-01-16-api-designing-translation/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.7822ca91becd3fe515c67241030e80de043ab22dea5278258d676181168c3c52.css integrity="sha256-eCLKkb7NP+UVxnJBAw6A3gQ6si3qUngljWdhgRaMPFI=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/posts/2018-01-16-api-designing-translation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="如何设计良好的API并且为什么这很重要（译）"><meta property="og:description" content="本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享
API 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会
为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量
好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑
通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前"><meta property="og:type" content="article"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/posts/2018-01-16-api-designing-translation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-16T11:38:31+00:00"><meta property="article:modified_time" content="2018-01-16T11:38:31+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何设计良好的API并且为什么这很重要（译）"><meta name=twitter:description content="本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享
API 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会
为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量
好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑
通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://barnett617.github.io/wilson-blog/posts/"},{"@type":"ListItem","position":2,"name":"如何设计良好的API并且为什么这很重要（译）","item":"https://barnett617.github.io/wilson-blog/posts/2018-01-16-api-designing-translation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何设计良好的API并且为什么这很重要（译）","name":"如何设计良好的API并且为什么这很重要（译）","description":"本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享\nAPI 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会\n为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量\n好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑\n通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前","keywords":["API"],"articleBody":"本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享\nAPI 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会\n为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量\n好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑\n通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前\n从你将扔掉的实现中拯救你 以下应开始于你正确指定出 API 之前\n从撰写你将扔掉的规范中拯救你 继续写 API 因为它充实你\n避免令人讨厌的惊喜 代码作为例子、单元测试而存在 关于 SPI 的内容甚至更重要 服务提供接口（Service Provider Interface, SPI） 插件式接口使得实现多样性 例如：Java 加密拓展接口（Java Cryptography Extension, JCE） 在发布之前编写多个插件 如果你只写一个，它可能不支持另一种情况 如果你写两个，它会很难支持更多 如果你写三个(原文 three 应表示多个?)，它会良好工作 Will Tracz 称之为“三项法则” （曾经以为程序销售员 Addision-Wesley,1995 的自白）\n保持现实的期望 大多数 API 设计的过约束 你不必取悦每一个人 旨在平等地使每个人都感到高兴 期望犯错 几年真实世界的使用将冲洗它们 期望发展 API II 一般原则 API 应该只做一件事并把它做好 功能应该易于解释 如果很难命名 API，那它通常是一个坏讯号 良好的命名会驱动开发 要易于分割和合并 API 应尽可能的小但不能再小\nAPI 应该满足它的初始需求\n当存疑时就抛弃掉 函数、类、方法、参数等等 你总可以加些什么，但你永远不能去掉什么 概念的重量比实体块的重量更重要 寻找一个好的力量/重量比率（此处应指 API 的作用和轻重之比） 实现不应该影响 API 实现细节 迷惑用户 禁止掉改变 API 实现的自由 意识到实现细节是什么 不要过度指定方法的行为 例如：不要指定散列函数 所有的可调整参数都是可疑的 别让实现细节“泄露”进 API 磁盘上的格式和线上的格式例外 最小化对于所有的可达性 将类和方法指定得尽可能私有\n公共类不应该有公共域（除了常量）\n这最大化了信息隐藏\n允许模块被独立使用、理解、构建、测试、调试\n给 API 命名的事务相当于一种小语言 名字应大部分不言自明（自解释的） 避免模糊的缩写 保持一致——同样的词应表达同样的意思 贯穿 API 的整个内容（包括不同平台上的该 API） 定期争取对称\n代码应该读起来像散文\nif (car.speed() \u003e 2 * SPEED_LIMIT) generateAlert(\"Watch out for cops!\"); 文档相关事宜 重用是一件说起来容易做起来难的事。具体做起来既需要好的设计又需要良好的文档。即使我们看到好的设计，我们仍很少能看到没有好的文档组件被重用。\nD.L.Parnas, _Software Aging. Proceedings of 16th International Conference Software Engineering, 1994\nDocument Religiously 为每一个类、接口、方法、构造器、参数和异常制作文档（注释） 类：实例所表示的东西 方法：方法和客户之间的契约 先决条件、后置条件、副作用 参数：提示性的单位、格式、所有权 文档要非常认真地陈述\n考虑 API 设计决定的性能后果 糟糕的决定会限制性能 让类型易变 提供构造器以取代静态工厂 使用实现类型取代接口 不要扭曲 API 来获得性能 底层性能问题会被修复，但头疼的事会一直伴随着你 良好的设计通常与良好的性能相吻合 API 设计决策在性能方面的影响是真实并且永久的 Component.getSize() returns Dimension 尺寸是易变的 每一个 getSize 调用都必然分配 Dimension 将导致非常多不必要的对象分配 在 1.2 版本增加替代品，老的客户端代码仍然慢（在新的版本找到解决方案，但不能解决旧代码的性能问题） API 必须和平台和平共存 做习惯性的事 遵守标准的命名约定 避免过时的参数和返回类型 模仿核心 APIs 和语言中的模式 利用 API 友好功能 泛型、可变参数、枚举、默认参数 了解并避免 API 陷阱 常量（Finalizers）、公共静态常量数组 III 类设计 最小化可变性 类应该是不可变的除非有一个好的理由不去这么做\n优点： 简洁、线程安全、可复用 缺点： 对于每个值都分离了对象 如果可变，保证状态空间尽可能小并被良好定义\n搞清何时去调用哪一个方法是合法的 仅在合理的地方建子类 建子类按时可替代性（Liskov）\n子类仅当 is-a 关系时存在 否则，使用组合 公共类不应该再包含其他公共子类，以保证实现简单\n反例： Properties extends Hashtable Stack extends Vector\n正例： Set extends Collection\n为继承做设计和文档否则禁止 继承违反封装（Snyder, 86）\n子类对于父类的实现细节敏感 如果你允许建子类，那么就文档自用\n方法如何相互使用 保守策略：所有具体的类都不可变（final）\n反例：J2SE 包中许多的具体类 正例：AbstractSet, AbstractMap\nIV 方法设计 别让客户端把模板能做的事都做了 减少对样板代码的需要\n通常经 cut-and-paste 完成 丑陋、恼人并且易错 不要违反最小原则 API 的使用者不应该对于某些行为感到惊讶\n值得额外的实现努力 这甚至值得降低性能 public class Thread implements Runnable { // Tests whether current thread has been interrupted // Clears the interrupted status of current thread. public static boolean interrupted(); } 上面的第二行注释所述的功能就做了额外的没必要的努力，违背了最小原则\n当错误发生尽可能快地产生错误报告 编译时报错最佳——静态拼写、generics\n在运行时，第一个方法调用失败为最佳\n方法应该是原子性失败（failure-atomic） // A Properties instance maps strings to strings public class Properties extends Hashtable { public Object put(Object key, Object value); // Throws ClassCastException if this Properties // contains any keys or values that are not strings public void save(OutputStream out, String comments); } 为所有的数据访问提供字符串的形式的编程接口 否则客户端需要做字符串转换 对于客户端来说很痛苦 更糟糕的是，turns strings format into de facto API（无力翻译 orz） public class Throwable { public void printStackTrace(PrintStream s); public StackTraceElement[] getStackTrace();\t// Since 1.4 } public final class StackTraceElement { public String getFilaName(); public int getLineNumber(); public String getClassName(); public String getMethodName(); public boolean isNativeMethod(); } 小心重载 避免模糊的重载 多个重载适用于相同的情况 保守策略：没有两个重载拥有同样多的参数个数 仅仅是因为你可以但不意味着你应当 通常最好使用不同的名字 如果你必须提供模糊的重载，请确保相同的参数拥有相同的行为 反例:\npublic TreeSet(Collection c);\t// Ignores order public TreeSet(SortedSet s);\t// Respects order 使用恰当的参数和返回类型 赞成接口类型作为类的输入\n提供灵活性、性能 使用最具体的可能的输入参数类型\n把运行时错误提前到编译时 如果存在更好的类型请别用 String 类型\nStrings 是繁琐的、易错的并且慢的 不要将浮点数用于货币值\n二进制浮点会导致不精确的结果 使用 double(64 位)优于 float(32 位)\n精确度损失是真实的，性能损失是可忽略的 在方法之间使用一致的参数顺序 如果参数类型相同，尤其重要 反例：\n#include char *strcpy (char *dest, char *src); void bcopy (void *src, void *dst, int n); 正例： java.util.Collections——第一个参数总被收集来用于修改或查询\njava.util.concurrent——time 总被指定为 long delay, TimeUnit unit\n避免长参数列表 三个或更少参数是比较理想的\n如果存在更多，用户则需参阅文档 相同类型的长参数列表是有害的\n程序员会错误地转置参数 程序仍会编译、运行，但行为不端 两种缩短参数列表的技巧\n拆分方法 创建辅助类来保存参数 反例：\n// Eleven parameters including four consecutive ints HWND CreateWindow(LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam); 避免返回值需要异常处理 返回零长度数组或空集合而非 null\npackage java.awt.image; public interface BufferedImageOp { // Returns the rendering hints for this operation, // or null if no hints have been set. public RenderingHints getRenderingHints(); } V.异常设计 抛出异常以表明异常的条件 不要强迫客户端去使用异常来控制流\n反例:\nprivate byte[] a = new byte[BUF_SIZE]; void processBuffer (ByteBuffer buf) { try { while (true) { buf.get(a); processBytes(tmp, BUF_SIZE); } } catch (BufferUnderflowException e) { int remaining = buf.remaining(); buf.get(a, 0, remaning); processBytes(bufArray, remaining); } } 反过来，不要安静的失败\n例如：\nThreadGroup.enumerate(Thread[] list) 赞成未经检查的异常 已检查——客户端必须采取修复措施\n未检查——程序报错\n过度使用已检查的异常会导致样板化\n反例：\ntry { Foo f = (Foo) super.clone(); ... } catch (CloneNotSupportedException e) { // This can't happen, since we're Cloneable throw new AssertionError(); } 在异常中包含错误捕获信息 允许诊断、修复或恢复\n对于未检查的异常，信息就足够了\n对于已检查的异常，提供访问者\nVI 重构 API 设计 向量的子列表操作 public class Vector { public int indexOf(Object elem, int index); public int lastIndexOf(Object elem, int index); } 不够强大——只支持搜索\n没有文档很难使用\n字列表操作重构 public interface List { List subList(int fromIndex, int toIndex); ... } 非常强大——支持所有的操作\n接口的使用减少了概念的重量\n高功率重量比 没有文档也易于使用\nThread-local 变量 // Broken - inappropriate use of String as capability. // Keys constitue a shared global namespace. public class ThreadLocal { private ThreadLocal() { } // Non-instantiable // Sets current thread's value for named variable. public static void set(String key, Object value); // Returns current thread's value for named variable. public static Object get(String key); } Thread-Local 变量重构（1） public class ThreadLocal { private ThreadLocal() { } // Noninstantiable public static class Key {\tKey() { } } // Generates a unique, unforgeable key public static void set(Key key, Object value); public static Object get(Key key); } 有效，但是需要使用样板代码 例如:\nstatic ThreadLocal.Key serialNumberKey = ThreadLocal.getKey(); ThreadLocal.set(serialNumberKey, nextSerialNumber()); System.out.println(ThreadLocal.get(serialNumberKey)); Thread-Local 变量重构（2） public class ThreadLocal { public ThreadLocal() { } public void set(Object value); public Object get(); } 消除 API 和客户端代码之间的混乱 static ThreadLocal serialNumber = new ThreadLocal(); serialNumber.set(nextSerialNumber()); System.out.println(serialNumber.get()); 结论 API 设计是一种高贵且有益的工艺 改进了很多程序员、最终用户和公司 这次谈话涵盖了一些启发式的手艺 不要狂妄地坚持，但… 不要没有理由的违反 API 设计很难 不是一个孤独的活动 完美是无法实现的，但无论如何都要尝试 个人评价\u0026总结 本文评价了很多 Java 语言包以及面向对象的优点和缺点，也包含 C 语言的部分例子。本文作者 Joshua Bloch 同时也是 Effective Java 的作者。本文中有些用词比较晦涩难懂，但通篇整体很好也很全面地剖析了 API 设计的重要性及一部分技巧和注意事项，值得参考借鉴。\n翻译过程也是磕磕绊绊，很多地方自我感觉翻译的不甚准确，甚至有问题，实在找不到合适的翻译的地方注明了原文或保留原文词句，希望有心读者能指正并反馈。不过翻译的过程的确为了理解作者原意，也会竭尽脑力去思考和体会字里行间所表达的思想，收益良多。 其中不乏有些建议的确出现于日常的编程实践，并作为编程规范存在于最佳实践中，一眼就能理解。也有一些目前可能尚未在实际应用中良好实践。\n原文链接：https://web.archive.org/web/20110903030015/http://lcsd05.cs.tamu.edu/slides/keynote.pdf\n","wordCount":"845","inLanguage":"zh","datePublished":"2018-01-16T11:38:31Z","dateModified":"2018-01-16T11:38:31Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://barnett617.github.io/wilson-blog/posts/2018-01-16-api-designing-translation/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">如何设计良好的API并且为什么这很重要（译）</h1><div class=post-meta><span title='2018-01-16 11:38:31 +0000 UTC'>2018-01-16 11:38:31</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;845 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2018-01-16-api-designing-translation.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#api-可以是公司最大的资产之一>API 可以是公司最大的资产之一</a></li><li><a href=#也可以成为公司最大的负债之一>也可以成为公司最大的负债之一</a></li><li><a href=#为什么-api-设计对于你来说很重要>为什么 API 设计对于你来说很重要</a><ul><li><a href=#如果你编码你就是一个-api-的设计者>如果你编码，你就是一个 API 的设计者</a></li><li><a href=#好的-api-所具备的特征>好的 API 所具备的特征</a></li><li><a href=#大纲>大纲</a></li></ul></li><li><a href=#i-api-设计的过程>I API 设计的过程</a><ul><li><a href=#通常你会得到建议的解决方法作为替代方案>通常你会得到建议的解决方法作为替代方案</a></li><li><a href=#你的工作是去提取出真正的需求>你的工作是去提取出真正的需求</a></li><li><a href=#从简短的规范页开始比较理想>从简短的规范页开始比较理想</a></li></ul></li><li><a href=#尽早写给你的-api>尽早写给你的 API</a></li><li><a href=#关于-spi-的内容甚至更重要>关于 SPI 的内容甚至更重要</a><ul><li><a href=#服务提供接口service-provider-interface-spi>服务提供接口（Service Provider Interface, SPI）</a></li><li><a href=#在发布之前编写多个插件>在发布之前编写多个插件</a></li><li><a href=#will-tracz-称之为三项法则>Will Tracz 称之为“三项法则”</a></li></ul></li><li><a href=#保持现实的期望>保持现实的期望</a><ul><li><a href=#大多数-api-设计的过约束>大多数 API 设计的过约束</a></li><li><a href=#期望犯错>期望犯错</a></li></ul></li><li><a href=#ii-一般原则>II 一般原则</a><ul><li><a href=#api-应该只做一件事并把它做好>API 应该只做一件事并把它做好</a></li><li><a href=#实现不应该影响-api>实现不应该影响 API</a></li><li><a href=#实现细节>实现细节</a></li><li><a href=#最小化对于所有的可达性>最小化对于所有的可达性</a></li><li><a href=#给-api-命名的事务相当于一种小语言>给 API 命名的事务相当于一种小语言</a></li></ul></li><li><a href=#文档相关事宜>文档相关事宜</a></li><li><a href=#document-religiously>Document Religiously</a><ul><li><a href=#为每一个类接口方法构造器参数和异常制作文档注释>为每一个类、接口、方法、构造器、参数和异常制作文档（注释）</a></li></ul></li><li><a href=#考虑-api-设计决定的性能后果>考虑 API 设计决定的性能后果</a><ul><li><a href=#糟糕的决定会限制性能>糟糕的决定会限制性能</a></li><li><a href=#不要扭曲-api-来获得性能>不要扭曲 API 来获得性能</a></li><li><a href=#api-设计决策在性能方面的影响是真实并且永久的>API 设计决策在性能方面的影响是真实并且永久的</a></li></ul></li><li><a href=#api-必须和平台和平共存>API 必须和平台和平共存</a><ul><li><a href=#做习惯性的事>做习惯性的事</a></li><li><a href=#利用-api-友好功能>利用 API 友好功能</a></li><li><a href=#了解并避免-api-陷阱>了解并避免 API 陷阱</a></li></ul></li><li><a href=#iii-类设计>III 类设计</a><ul><li><a href=#最小化可变性>最小化可变性</a></li><li><a href=#仅在合理的地方建子类>仅在合理的地方建子类</a></li><li><a href=#为继承做设计和文档否则禁止>为继承做设计和文档否则禁止</a></li></ul></li><li><a href=#iv-方法设计>IV 方法设计</a><ul><li><a href=#别让客户端把模板能做的事都做了>别让客户端把模板能做的事都做了</a></li><li><a href=#不要违反最小原则>不要违反最小原则</a></li><li><a href=#当错误发生尽可能快地产生错误报告>当错误发生尽可能快地产生错误报告</a></li><li><a href=#为所有的数据访问提供字符串的形式的编程接口>为所有的数据访问提供字符串的形式的编程接口</a></li><li><a href=#小心重载>小心重载</a></li><li><a href=#使用恰当的参数和返回类型>使用恰当的参数和返回类型</a></li><li><a href=#在方法之间使用一致的参数顺序>在方法之间使用一致的参数顺序</a></li><li><a href=#避免长参数列表>避免长参数列表</a></li><li><a href=#避免返回值需要异常处理>避免返回值需要异常处理</a></li></ul></li><li><a href=#v异常设计>V.异常设计</a><ul><li><a href=#抛出异常以表明异常的条件>抛出异常以表明异常的条件</a></li><li><a href=#赞成未经检查的异常>赞成未经检查的异常</a></li><li><a href=#在异常中包含错误捕获信息>在异常中包含错误捕获信息</a></li></ul></li><li><a href=#vi-重构-api-设计>VI 重构 API 设计</a><ul><li><a href=#向量的子列表操作>向量的子列表操作</a></li><li><a href=#字列表操作重构>字列表操作重构</a></li><li><a href=#thread-local-变量>Thread-local 变量</a></li><li><a href=#有效但是需要使用样板代码>有效，但是需要使用样板代码</a></li></ul></li><li><a href=#结论>结论</a><ul><li><a href=#api-设计是一种高贵且有益的工艺>API 设计是一种高贵且有益的工艺</a></li><li><a href=#这次谈话涵盖了一些启发式的手艺>这次谈话涵盖了一些启发式的手艺</a></li><li><a href=#api-设计很难>API 设计很难</a></li></ul></li><li><a href=#个人评价总结>个人评价&总结</a></li></ul></nav></div></details></div><div class=post-content><p>本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享</p><h2 id=api-可以是公司最大的资产之一>API 可以是公司最大的资产之一<a hidden class=anchor aria-hidden=true href=#api-可以是公司最大的资产之一>#</a></h2><ul><li>客户投入巨资：购买、撰写、学习（售前一系列培训）</li><li>停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多）</li><li>成功的公共 API 赢得客户</li></ul><h2 id=也可以成为公司最大的负债之一>也可以成为公司最大的负债之一<a hidden class=anchor aria-hidden=true href=#也可以成为公司最大的负债之一>#</a></h2><ul><li>糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映）</li></ul><p>公共的 APIs 是永久的——一次去做正确事情的机会</p><h2 id=为什么-api-设计对于你来说很重要>为什么 API 设计对于你来说很重要<a hidden class=anchor aria-hidden=true href=#为什么-api-设计对于你来说很重要>#</a></h2><h3 id=如果你编码你就是一个-api-的设计者>如果你编码，你就是一个 API 的设计者<a hidden class=anchor aria-hidden=true href=#如果你编码你就是一个-api-的设计者>#</a></h3><ul><li>良好的代码应该是模块化的——每一个模块都有一个 API</li><li>有用的模块往往被重用</li></ul><p>对于 API 方面的思考将提高代码的质量</p><h3 id=好的-api-所具备的特征>好的 API 所具备的特征<a hidden class=anchor aria-hidden=true href=#好的-api-所具备的特征>#</a></h3><ul><li>易于学习</li><li>易于使用，甚至无需任何文档</li><li>不易误用</li><li>易于阅读并且对所使用的代码部分易于维护</li><li>足够强大以满足需求</li><li>易于拓展</li><li>适用于大众</li></ul><h3 id=大纲>大纲<a hidden class=anchor aria-hidden=true href=#大纲>#</a></h3><ul><li>API 设计的过程</li><li>一般原则</li><li>类设计</li><li>方法设计</li><li>异常设计</li><li>API 重构设计</li></ul><h2 id=i-api-设计的过程>I API 设计的过程<a hidden class=anchor aria-hidden=true href=#i-api-设计的过程>#</a></h2><p>收集需求——以一种健康的程度怀疑</p><h3 id=通常你会得到建议的解决方法作为替代方案>通常你会得到建议的解决方法作为替代方案<a hidden class=anchor aria-hidden=true href=#通常你会得到建议的解决方法作为替代方案>#</a></h3><ul><li>可能存在更好的解决方案</li></ul><h3 id=你的工作是去提取出真正的需求>你的工作是去提取出真正的需求<a hidden class=anchor aria-hidden=true href=#你的工作是去提取出真正的需求>#</a></h3><ul><li>应采取用例的形式</li><li>可以更容易、更有意义地建立更普遍的东西</li></ul><h3 id=从简短的规范页开始比较理想>从简短的规范页开始比较理想<a hidden class=anchor aria-hidden=true href=#从简短的规范页开始比较理想>#</a></h3><ul><li>在这个阶段，敏捷胜过完整性</li><li>和尽可能多的人谈（原文：Bounce spec off as many people as possible）
倾听他们的输入并认真对待</li><li>如果你保持规范简短，那么将易于修改</li><li>充分自信
这涉及到编码时也很必要</li></ul><h2 id=尽早写给你的-api>尽早写给你的 API<a hidden class=anchor aria-hidden=true href=#尽早写给你的-api>#</a></h2><p>以下应开始于在你实现 API 之前</p><ul><li>从你将扔掉的实现中拯救你</li></ul><p>以下应开始于你正确指定出 API 之前</p><ul><li>从撰写你将扔掉的规范中拯救你</li></ul><p>继续写 API 因为它充实你</p><ul><li>避免令人讨厌的惊喜</li><li>代码作为例子、单元测试而存在</li></ul><h2 id=关于-spi-的内容甚至更重要>关于 SPI 的内容甚至更重要<a hidden class=anchor aria-hidden=true href=#关于-spi-的内容甚至更重要>#</a></h2><h3 id=服务提供接口service-provider-interface-spi>服务提供接口（Service Provider Interface, SPI）<a hidden class=anchor aria-hidden=true href=#服务提供接口service-provider-interface-spi>#</a></h3><ul><li>插件式接口使得实现多样性</li><li>例如：Java 加密拓展接口（Java Cryptography Extension, JCE）</li></ul><h3 id=在发布之前编写多个插件>在发布之前编写多个插件<a hidden class=anchor aria-hidden=true href=#在发布之前编写多个插件>#</a></h3><ul><li>如果你只写一个，它可能不支持另一种情况</li><li>如果你写两个，它会很难支持更多</li><li>如果你写三个(原文 three 应表示多个?)，它会良好工作</li></ul><h3 id=will-tracz-称之为三项法则>Will Tracz 称之为“三项法则”<a hidden class=anchor aria-hidden=true href=#will-tracz-称之为三项法则>#</a></h3><p>（曾经以为程序销售员 Addision-Wesley,1995 的自白）</p><h2 id=保持现实的期望>保持现实的期望<a hidden class=anchor aria-hidden=true href=#保持现实的期望>#</a></h2><h3 id=大多数-api-设计的过约束>大多数 API 设计的过约束<a hidden class=anchor aria-hidden=true href=#大多数-api-设计的过约束>#</a></h3><ul><li>你不必取悦每一个人</li><li>旨在平等地使每个人都感到高兴</li></ul><h3 id=期望犯错>期望犯错<a hidden class=anchor aria-hidden=true href=#期望犯错>#</a></h3><ul><li>几年真实世界的使用将冲洗它们</li><li>期望发展 API</li></ul><h2 id=ii-一般原则>II 一般原则<a hidden class=anchor aria-hidden=true href=#ii-一般原则>#</a></h2><h3 id=api-应该只做一件事并把它做好>API 应该只做一件事并把它做好<a hidden class=anchor aria-hidden=true href=#api-应该只做一件事并把它做好>#</a></h3><h4 id=功能应该易于解释>功能应该易于解释<a hidden class=anchor aria-hidden=true href=#功能应该易于解释>#</a></h4><ul><li>如果很难命名 API，那它通常是一个坏讯号</li><li>良好的命名会驱动开发</li><li>要易于分割和合并</li></ul><p>API 应尽可能的小但不能再小</p><p>API 应该满足它的初始需求</p><h4 id=当存疑时就抛弃掉>当存疑时就抛弃掉<a hidden class=anchor aria-hidden=true href=#当存疑时就抛弃掉>#</a></h4><ul><li>函数、类、方法、参数等等</li><li>你总可以加些什么，但你永远不能去掉什么</li></ul><h4 id=概念的重量比实体块的重量更重要>概念的重量比实体块的重量更重要<a hidden class=anchor aria-hidden=true href=#概念的重量比实体块的重量更重要>#</a></h4><h4 id=寻找一个好的力量重量比率此处应指-api-的作用和轻重之比>寻找一个好的力量/重量比率（此处应指 API 的作用和轻重之比）<a hidden class=anchor aria-hidden=true href=#寻找一个好的力量重量比率此处应指-api-的作用和轻重之比>#</a></h4><h3 id=实现不应该影响-api>实现不应该影响 API<a hidden class=anchor aria-hidden=true href=#实现不应该影响-api>#</a></h3><h3 id=实现细节>实现细节<a hidden class=anchor aria-hidden=true href=#实现细节>#</a></h3><ul><li>迷惑用户</li><li>禁止掉改变 API 实现的自由</li></ul><h4 id=意识到实现细节是什么>意识到实现细节是什么<a hidden class=anchor aria-hidden=true href=#意识到实现细节是什么>#</a></h4><ul><li>不要过度指定方法的行为</li><li>例如：不要指定散列函数</li><li>所有的可调整参数都是可疑的</li></ul><h4 id=别让实现细节泄露进-api>别让实现细节“泄露”进 API<a hidden class=anchor aria-hidden=true href=#别让实现细节泄露进-api>#</a></h4><ul><li>磁盘上的格式和线上的格式例外</li></ul><h3 id=最小化对于所有的可达性>最小化对于所有的可达性<a hidden class=anchor aria-hidden=true href=#最小化对于所有的可达性>#</a></h3><p>将类和方法指定得尽可能私有</p><p>公共类不应该有公共域（除了常量）</p><p>这最大化了信息隐藏</p><p>允许模块被独立使用、理解、构建、测试、调试</p><h3 id=给-api-命名的事务相当于一种小语言>给 API 命名的事务相当于一种小语言<a hidden class=anchor aria-hidden=true href=#给-api-命名的事务相当于一种小语言>#</a></h3><h4 id=名字应大部分不言自明自解释的>名字应大部分不言自明（自解释的）<a hidden class=anchor aria-hidden=true href=#名字应大部分不言自明自解释的>#</a></h4><ul><li>避免模糊的缩写</li></ul><h4 id=保持一致同样的词应表达同样的意思>保持一致——同样的词应表达同样的意思<a hidden class=anchor aria-hidden=true href=#保持一致同样的词应表达同样的意思>#</a></h4><ul><li>贯穿 API 的整个内容（包括不同平台上的该 API）</li></ul><p>定期争取对称</p><p>代码应该读起来像散文</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>car</span><span class=p>.</span><span class=na>speed</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>SPEED_LIMIT</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>generateAlert</span><span class=p>(</span><span class=s>&#34;Watch out for cops!&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h2 id=文档相关事宜>文档相关事宜<a hidden class=anchor aria-hidden=true href=#文档相关事宜>#</a></h2><blockquote><p>重用是一件说起来容易做起来难的事。具体做起来既需要好的设计又需要良好的文档。即使我们看到好的设计，我们仍很少能看到没有好的文档组件被重用。</p></blockquote><blockquote><p>D.L.Parnas, _Software Aging. Proceedings of 16th International Conference Software Engineering, 1994</p></blockquote><h2 id=document-religiously>Document Religiously<a hidden class=anchor aria-hidden=true href=#document-religiously>#</a></h2><h3 id=为每一个类接口方法构造器参数和异常制作文档注释>为每一个类、接口、方法、构造器、参数和异常制作文档（注释）<a hidden class=anchor aria-hidden=true href=#为每一个类接口方法构造器参数和异常制作文档注释>#</a></h3><ul><li>类：实例所表示的东西</li><li>方法：方法和客户之间的契约<ul><li>先决条件、后置条件、副作用</li></ul></li><li>参数：提示性的单位、格式、所有权</li></ul><p>文档要非常认真地陈述</p><h2 id=考虑-api-设计决定的性能后果>考虑 API 设计决定的性能后果<a hidden class=anchor aria-hidden=true href=#考虑-api-设计决定的性能后果>#</a></h2><h3 id=糟糕的决定会限制性能>糟糕的决定会限制性能<a hidden class=anchor aria-hidden=true href=#糟糕的决定会限制性能>#</a></h3><ul><li>让类型易变</li><li>提供构造器以取代静态工厂</li><li>使用实现类型取代接口</li></ul><h3 id=不要扭曲-api-来获得性能>不要扭曲 API 来获得性能<a hidden class=anchor aria-hidden=true href=#不要扭曲-api-来获得性能>#</a></h3><ul><li>底层性能问题会被修复，但头疼的事会一直伴随着你</li><li>良好的设计通常与良好的性能相吻合</li></ul><h3 id=api-设计决策在性能方面的影响是真实并且永久的>API 设计决策在性能方面的影响是真实并且永久的<a hidden class=anchor aria-hidden=true href=#api-设计决策在性能方面的影响是真实并且永久的>#</a></h3><ul><li>Component.getSize() returns Dimension</li><li>尺寸是易变的</li><li>每一个 getSize 调用都必然分配 Dimension</li><li>将导致非常多不必要的对象分配</li><li>在 1.2 版本增加替代品，老的客户端代码仍然慢（在新的版本找到解决方案，但不能解决旧代码的性能问题）</li></ul><h2 id=api-必须和平台和平共存>API 必须和平台和平共存<a hidden class=anchor aria-hidden=true href=#api-必须和平台和平共存>#</a></h2><h3 id=做习惯性的事>做习惯性的事<a hidden class=anchor aria-hidden=true href=#做习惯性的事>#</a></h3><ul><li>遵守标准的命名约定</li><li>避免过时的参数和返回类型</li><li>模仿核心 APIs 和语言中的模式</li></ul><h3 id=利用-api-友好功能>利用 API 友好功能<a hidden class=anchor aria-hidden=true href=#利用-api-友好功能>#</a></h3><ul><li>泛型、可变参数、枚举、默认参数</li></ul><h3 id=了解并避免-api-陷阱>了解并避免 API 陷阱<a hidden class=anchor aria-hidden=true href=#了解并避免-api-陷阱>#</a></h3><ul><li>常量（Finalizers）、公共静态常量数组</li></ul><h2 id=iii-类设计>III 类设计<a hidden class=anchor aria-hidden=true href=#iii-类设计>#</a></h2><h3 id=最小化可变性>最小化可变性<a hidden class=anchor aria-hidden=true href=#最小化可变性>#</a></h3><p>类应该是不可变的除非有一个好的理由不去这么做</p><ul><li>优点： 简洁、线程安全、可复用</li><li>缺点： 对于每个值都分离了对象</li></ul><p>如果可变，保证状态空间尽可能小并被良好定义</p><ul><li>搞清何时去调用哪一个方法是合法的</li></ul><h3 id=仅在合理的地方建子类>仅在合理的地方建子类<a hidden class=anchor aria-hidden=true href=#仅在合理的地方建子类>#</a></h3><p>建子类按时可替代性（Liskov）</p><ul><li>子类仅当 is-a 关系时存在</li><li>否则，使用组合</li></ul><p>公共类不应该再包含其他公共子类，以保证实现简单</p><p>反例： Properties extends Hashtable
Stack extends Vector</p><p>正例： Set extends Collection</p><h3 id=为继承做设计和文档否则禁止>为继承做设计和文档否则禁止<a hidden class=anchor aria-hidden=true href=#为继承做设计和文档否则禁止>#</a></h3><p>继承违反封装（Snyder, 86）</p><ul><li>子类对于父类的实现细节敏感</li></ul><p>如果你允许建子类，那么就文档自用</p><ul><li>方法如何相互使用</li></ul><p>保守策略：所有具体的类都不可变（final）</p><p>反例：J2SE 包中许多的具体类
正例：AbstractSet, AbstractMap</p><h2 id=iv-方法设计>IV 方法设计<a hidden class=anchor aria-hidden=true href=#iv-方法设计>#</a></h2><h3 id=别让客户端把模板能做的事都做了>别让客户端把模板能做的事都做了<a hidden class=anchor aria-hidden=true href=#别让客户端把模板能做的事都做了>#</a></h3><p>减少对样板代码的需要</p><ul><li>通常经 cut-and-paste 完成</li><li>丑陋、恼人并且易错</li></ul><h3 id=不要违反最小原则>不要违反最小原则<a hidden class=anchor aria-hidden=true href=#不要违反最小原则>#</a></h3><p>API 的使用者不应该对于某些行为感到惊讶</p><ul><li>值得额外的实现努力</li><li>这甚至值得降低性能</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Thread</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Runnable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Tests whether current thread has been interrupted</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Clears the interrupted status of current thread.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>interrupted</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>上面的第二行注释所述的功能就做了额外的没必要的努力，违背了最小原则</p><h3 id=当错误发生尽可能快地产生错误报告>当错误发生尽可能快地产生错误报告<a hidden class=anchor aria-hidden=true href=#当错误发生尽可能快地产生错误报告>#</a></h3><p>编译时报错最佳——静态拼写、generics</p><p>在运行时，第一个方法调用失败为最佳</p><ul><li>方法应该是原子性失败（failure-atomic）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// A Properties instance maps strings to strings</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Properties</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Hashtable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Throws ClassCastException if this Properties</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// contains any keys or values that are not strings</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>save</span><span class=p>(</span><span class=n>OutputStream</span><span class=w> </span><span class=n>out</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>comments</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=为所有的数据访问提供字符串的形式的编程接口>为所有的数据访问提供字符串的形式的编程接口<a hidden class=anchor aria-hidden=true href=#为所有的数据访问提供字符串的形式的编程接口>#</a></h3><h4 id=否则客户端需要做字符串转换>否则客户端需要做字符串转换<a hidden class=anchor aria-hidden=true href=#否则客户端需要做字符串转换>#</a></h4><ul><li>对于客户端来说很痛苦</li><li>更糟糕的是，turns strings format into de facto API（无力翻译 orz）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Throwable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>printStackTrace</span><span class=p>(</span><span class=n>PrintStream</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>StackTraceElement</span><span class=o>[]</span><span class=w> </span><span class=nf>getStackTrace</span><span class=p>();</span><span class=w>		</span><span class=c1>// Since 1.4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>StackTraceElement</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getFilaName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getLineNumber</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getClassName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getMethodName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isNativeMethod</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=小心重载>小心重载<a hidden class=anchor aria-hidden=true href=#小心重载>#</a></h3><h4 id=避免模糊的重载>避免模糊的重载<a hidden class=anchor aria-hidden=true href=#避免模糊的重载>#</a></h4><ul><li>多个重载适用于相同的情况</li><li>保守策略：没有两个重载拥有同样多的参数个数</li></ul><h4 id=仅仅是因为你可以但不意味着你应当>仅仅是因为你可以但不意味着你应当<a hidden class=anchor aria-hidden=true href=#仅仅是因为你可以但不意味着你应当>#</a></h4><ul><li>通常最好使用不同的名字</li></ul><h4 id=如果你必须提供模糊的重载请确保相同的参数拥有相同的行为>如果你必须提供模糊的重载，请确保相同的参数拥有相同的行为<a hidden class=anchor aria-hidden=true href=#如果你必须提供模糊的重载请确保相同的参数拥有相同的行为>#</a></h4><p>反例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=nf>TreeSet</span><span class=p>(</span><span class=n>Collection</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>		</span><span class=c1>// Ignores order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=nf>TreeSet</span><span class=p>(</span><span class=n>SortedSet</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>		</span><span class=c1>// Respects order</span><span class=w>
</span></span></span></code></pre></div><h3 id=使用恰当的参数和返回类型>使用恰当的参数和返回类型<a hidden class=anchor aria-hidden=true href=#使用恰当的参数和返回类型>#</a></h3><p>赞成接口类型作为类的输入</p><ul><li>提供灵活性、性能</li></ul><p>使用最具体的可能的输入参数类型</p><ul><li>把运行时错误提前到编译时</li></ul><p>如果存在更好的类型请别用 String 类型</p><ul><li>Strings 是繁琐的、易错的并且慢的</li></ul><p>不要将浮点数用于货币值</p><ul><li>二进制浮点会导致不精确的结果</li></ul><p>使用 double(64 位)优于 float(32 位)</p><ul><li>精确度损失是真实的，性能损失是可忽略的</li></ul><h3 id=在方法之间使用一致的参数顺序>在方法之间使用一致的参数顺序<a hidden class=anchor aria-hidden=true href=#在方法之间使用一致的参数顺序>#</a></h3><h4 id=如果参数类型相同尤其重要>如果参数类型相同，尤其重要<a hidden class=anchor aria-hidden=true href=#如果参数类型相同尤其重要>#</a></h4><p>反例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=nf>strcpy</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>bcopy</span>   <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span></code></pre></div><p>正例：
java.util.Collections——第一个参数总被收集来用于修改或查询</p><p>java.util.concurrent——time 总被指定为 long delay, TimeUnit unit</p><h3 id=避免长参数列表>避免长参数列表<a hidden class=anchor aria-hidden=true href=#避免长参数列表>#</a></h3><p>三个或更少参数是比较理想的</p><ul><li>如果存在更多，用户则需参阅文档</li></ul><p>相同类型的长参数列表是有害的</p><ul><li>程序员会错误地转置参数</li><li>程序仍会编译、运行，但行为不端</li></ul><p>两种缩短参数列表的技巧</p><ul><li>拆分方法</li><li>创建辅助类来保存参数</li></ul><p>反例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=c1>// Eleven parameters including four consecutive ints</span>
</span></span><span class=line><span class=cl><span class=n>HWND</span> <span class=n>CreateWindow</span><span class=p>(</span><span class=n>LPCTSTR</span> <span class=n>lpClassName</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpWindowName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>DWORD</span> <span class=n>dwStyle</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nWidth</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nHeight</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>HWND</span> <span class=n>hWndParent</span><span class=p>,</span> <span class=n>HMENU</span> <span class=n>hMenu</span><span class=p>,</span> <span class=n>HINSTANCE</span> <span class=n>hInstance</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>LPVOID</span> <span class=n>lpParam</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=避免返回值需要异常处理>避免返回值需要异常处理<a hidden class=anchor aria-hidden=true href=#避免返回值需要异常处理>#</a></h3><p>返回零长度数组或空集合而非 null</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nn>java.awt.image</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>BufferedImageOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Returns the rendering hints for this operation,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// or null if no hints have been set.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>RenderingHints</span><span class=w> </span><span class=nf>getRenderingHints</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=v异常设计>V.异常设计<a hidden class=anchor aria-hidden=true href=#v异常设计>#</a></h2><h3 id=抛出异常以表明异常的条件>抛出异常以表明异常的条件<a hidden class=anchor aria-hidden=true href=#抛出异常以表明异常的条件>#</a></h3><p>不要强迫客户端去使用异常来控制流</p><p>反例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>BUF_SIZE</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>void</span><span class=w> </span><span class=nf>processBuffer</span><span class=w> </span><span class=p>(</span><span class=n>ByteBuffer</span><span class=w> </span><span class=n>buf</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>buf</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>processBytes</span><span class=p>(</span><span class=n>tmp</span><span class=p>,</span><span class=w> </span><span class=n>BUF_SIZE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>BufferUnderflowException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>remaining</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buf</span><span class=p>.</span><span class=na>remaining</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>buf</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>remaning</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>processBytes</span><span class=p>(</span><span class=n>bufArray</span><span class=p>,</span><span class=w> </span><span class=n>remaining</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>反过来，不要安静的失败</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ThreadGroup</span><span class=p>.</span><span class=na>enumerate</span><span class=p>(</span><span class=n>Thread</span><span class=o>[]</span><span class=w> </span><span class=n>list</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h3 id=赞成未经检查的异常>赞成未经检查的异常<a hidden class=anchor aria-hidden=true href=#赞成未经检查的异常>#</a></h3><p>已检查——客户端必须采取修复措施</p><p>未检查——程序报错</p><p>过度使用已检查的异常会导致样板化</p><p>反例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Foo</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span><span class=w> </span><span class=kd>super</span><span class=p>.</span><span class=na>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>CloneNotSupportedException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// This can&#39;t happen, since we&#39;re Cloneable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AssertionError</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=在异常中包含错误捕获信息>在异常中包含错误捕获信息<a hidden class=anchor aria-hidden=true href=#在异常中包含错误捕获信息>#</a></h3><p>允许诊断、修复或恢复</p><p>对于未检查的异常，信息就足够了</p><p>对于已检查的异常，提供访问者</p><h2 id=vi-重构-api-设计>VI 重构 API 设计<a hidden class=anchor aria-hidden=true href=#vi-重构-api-设计>#</a></h2><h3 id=向量的子列表操作>向量的子列表操作<a hidden class=anchor aria-hidden=true href=#向量的子列表操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Vector</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>indexOf</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>elem</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>lastIndexOf</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>elem</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>不够强大——只支持搜索</p><p>没有文档很难使用</p><h3 id=字列表操作重构>字列表操作重构<a hidden class=anchor aria-hidden=true href=#字列表操作重构>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>List</span><span class=w> </span><span class=nf>subList</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>fromIndex</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>toIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>非常强大——支持所有的操作</p><p>接口的使用减少了概念的重量</p><ul><li>高功率重量比</li></ul><p>没有文档也易于使用</p><h3 id=thread-local-变量>Thread-local 变量<a hidden class=anchor aria-hidden=true href=#thread-local-变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Broken - inappropriate use of String as capability.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Keys constitue a shared global namespace.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>ThreadLocal</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w>    </span><span class=c1>// Non-instantiable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Sets current thread&#39;s value for named variable.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>set</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Returns current thread&#39;s value for named variable.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>get</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>key</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=thread-local-变量重构1>Thread-Local 变量重构（1）<a hidden class=anchor aria-hidden=true href=#thread-local-变量重构1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>ThreadLocal</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w>  </span><span class=c1>// Noninstantiable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>Key</span><span class=w> </span><span class=p>{</span><span class=w>	</span><span class=n>Key</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Generates a unique, unforgeable key</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>set</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>get</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=有效但是需要使用样板代码>有效，但是需要使用样板代码<a hidden class=anchor aria-hidden=true href=#有效但是需要使用样板代码>#</a></h3><p>例如:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=n>ThreadLocal</span><span class=p>.</span><span class=na>Key</span><span class=w> </span><span class=n>serialNumberKey</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ThreadLocal</span><span class=p>.</span><span class=na>getKey</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ThreadLocal</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>serialNumberKey</span><span class=p>,</span><span class=w> </span><span class=n>nextSerialNumber</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>ThreadLocal</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>serialNumberKey</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><h4 id=thread-local-变量重构2>Thread-Local 变量重构（2）<a hidden class=anchor aria-hidden=true href=#thread-local-变量重构2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>ThreadLocal</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>set</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=消除-api-和客户端代码之间的混乱>消除 API 和客户端代码之间的混乱<a hidden class=anchor aria-hidden=true href=#消除-api-和客户端代码之间的混乱>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=n>ThreadLocal</span><span class=w> </span><span class=n>serialNumber</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadLocal</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>serialNumber</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>nextSerialNumber</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>serialNumber</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></div><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><h3 id=api-设计是一种高贵且有益的工艺>API 设计是一种高贵且有益的工艺<a hidden class=anchor aria-hidden=true href=#api-设计是一种高贵且有益的工艺>#</a></h3><ul><li>改进了很多程序员、最终用户和公司</li></ul><h3 id=这次谈话涵盖了一些启发式的手艺>这次谈话涵盖了一些启发式的手艺<a hidden class=anchor aria-hidden=true href=#这次谈话涵盖了一些启发式的手艺>#</a></h3><ul><li>不要狂妄地坚持，但&mldr;</li><li>不要没有理由的违反</li></ul><h3 id=api-设计很难>API 设计很难<a hidden class=anchor aria-hidden=true href=#api-设计很难>#</a></h3><ul><li>不是一个孤独的活动</li><li>完美是无法实现的，但无论如何都要尝试</li></ul><h2 id=个人评价总结>个人评价&总结<a hidden class=anchor aria-hidden=true href=#个人评价总结>#</a></h2><p>本文评价了很多 Java 语言包以及面向对象的优点和缺点，也包含 C 语言的部分例子。本文作者 Joshua Bloch 同时也是 Effective Java 的作者。本文中有些用词比较晦涩难懂，但通篇整体很好也很全面地剖析了 API 设计的重要性及一部分技巧和注意事项，值得参考借鉴。</p><p>翻译过程也是磕磕绊绊，很多地方自我感觉翻译的不甚准确，甚至有问题，实在找不到合适的翻译的地方注明了原文或保留原文词句，希望有心读者能指正并反馈。不过翻译的过程的确为了理解作者原意，也会竭尽脑力去思考和体会字里行间所表达的思想，收益良多。
其中不乏有些建议的确出现于日常的编程实践，并作为编程规范存在于最佳实践中，一眼就能理解。也有一些目前可能尚未在实际应用中良好实践。</p><p>原文链接：<a href=https://web.archive.org/web/20110903030015/http://lcsd05.cs.tamu.edu/slides/keynote.pdf>https://web.archive.org/web/20110903030015/http://lcsd05.cs.tamu.edu/slides/keynote.pdf</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://barnett617.github.io/wilson-blog/tags/api/>API</a></li></ul><nav class=paginav><a class=prev href=https://barnett617.github.io/wilson-blog/posts/2018-01-17-webpack-basic/><span class=title>« 上一页</span><br><span>webpack学习笔记</span>
</a><a class=next href=https://barnett617.github.io/wilson-blog/posts/2017-11-28-vultr-billing-and-ssr-on-vultr/><span class=title>下一页 »</span><br><span>vultr账单解析及使用ssr在vultr搭建代理</span></a></nav><script async crossorigin=anonymous src=/wilson-blog/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share 如何设计良好的API并且为什么这很重要（译） on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 如何设计良好的API并且为什么这很重要（译） on x" href="https://x.com/intent/tweet/?text=%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e8%89%af%e5%a5%bd%e7%9a%84API%e5%b9%b6%e4%b8%94%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e5%be%88%e9%87%8d%e8%a6%81%ef%bc%88%e8%af%91%ef%bc%89&amp;url=https%3a%2f%2fbarnett617.github.io%2fwilson-blog%2fposts%2f2018-01-16-api-designing-translation%2f&amp;hashtags=API"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>