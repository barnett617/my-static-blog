<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>React教程之快速上手篇 | Wilson's Blog</title>
<meta name=keywords content="react"><meta name=description content="React 官方教程系列之快速上手篇"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.659e049f7d2efb8a004f34ec6fb29b526477a978c7fb695f4c301f8864c325c5.css integrity="sha256-ZZ4En30u+4oATzTsb7KbUmR3qXjH+2lfTDAfiGTDJcU=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="React教程之快速上手篇"><meta property="og:description" content="React 官方教程系列之快速上手篇"><meta property="og:type" content="article"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-01T15:32:54+00:00"><meta property="article:modified_time" content="2018-02-01T15:32:54+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="React教程之快速上手篇"><meta name=twitter:description content="React 官方教程系列之快速上手篇"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://barnett617.github.io/wilson-blog/posts/"},{"@type":"ListItem","position":2,"name":"React教程之快速上手篇","item":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React教程之快速上手篇","name":"React教程之快速上手篇","description":"React 官方教程系列之快速上手篇\n","keywords":["react"],"articleBody":"React 官方教程系列之快速上手篇\nHello World React 官网的 Quick Start 提供了一个在线编辑器 CodePen，里面提供了一个 react 的最小配置示例，即\nReactDOM.render( \u003ch1\u003eHello, World\u003c/h1\u003e, document.getElementById('root') ); 这个 js 文件将会把 html 文件渲染出 Hello，World 这个标题\nhtml 文件结构如下\n\u003cdiv id=\"root\"\u003e\u003c/div\u003e 接下来将探析 React 应用的构建块部分：元素、组件\n一旦掌握，便可通过碎小的可复用块创造复杂的应用\n关于 React 于 JavaScript 的关系 React 是一个 JavaScript 库（library）\n官网给出的建议是在学习 React 前确保自己的 JavaScript 有所理解，参照另一篇博文Refresh your JavaScript Knowledge\n我们在例子里也用到了一些 ES6 语法。我们试图保守地用它，因为它还近乎崭新，但我们鼓励你熟悉一下箭头函数、类、模板字、let 和 const 语句。你可以使用Babel REPL来检查 ES6 代码编译成什么样\nJSX 介绍 考虑这个变量声明：\nconst element = \u003ch1\u003eHello, world!\u003c/h1\u003e; 这个搞笑的标签语法既不是一个字符串也不是 HTML\n它叫做 JSX，并且它是 JavaScript 的一种语法拓展。我们推荐你在 React 使用它来描述 UI 看上去应该的样子。JSX 可能使你想起模板语言，但它完全来自 JavaScript 的强大\nJSX 生产 React“元素”。我们将在下一部分探索把它们渲染成 DOM。在下面你会发现 JSX 必备基础来使你开始\n为什么用 JSX React 拥抱渲染逻辑本质上是加上其他的 UI 逻辑这样的事实：事件如何处理，状态如何改变，还有数据如何被准备好用作展示\n不是通过把标记和逻辑放在不同的文件中这样人为的分离技术，取而代之 React 分离聚焦在两个称作组件的松耦合单元（原文：React separates concerns with loosely coupled units called “components” that contain both.）我们会在后面的部分回到组件，但如果你还对于把标记放进 JavaScript 感到不舒服，这段谈话可能会使你信服。\nReact 并不一定要使用 JSX，但大多数人发现这在他们处理 JavaScript 代码中的 UI 时，JSX 像一个可视化目标一样帮到他们。它也允许 React 去展示更多有用的错误和警告信息\n有了这些方法，让我们开始吧！\n在 JSX 中嵌入表达式 你可以在 JSX 中嵌入任何 JavaScript 表达式，通过包裹在大括号内\n例如：2 + 2、user.firstName 和 formatName(user)都是有效的表达式：\nfunction formatName(user) { return user.firstName + \" \" + user.lastName; } const user = { firstName: \"Harper\", lastName: \"Perez\", }; const element = \u003ch1\u003eHello, {formatName(user)}!\u003c/h1\u003e; ReactDOM.render(element, document.getElementById(\"root\")); 我们为了可读性把 JSX 拆分成多行。虽然不是必须的，当这样做时，我们还是建议用括号包裹起来以避免自动分号的陷阱\nJSX 也是表达式 在编译之后，JSX 表达式成为常规的 JavaScript 函数调用和评估\n这意味着你可以在 if 语句和 for 循环内使用 JSX，把它赋值给变量，接受它作为参数，还有从函数返回它\nfunction getGreeting(user) { if (user) { return \u003ch1\u003eHello, {formatName(user)}!\u003c/h1\u003e; } return \u003ch1\u003eHello, Stranger.\u003c/h1\u003e; } 为 JSX 指定属性 你可能使用引号来指定字符串文字作为属性：\nconst element = \u003cdiv tabIndex=\"0\"\u003e\u003c/div\u003e; 你也可能使用花括号来在属性内嵌入 JavaScript 表达式\nconst element = \u003cimg src={user.avatarUrl}\u003e\u003c/img\u003e; 当向一个属性内嵌入 JavaScript 表达式时，不要在花括号外加引号。你应该使用引号（对字符串值）或花括号（对表达式），但不应该二者都用于属性\n警告：因为 JSX 比起 HTML 更像 JavaScript，React DOM 使用驼峰属性命名法取代 HTML 属性名称。例如，在 JSX 中，class 变成 className，tabindex 变成 tabIndex\n为 JSX 指定子 如果一个标签是空的，你可能会立即用一个/\u003e关上它，像 XML：\nconst element = \u003cimg src={user.avatarUrl} /\u003e; JSX 标签可能包含子：\nconst element = ( \u003cdiv\u003e \u003ch1\u003eHello!\u003c/h1\u003e \u003ch2\u003eGood to see you here.\u003c/h2\u003e \u003c/div\u003e ); JSX 避免注入攻击 在 JSX 中嵌入用户输入是安全的\nconst title = response.potentiallyMaliciousInput; const element \u003ch1\u003e{title}\u003c/h1\u003e; 默认的，React DOM 会在渲染之前转义嵌在 JSX 中的值。从而确保你永远不会注入任何写在你程序里不明确的东西。任何东西都会在渲染之前被转换为字符串。这避免了 XSS 攻击\nJSX 表示对象 Babel 编译 JSX 为 React.createElement()调用\n下面两个例子完全相同：\nconst element = \u003ch1 className=\"greeting\"\u003eHello, world!\u003c/h1\u003e; const element = React.createElement( \"h1\", { className: \"greeting\" }, \"Hello world\" ); React.createElement()实施了一些检查以帮助你写出无缺陷的代码，但会潜在创造一个如下的对象：\nconst element = { type: \"h1\", props: { className: \"greeting\", children: \"Hello, world\", }, }; 这些对象称为 React 元素。你可以把它们当作你想在屏幕上看到的东西的描述。React 读取这些对象并使用它们去构造 DOM 并保持它们为最新的\n我们将会在下个部分探索渲染 React 元素为 DOM\nTip: 我们推荐你为你的编辑器选择使用Babel 语言定义，这样 ES6 和 JSX 就可以正确地高亮显示。（原文此处使用Oceanic Next颜色主题）\n渲染元素 元素是 React 应用最小的构建块\n元素描述了你想在屏幕上看到的东西：\nconst element = \u003ch1\u003eHello, world\u003c/h1\u003e; 不像浏览器 DOM 元素，React 元素是纯文本对象，并且容易创建。React DOM 关心更新 DOM 以匹配 React 元素\n有人可能会混淆元素一个更广为人知的概念——“组件”。我们将会介绍组件在下一部分。元素是组件的组成部分并且我们鼓励你跳读前阅读组件这个部分\n把元素渲染为 DOM 让我们假设在你的 HTML 文件中的某个地方有一个\n\u003cdiv id=\"root\"\u003e\u003c/div\u003e 我们称其为 DOM“根”节点，因为所以其内的节点都受管于 React DOM\n仅用 React 构建的程序经常只有一个唯一的根 DOM 节点。如果你将 React 集成进一个已存在的应用，你可以有尽可能多的孤立的根 DOM\n渲染一个 React 元素为一个根 DOM 节点，通过 ReactDOM.render()：\nconst element = \u003ch1\u003eHello, world\u003c/h1\u003e; ReactDOM.render(element, document.getElementById(\"root\")); 更新渲染的元素 React 元素是一成不变的。一旦你创建一个元素，你无法改变它的子或者属性。元素就像电影中的一帧：它展现了在以一个特定时间点的 UI\n就我们现在所知，更新 UI 的唯一方式是创建一个新的元素，并把它传递给 ReactDOM.render()\n考虑一下这个钟表滴答例子：\nfunction tick() { const element = ( \u003cdiv\u003e \u003ch1\u003eHello, world!\u003c/h1\u003e \u003ch2\u003e It is{' '} {hew Date().toLocaleTimeString()}. \u003c/h2\u003e \u003c/div\u003e ); ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 它从setInterval()的回调函数每秒调用一次 ReactDOM.render()\n实际上，大多数 React 应用只调用一次 ReactDOM.render()。在下一个部分我们将学习怎样把这样的代码装进状态组件。我们推荐你不要跳过话题，因为它们依赖于彼此。\nReact 只更新必要的东西 React DOM 会比较元素及其子元素与前一个状态的对比，只把必要的 DOM 更新为适用于所需的状态\n你可通过使用浏览器工具检查上一个例子来确认\n即使我们每一秒创建一个元素来描述整个 UI 树，但只有内容改变的文本节点通过 React DOM 获得更新\n在我们的实验中，思考 UI 如何根据给出的时刻而不是随着时间的推移进行改变，消除整个类的错误\n组件和 props 组件使你将 UI 分离成独立的部分、可重用的碎片并隔离的考虑每一个碎片\n概念上讲，组件像是 JavaScript 的函数。它们接收任意的输入（称作 props）并返回 React 元素来描述屏幕上发生了什么\n功能组件和类组件 定义一个组件最简单的方式就是写一个 JavaScript 函数：\nfunction Welcome(props) { return \u003ch1\u003eHello, {props.name}\u003c/h1\u003e; } 这个函数是一个有效的 React 组件，因为它接收了一个伴有数据的单一的 props（表示属性）对象参数并返回了一个 React 元素。我们称这样的组件为函数组件，因为它们字面上是 JavaScript 函数\n你也可以使用一个 ES6 的类来定义一个组件\nclass Welcome extends React.Comoponent { render() { return \u003ch1\u003eHello, {this.props.name}\u003c/h1\u003e } } 以上两个组件从 React 的角度等价\n类有一些额外特性我们将在接下来的部分讨论。到那时，我们将因其简明性而使用函数组件\n渲染一个组件 先前，我们只遇到 React 元素呈现 DOM 标签：\nconst element = \u003cdiv /\u003e; 然而，元素也可以呈现用户定义的组件：\nconst element = \u003cWelcome name=\"Sara\" /\u003e; 当 React 看到一个元素展现一个用户定义的组件时，它作为一个单独的对象传递 JSX 参数给这个组件。我们称这个对象为“props”\n比如，这个代码渲染“你好，Sara”在页面上：\nfunction Welcome(props) { return \u003ch1\u003eHello, {props.name}\u003c/h1\u003e; } 参考链接：\nhttps://reactjs.org/docs/\nhttps://codepen.io/pen?\u0026editors=0010\n","wordCount":"522","inLanguage":"zh","datePublished":"2018-02-01T15:32:54Z","dateModified":"2018-02-01T15:32:54Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>React教程之快速上手篇</h1><div class=post-meta><span title='2018-02-01 15:32:54 +0000 UTC'>2018-02-01 15:32:54</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;522 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2018-02-01-react-quick-start.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#hello-world>Hello World</a></li><li><a href=#关于-react-于-javascript-的关系>关于 React 于 JavaScript 的关系</a></li><li><a href=#jsx-介绍>JSX 介绍</a></li><li><a href=#渲染元素>渲染元素</a></li><li><a href=#组件和-props>组件和 props</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>React 官方教程系列之快速上手篇</p><h3 id=hello-world>Hello World<a hidden class=anchor aria-hidden=true href=#hello-world>#</a></h3><p>React 官网的 Quick Start 提供了一个在线编辑器 CodePen，里面提供了一个 react 的最小配置示例，即</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=nx>World</span><span class=o>&lt;</span><span class=err>/h1&gt;,</span>
</span></span><span class=line><span class=cl>	<span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;root&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>这个 js 文件将会把 html 文件渲染出 Hello，World 这个标题</p><p>html 文件结构如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>div</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;root&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>接下来将探析 React 应用的构建块部分：元素、组件</p><p>一旦掌握，便可通过碎小的可复用块创造复杂的应用</p><h3 id=关于-react-于-javascript-的关系>关于 React 于 JavaScript 的关系<a hidden class=anchor aria-hidden=true href=#关于-react-于-javascript-的关系>#</a></h3><p>React 是一个 JavaScript 库（library）</p><p>官网给出的建议是在学习 React 前确保自己的 JavaScript 有所理解，参照另一篇博文Refresh your JavaScript Knowledge</p><p>我们在例子里也用到了一些 ES6 语法。我们试图保守地用它，因为它还近乎崭新，但我们鼓励你熟悉一下箭头函数、类、模板字、let 和 const 语句。你可以使用Babel REPL来检查 ES6 代码编译成什么样</p><h3 id=jsx-介绍>JSX 介绍<a hidden class=anchor aria-hidden=true href=#jsx-介绍>#</a></h3><p>考虑这个变量声明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>const</span> <span class=n>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span><span class=n>Hello</span><span class=p>,</span> <span class=n>world</span><span class=o>!&lt;/</span><span class=n>h1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>这个搞笑的标签语法既不是一个字符串也不是 HTML</p><p>它叫做 JSX，并且它是 JavaScript 的一种语法拓展。我们推荐你在 React 使用它来描述 UI 看上去应该的样子。JSX 可能使你想起模板语言，但它完全来自 JavaScript 的强大</p><p>JSX 生产 React“元素”。我们将在下一部分探索把它们渲染成 DOM。在下面你会发现 JSX 必备基础来使你开始</p><h4 id=为什么用-jsx>为什么用 JSX<a hidden class=anchor aria-hidden=true href=#为什么用-jsx>#</a></h4><p>React 拥抱渲染逻辑本质上是加上其他的 UI 逻辑这样的事实：事件如何处理，状态如何改变，还有数据如何被准备好用作展示</p><p>不是通过把标记和逻辑放在不同的文件中这样人为的分离技术，取而代之 React 分离聚焦在两个称作组件的松耦合单元（原文：React separates concerns with loosely coupled units called “components” that contain both.）我们会在后面的部分回到组件，但如果你还对于把标记放进 JavaScript 感到不舒服，这段谈话可能会使你信服。</p><p>React 并不一定要使用 JSX，但大多数人发现这在他们处理 JavaScript 代码中的 UI 时，JSX 像一个可视化目标一样帮到他们。它也允许 React 去展示更多有用的错误和警告信息</p><p>有了这些方法，让我们开始吧！</p><h4 id=在-jsx-中嵌入表达式>在 JSX 中嵌入表达式<a hidden class=anchor aria-hidden=true href=#在-jsx-中嵌入表达式>#</a></h4><p>你可以在 JSX 中嵌入任何 JavaScript 表达式，通过包裹在大括号内</p><p>例如：2 + 2、user.firstName 和 formatName(user)都是有效的表达式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>formatName</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>user</span><span class=p>.</span><span class=nx>firstName</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=nx>user</span><span class=p>.</span><span class=nx>lastName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>firstName</span><span class=o>:</span> <span class=s2>&#34;Harper&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>lastName</span><span class=o>:</span> <span class=s2>&#34;Perez&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=nx>formatName</span><span class=p>(</span><span class=nx>user</span><span class=p>)}</span><span class=o>!&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span><span class=nx>element</span><span class=p>,</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;root&#34;</span><span class=p>));</span>
</span></span></code></pre></div><p>我们为了可读性把 JSX 拆分成多行。虽然不是必须的，当这样做时，我们还是建议用括号包裹起来以避免自动分号的陷阱</p><h4 id=jsx-也是表达式>JSX 也是表达式<a hidden class=anchor aria-hidden=true href=#jsx-也是表达式>#</a></h4><p>在编译之后，JSX 表达式成为常规的 JavaScript 函数调用和评估</p><p>这意味着你可以在 if 语句和 for 循环内使用 JSX，把它赋值给变量，接受它作为参数，还有从函数返回它</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getGreeting</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=nx>formatName</span><span class=p>(</span><span class=nx>user</span><span class=p>)}</span><span class=o>!&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=nx>Stranger</span><span class=p>.</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=为-jsx-指定属性>为 JSX 指定属性<a hidden class=anchor aria-hidden=true href=#为-jsx-指定属性>#</a></h4><p>你可能使用引号来指定字符串文字作为属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>tabIndex</span><span class=o>=</span><span class=s2>&#34;0&#34;</span><span class=o>&gt;&lt;</span><span class=err>/div&gt;;</span>
</span></span></code></pre></div><p>你也可能使用花括号来在属性内嵌入 JavaScript 表达式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>const</span> <span class=n>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=n>img</span> <span class=n>src</span><span class=o>=</span><span class=p>{</span><span class=n>user</span><span class=o>.</span><span class=n>avatarUrl</span><span class=p>}</span><span class=o>&gt;&lt;/</span><span class=n>img</span><span class=o>&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>当向一个属性内嵌入 JavaScript 表达式时，不要在花括号外加引号。你应该使用引号（对字符串值）或花括号（对表达式），但不应该二者都用于属性</p><blockquote><p>警告：因为 JSX 比起 HTML 更像 JavaScript，React DOM 使用驼峰属性命名法取代 HTML 属性名称。例如，在 JSX 中，class 变成 className，tabindex 变成 tabIndex</p></blockquote><h4 id=为-jsx-指定子>为 JSX 指定子<a hidden class=anchor aria-hidden=true href=#为-jsx-指定子>#</a></h4><p>如果一个标签是空的，你可能会立即用一个/>关上它，像 XML：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>img</span> <span class=nx>src</span><span class=o>=</span><span class=p>{</span><span class=nx>user</span><span class=p>.</span><span class=nx>avatarUrl</span><span class=p>}</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>JSX 标签可能包含子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=o>!&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>h2</span><span class=o>&gt;</span><span class=nx>Good</span> <span class=nx>to</span> <span class=nx>see</span> <span class=nx>you</span> <span class=nx>here</span><span class=p>.</span><span class=o>&lt;</span><span class=err>/h2&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><h4 id=jsx-避免注入攻击>JSX 避免注入攻击<a hidden class=anchor aria-hidden=true href=#jsx-避免注入攻击>#</a></h4><p>在 JSX 中嵌入用户输入是安全的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>title</span> <span class=o>=</span> <span class=nx>response</span><span class=p>.</span><span class=nx>potentiallyMaliciousInput</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span></code></pre></div><p>默认的，React DOM 会在渲染之前转义嵌在 JSX 中的值。从而确保你永远不会注入任何写在你程序里不明确的东西。任何东西都会在渲染之前被转换为字符串。这避免了 XSS 攻击</p><h4 id=jsx-表示对象>JSX 表示对象<a hidden class=anchor aria-hidden=true href=#jsx-表示对象>#</a></h4><p>Babel 编译 JSX 为 React.createElement()调用</p><p>下面两个例子完全相同：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>h1</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;greeting&#34;</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=nx>world</span><span class=o>!&lt;</span><span class=err>/h1&gt;;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;h1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>className</span><span class=o>:</span> <span class=s2>&#34;greeting&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;Hello world&#34;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>React.createElement()实施了一些检查以帮助你写出无缺陷的代码，但会潜在创造一个如下的对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>type</span><span class=o>:</span> <span class=s2>&#34;h1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>props</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>className</span><span class=o>:</span> <span class=s2>&#34;greeting&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>children</span><span class=o>:</span> <span class=s2>&#34;Hello, world&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这些对象称为 React 元素。你可以把它们当作你想在屏幕上看到的东西的描述。React 读取这些对象并使用它们去构造 DOM 并保持它们为最新的</p><p>我们将会在下个部分探索渲染 React 元素为 DOM</p><blockquote><p>Tip: 我们推荐你为你的编辑器选择使用Babel 语言定义，这样 ES6 和 JSX 就可以正确地高亮显示。（原文此处使用Oceanic Next颜色主题）</p></blockquote><h3 id=渲染元素>渲染元素<a hidden class=anchor aria-hidden=true href=#渲染元素>#</a></h3><p>元素是 React 应用最小的构建块</p><p>元素描述了你想在屏幕上看到的东西：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=nx>world</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span></code></pre></div><p>不像浏览器 DOM 元素，React 元素是纯文本对象，并且容易创建。React DOM 关心更新 DOM 以匹配 React 元素</p><blockquote><p>有人可能会混淆元素一个更广为人知的概念——“组件”。我们将会介绍组件在下一部分。元素是组件的组成部分并且我们鼓励你跳读前阅读组件这个部分</p></blockquote><h4 id=把元素渲染为-dom>把元素渲染为 DOM<a hidden class=anchor aria-hidden=true href=#把元素渲染为-dom>#</a></h4><p>让我们假设在你的 HTML 文件中的某个地方有一个</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>div</span> <span class=nx>id</span><span class=o>=</span><span class=s2>&#34;root&#34;</span><span class=o>&gt;&lt;</span><span class=err>/div&gt;</span>
</span></span></code></pre></div><p>我们称其为 DOM“根”节点，因为所以其内的节点都受管于 React DOM</p><p>仅用 React 构建的程序经常只有一个唯一的根 DOM 节点。如果你将 React 集成进一个已存在的应用，你可以有尽可能多的孤立的根 DOM</p><p>渲染一个 React 元素为一个根 DOM 节点，通过 ReactDOM.render()：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=nx>world</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl><span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span><span class=nx>element</span><span class=p>,</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;root&#34;</span><span class=p>));</span>
</span></span></code></pre></div><h4 id=更新渲染的元素>更新渲染的元素<a hidden class=anchor aria-hidden=true href=#更新渲染的元素>#</a></h4><p>React 元素是一成不变的。一旦你创建一个元素，你无法改变它的子或者属性。元素就像电影中的一帧：它展现了在以一个特定时间点的 UI</p><p>就我们现在所知，更新 UI 的唯一方式是创建一个新的元素，并把它传递给 ReactDOM.render()</p><p>考虑一下这个钟表滴答例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>tick</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=nx>world</span><span class=o>!&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nx>It</span> <span class=nx>is</span><span class=p>{</span><span class=s1>&#39; &#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=nx>hew</span> <span class=nb>Date</span><span class=p>().</span><span class=nx>toLocaleTimeString</span><span class=p>()}.</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=err>/h2&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>element</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;root&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setInterval</span><span class=p>(</span><span class=nx>tick</span><span class=p>,</span> <span class=mi>1000</span><span class=p>);</span>
</span></span></code></pre></div><p>它从setInterval()的回调函数每秒调用一次 ReactDOM.render()</p><blockquote><p>实际上，大多数 React 应用只调用一次 ReactDOM.render()。在下一个部分我们将学习怎样把这样的代码装进状态组件。我们推荐你不要跳过话题，因为它们依赖于彼此。</p></blockquote><h4 id=react-只更新必要的东西>React 只更新必要的东西<a hidden class=anchor aria-hidden=true href=#react-只更新必要的东西>#</a></h4><p>React DOM 会比较元素及其子元素与前一个状态的对比，只把必要的 DOM 更新为适用于所需的状态</p><p>你可通过使用浏览器工具检查上一个例子来确认</p><p>即使我们每一秒创建一个元素来描述整个 UI 树，但只有内容改变的文本节点通过 React DOM 获得更新</p><p>在我们的实验中，思考 UI 如何根据给出的时刻而不是随着时间的推移进行改变，消除整个类的错误</p><h3 id=组件和-props>组件和 props<a hidden class=anchor aria-hidden=true href=#组件和-props>#</a></h3><p>组件使你将 UI 分离成独立的部分、可重用的碎片并隔离的考虑每一个碎片</p><p>概念上讲，组件像是 JavaScript 的函数。它们接收任意的输入（称作 props）并返回 React 元素来描述屏幕上发生了什么</p><h4 id=功能组件和类组件>功能组件和类组件<a hidden class=anchor aria-hidden=true href=#功能组件和类组件>#</a></h4><p>定义一个组件最简单的方式就是写一个 JavaScript 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Welcome</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个函数是一个有效的 React 组件，因为它接收了一个伴有数据的单一的 props（表示属性）对象参数并返回了一个 React 元素。我们称这样的组件为函数组件，因为它们字面上是 JavaScript 函数</p><p>你也可以使用一个 ES6 的类来定义一个组件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Welcome</span> <span class=kr>extends</span> <span class=nx>React</span><span class=p>.</span><span class=nx>Comoponent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上两个组件从 React 的角度等价</p><p>类有一些额外特性我们将在接下来的部分讨论。到那时，我们将因其简明性而使用函数组件</p><h4 id=渲染一个组件>渲染一个组件<a hidden class=anchor aria-hidden=true href=#渲染一个组件>#</a></h4><p>先前，我们只遇到 React 元素呈现 DOM 标签：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>div</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>然而，元素也可以呈现用户定义的组件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>Welcome</span> <span class=nx>name</span><span class=o>=</span><span class=s2>&#34;Sara&#34;</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>当 React 看到一个元素展现一个用户定义的组件时，它作为一个单独的对象传递 JSX 参数给这个组件。我们称这个对象为“props”</p><p>比如，这个代码渲染“你好，Sara”在页面上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Welcome</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>参考链接：</p><ul><li><p><a href=https://reactjs.org/docs/>https://reactjs.org/docs/</a></p></li><li><p><a href="https://codepen.io/pen?&amp;editors=0010">https://codepen.io/pen?&amp;editors=0010</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://barnett617.github.io/wilson-blog/tags/react/>react</a></li></ul><nav class=paginav><a class=prev href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/><span class=title>« 上一页</span><br><span>JavaScript知识巩固</span>
</a><a class=next href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-mysql-data-recovery/><span class=title>下一页 »</span><br><span>mysql误删数据恢复</span></a></nav><script defer crossorigin=anonymous src=/wilson-blog/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share React教程之快速上手篇 on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share React教程之快速上手篇 on x" href="https://x.com/intent/tweet/?text=React%e6%95%99%e7%a8%8b%e4%b9%8b%e5%bf%ab%e9%80%9f%e4%b8%8a%e6%89%8b%e7%af%87&amp;url=https%3a%2f%2fbarnett617.github.io%2fwilson-blog%2fposts%2f2018-02-01-react-quick-start%2f&amp;hashtags=react"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>