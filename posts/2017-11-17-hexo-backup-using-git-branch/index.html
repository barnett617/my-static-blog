<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用分支备份hexo博客 | Wilson's Blog</title>
<meta name=keywords content="Git"><meta name=description content="使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。
正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。
hexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。
假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。
那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。
操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录
可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录
git init 这样 hexo 主目录会多一个隐藏目录.git
创建本地分支，与远端的分支对应
git checkout -b source 然后将 hexo 主目录的所有文件按照."><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/posts/2017-11-17-hexo-backup-using-git-branch/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.659e049f7d2efb8a004f34ec6fb29b526477a978c7fb695f4c301f8864c325c5.css integrity="sha256-ZZ4En30u+4oATzTsb7KbUmR3qXjH+2lfTDAfiGTDJcU=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/posts/2017-11-17-hexo-backup-using-git-branch/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="使用分支备份hexo博客"><meta property="og:description" content="使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。
正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。
hexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。
假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。
那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。
操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录
可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录
git init 这样 hexo 主目录会多一个隐藏目录.git
创建本地分支，与远端的分支对应
git checkout -b source 然后将 hexo 主目录的所有文件按照."><meta property="og:type" content="article"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/posts/2017-11-17-hexo-backup-using-git-branch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-11-17T17:39:36+00:00"><meta property="article:modified_time" content="2017-11-17T17:39:36+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用分支备份hexo博客"><meta name=twitter:description content="使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。
正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。
hexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。
假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。
那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。
操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录
可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录
git init 这样 hexo 主目录会多一个隐藏目录.git
创建本地分支，与远端的分支对应
git checkout -b source 然后将 hexo 主目录的所有文件按照."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://barnett617.github.io/wilson-blog/posts/"},{"@type":"ListItem","position":2,"name":"使用分支备份hexo博客","item":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-hexo-backup-using-git-branch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用分支备份hexo博客","name":"使用分支备份hexo博客","description":"使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。\n正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。\nhexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。\n假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。\n那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。\n操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录\n可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录\ngit init 这样 hexo 主目录会多一个隐藏目录.git\n创建本地分支，与远端的分支对应\ngit checkout -b source 然后将 hexo 主目录的所有文件按照.","keywords":["Git"],"articleBody":"使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。\n正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。\nhexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。\n假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。\n那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。\n操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录\n可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录\ngit init 这样 hexo 主目录会多一个隐藏目录.git\n创建本地分支，与远端的分支对应\ngit checkout -b source 然后将 hexo 主目录的所有文件按照.gitignore 文件的配置交由 git 管理（hexo 原主目录中的.gitignore 配置即可，过滤了 node_modules 目录、public 目录、deploy 目录，node_modules 目录是 hexo 使用到的相关 node 模块，不必上传，否则会出错，后面两个目录会在 hexo g -d 时发生变化，也不需要上传）\ngit add . git commmit -m \"commit hexo files to remote\" git push 添加远程仓库\ngit remote add origin URL 将本地当前分支（source）的文件上传到远端仓库的 source 分支（此命令会自动在远端仓库创建 source 分支）\n这样就实现了将 hexo 工程交由 git 管理，并在远端仓库进行备份的操作\n接下来就是异地恢复\n首先，我们要下载的是 hexo 原工程目录的文件，而不是发布后的。当前远端仓库有两个分支，主干分支存储着 hexo 发布后的文件，source 分支存储 hexo 原始工程文件。所以我们需要将远端仓库的默认分支设置为 source（master 仅用于访问，而 source 用于下载）\n然后就是克隆 source 分支的文件\ngit clone URL 本地仓库名（任意起） 然后进入本地下载下来的仓库\ncd 本地仓库名 这个时候能看到 hexo 原始工程的大部分文件，但由于上传的时候.gitignore 过滤了一些文件没上传，所以需要在本地自行生成那些文件，方式如下：\nnpm install hexo 这个命令可以通过 node 的包管理器在当前目录下载 hexo 所需要的模块，即会生成一个 node_modules 目录\n然后生成一些 hexo 初始配置文件\nhexo init 因为当前目录已经包含一些 hexo 初始文件，所以敲该命令时会提示有些重复文件未生成，没有问题，我们只需要补全那些没有的初始文件，已存在的当然就用从远端下载下来的，比如主配置文件_config.yml\n然后更新 npm 并下载发布工具\nnpm install npm install hexo-deployer-git 这样就完成了本地恢复博客所有结构的操作。\n最后，可以创建新的博文，然后更新到远端，然后在本地发布。\n每次使用前只需要拉下最新的文件，在其基础上操作即可。\n","wordCount":"176","inLanguage":"zh","datePublished":"2017-11-17T17:39:36Z","dateModified":"2017-11-17T17:39:36Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-hexo-backup-using-git-branch/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>使用分支备份hexo博客</h1><div class=post-meta><span title='2017-11-17 17:39:36 +0000 UTC'>2017-11-17 17:39:36</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;176 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2017-11-17-hexo-backup-using-git-branch.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#正文>正文</a></li><li><a href=#操作步骤>操作步骤</a></li></ul></nav></div></details></div><div class=post-content><p>使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。</p><h2 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h2><p>实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。</p><p>hexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。</p><p>假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。</p><p>那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。</p><h2 id=操作步骤>操作步骤<a hidden class=anchor aria-hidden=true href=#操作步骤>#</a></h2><p>hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录</p><p>可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git init
</span></span></code></pre></div><p>这样 hexo 主目录会多一个隐藏目录.git</p><p>创建本地分支，与远端的分支对应</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git checkout -b source
</span></span></code></pre></div><p>然后将 hexo 主目录的所有文件按照.gitignore 文件的配置交由 git 管理（hexo 原主目录中的.gitignore 配置即可，过滤了 node_modules 目录、public 目录、deploy 目录，node_modules 目录是 hexo 使用到的相关 node 模块，不必上传，否则会出错，后面两个目录会在 hexo g -d 时发生变化，也不需要上传）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git commmit -m &#34;commit hexo files to remote&#34;
</span></span><span class=line><span class=cl>git push
</span></span></code></pre></div><p>添加远程仓库</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git remote add origin URL
</span></span></code></pre></div><p>将本地当前分支（source）的文件上传到远端仓库的 source 分支（此命令会自动在远端仓库创建 source 分支）</p><p>这样就实现了将 hexo 工程交由 git 管理，并在远端仓库进行备份的操作</p><p>接下来就是异地恢复</p><p>首先，我们要下载的是 hexo 原工程目录的文件，而不是发布后的。当前远端仓库有两个分支，主干分支存储着 hexo 发布后的文件，source 分支存储 hexo 原始工程文件。所以我们需要将远端仓库的默认分支设置为 source（master 仅用于访问，而 source 用于下载）</p><p>然后就是克隆 source 分支的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>git clone URL 本地仓库名（任意起）
</span></span></code></pre></div><p>然后进入本地下载下来的仓库</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cd 本地仓库名
</span></span></code></pre></div><p>这个时候能看到 hexo 原始工程的大部分文件，但由于上传的时候.gitignore 过滤了一些文件没上传，所以需要在本地自行生成那些文件，方式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>npm install hexo
</span></span></code></pre></div><p>这个命令可以通过 node 的包管理器在当前目录下载 hexo 所需要的模块，即会生成一个 node_modules 目录</p><p>然后生成一些 hexo 初始配置文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>hexo init
</span></span></code></pre></div><p>因为当前目录已经包含一些 hexo 初始文件，所以敲该命令时会提示有些重复文件未生成，没有问题，我们只需要补全那些没有的初始文件，已存在的当然就用从远端下载下来的，比如主配置文件_config.yml</p><p>然后更新 npm 并下载发布工具</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>npm install
</span></span><span class=line><span class=cl>npm install hexo-deployer-git
</span></span></code></pre></div><p>这样就完成了本地恢复博客所有结构的操作。</p><p>最后，可以创建新的博文，然后更新到远端，然后在本地发布。</p><p>每次使用前只需要拉下最新的文件，在其基础上操作即可。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://barnett617.github.io/wilson-blog/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://barnett617.github.io/wilson-blog/posts/2017-11-28-vultr-billing-and-ssr-on-vultr/><span class=title>« 上一页</span><br><span>vultr账单解析及使用ssr在vultr搭建代理</span>
</a><a class=next href=https://barnett617.github.io/wilson-blog/posts/2017-11-17-markdown-programmer/><span class=title>下一页 »</span><br><span>Markdown语法学习整理</span></a></nav><script defer crossorigin=anonymous src=/wilson-blog/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share 使用分支备份hexo博客 on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 使用分支备份hexo博客 on x" href="https://x.com/intent/tweet/?text=%e4%bd%bf%e7%94%a8%e5%88%86%e6%94%af%e5%a4%87%e4%bb%bdhexo%e5%8d%9a%e5%ae%a2&amp;url=https%3a%2f%2fbarnett617.github.io%2fwilson-blog%2fposts%2f2017-11-17-hexo-backup-using-git-branch%2f&amp;hashtags=Git"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>