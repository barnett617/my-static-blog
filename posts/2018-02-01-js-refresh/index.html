<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript知识巩固 | Wilson's Blog</title>
<meta name=keywords content="JavaScript"><meta name=description content="Refresh your JavaScript Knowledge"><meta name=author content><link rel=canonical href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/wilson-blog/assets/css/stylesheet.7822ca91becd3fe515c67241030e80de043ab22dea5278258d676181168c3c52.css integrity="sha256-eCLKkb7NP+UVxnJBAw6A3gQ6si3qUngljWdhgRaMPFI=" rel="preload stylesheet" as=style><link rel=icon href=https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://barnett617.github.io/wilson-blog/favicon_io/favicon32x32.png><link rel=apple-touch-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><link rel=mask-icon href=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JavaScript知识巩固"><meta property="og:description" content="Refresh your JavaScript Knowledge"><meta property="og:type" content="article"><meta property="og:url" content="https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-01T21:28:22+00:00"><meta property="article:modified_time" content="2018-02-01T21:28:22+00:00"><meta property="og:site_name" content="Wilson's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="JavaScript知识巩固"><meta name=twitter:description content="Refresh your JavaScript Knowledge"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://barnett617.github.io/wilson-blog/posts/"},{"@type":"ListItem","position":2,"name":"JavaScript知识巩固","item":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript知识巩固","name":"JavaScript知识巩固","description":"Refresh your JavaScript Knowledge\n","keywords":["JavaScript"],"articleBody":"Refresh your JavaScript Knowledge\nJavaScript 知识巩固 诞生 JavaScript 于 1995 年被网景的一名工程师 Brendan Eich 所创造\n第一次发布于 1996 年早期的 Netscape 2\n最初叫 LiveScript\n但由于不幸的营销决策，为了利用 Java 的热度，而改名为 JavaScript（但与 Java 毫无联系）\n发展历程 几个月后，微软在 IE 3 中发布了 JScript\n几个月后，网景向 ECMA（欧洲标准组织）国际组织提交了 JavaScript\n于是在那一年诞生了 ECMAScript 标准的第一个版本\n这个标准在 1999 年收到了一个具有象征意义的更新，定为 ECMAScript 第三版本，从那以后版本趋于稳定\n由于有关语言复杂性的政治分歧，第四个版本被废弃掉\n随后第四版本的许多部分成为了第五个版本的基础，发版于 2009 年 12 月\n第六版发布于 2015 年 6 月\n应用场景 不像大多数语言，JavaScript 没有输入和输出的概念\n它被设计用来在宿主环境作为一种脚本语言运行，并且由宿主环境决定其与外部世界沟通的机制\n最普遍的宿主环境是浏览器\n但 JavaScript 解释器还能在以下地方找到：\nAdobe Acrobat Adobe Photoshop SVG images（矢量图） Yahoo’s Widget engine（雅虎组件引擎） 服务端环境，例如 Node.js 非关系型数据库，例如开源的 Apache CouchDB 嵌入式计算机 复杂的桌面环境，例如 GNOME（GNU/Linux 操作系统最著名的图形界面系统之一） 其他 概述 JavaScript 是一种多范式、动态语言，拥有类型、操作符、标准内建对象和方法\n它的语法基于 Java 和 C（许多这二者语言的结构都被应用于 JavaScript）\nJavaScript 支持面向对象编程通过使用对象原型（object prototypes）取代类（更多见**原型继承和 ES2015类**概念）\nJavaScript 也支持函数式编程——函数是对象，给予函数容纳可执行代码的能力并将像其他对象一样进行传递\nJavaScript 类型 Number String Boolean Function Object Symbol（ES2015 新加） 技术上更严谨的分类如下：\nNumber\nString\nBoolean\nSymbol（ES2015 新加）\nObject\nFunction Array Date RegExp Math null\nundefined\n还有一些内建的 Error 类型\nNumber JavaScript 的 Numbers 是 double-precision 64-bit format IEEE 754 values\n由于这个特点，JavaScript 中没有整型，所以在 C 或 Java 中使用到的算数运算要在 JavaScript 中留意\n比如：\n0.1+0.2 0.30000000000000004 实践中，整型值会被当做 32 位整数，并且甚至有些实现以这种方式存储，直到被要求去执行一条在 Number 上有效但在 32 位整型上无效的指令，这对于位运算来说很重要\n原文：In practice, integer values are treated as 32-bit ints, and some implementations even store it that way until they are asked to perform an instruction that’s valid on a Number but not on a 32-bit integer. This can be important for bit-wise operations.\n标准的算数运算符被支持，包括加、减、取模、取余等等\n内建对象 Math 提供了高级数学运算函数和常量\nMath.sin(3.5); -0.35078322768961984 r = 2; var circumference = 2 * Math.PI * r; console.log(circumference) 使用内建函数 parseInt()可以将一个字符串转换为整型数，但是要注意给该函数指定第二个参数（要转换的进制），如果不填会得到意想不到的结果\nparseInt('010') 10 parseInt('0x10') 16 parseInt('010', 8) 8 parseInt('0x10', 16) 16 parseInt('11',2) 3 转换为八进制省略第二个参数的方式在 2013 年后被废除，但十六进制忽略第二个参数的用法仍存在，因为可以识别到十六进制前缀0x\n还有内建函数 parseFloat 用于将字符串转换为浮点数，但不同于 parseInt()，它总是默认以十进制方式转换\n另外，还可以通过一元运算符+将值转换为数值\nparseFloat('12.34') 12.34 + '56.78'; 56.78 + '0x10' 16 + '42' 42 如果字符串是非数值，转换会返回一个特殊值 NaN（Not a Number）\nparseInt('hello', 10) NaN 如果将 NaN 作为输入，做任何算数运算所得都是 NaN\nparseInt('hello', 10) + 5 NaN 可通过内建函数 isNaN()判定是否为 NaN\nisNaN(parseInt('hello', 10) + 5) true JavaScript 还提供了特殊值：Infinity 和-Infinity\n1 / 0; Infinity -1 / 0; -Infinity 可以使用内建函数 isFinite()判断 Infinity、-Infinity 和 NaN\nisFinite(1 / 0); false isFinite(-1 / 0); false isFinite(NaN); false parseInt()、parseFloat()和+的区别：前两者会将字符串转换，直到遇到不是有效的数字止，而+会直接将字符串转换为 NaN 如果字符串内包含无效字符\nparseInt('10.2abc'); 10 + '10.2abc' NaN String JavaScript 中的字符串是 Unicode 字符序列，这对于处理国家化问题来说很方便，更准确地讲，是 sequences of UTF-16 code units，每一个码单元通过一个 16 位数字呈现，每一个 Unicode 字符通过 1 个或 2 个码单元呈现\n如果想呈现一个单字符，只需要使用一个包含单个字符的字符串\n如果想知道一个（码单元中的）字符串的长度，访问其 length 属性\n'hello'.length 5 字符串也可当做对象，并通过方法来操作字符串的信息\n'hello'.charAt(0); \"h\" 'hello, world'.replace('hello', 'hola'); \"hola, world\" 'hello'.toUpperCase(); \"HELLO\" 其他类型 JavaScript 用 null 表示 non-value（并且也仅能通过null访问）\n还有 undefined 表示一个尚未初始化的值（表示一个还未被赋值的变量）\n如果你声明一个变量，但没对其赋值（assign），这个变量的类型就是 undefined，但 undefined 实际上是一个常量\nJavaScript 还有一个布尔类型，只有两个值，true 和 false\n任何值都能被转换成一个布尔值通过以下方式：\nfalse、0、空字符串（\"\"）、NaN、null 和 undefined\n所以其他都被判定为布尔中的 true\n使用 Boolean()函数来具体实现\nBoolean(''); false Boolean(234); true 这很少情况需要这样处理，当 JavaScript 期望一个布尔值时，会静默执行布尔转换，例如ifstatement\n布尔操作符，例如\u0026\u0026（逻辑与）、||（逻辑或）和！（逻辑非）都被支持\n变量 JavaScript 通过三个关键字声明新的变量：let、const 和 var\nlet 允许声明块级变量，其声明的变量仅在封闭块中有效\nfor (let i = 1; i \u003c 5; i++) { console.log(i); } console.log(i); VM959:2 1 VM959:2 2 VM959:2 3 VM959:2 4 VM959:4 Uncaught ReferenceError: i is not defined at :4:13 const 允许声明永远不会企图改变的变量，并且也仅在所声明的块范围内有效\nfor (const j = 2; j \u003c 4; j++) { console.log(j); } console.log(j); VM1175:2 2 VM1175:1 Uncaught TypeError: Assignment to constant variable. at \u003canonymous\u003e:1:27 var 是最通用的声明关键字，它没有 let 和 const 的限制\n它是传统 JavaScript 唯一的声明变量的关键字\nfor (var k = 3; k \u003c 7; k ++) { console.log(k); } console.log(k); VM1257:2 3 VM1257:2 4 VM1257:2 5 VM1257:2 6 VM1257:4 7 JavaScript 和其他语言（比如 Java）很重要的一个区别是代码块并没有域，只有函数才有域\n所以如果在一个 compound statement（例如在 if 控制结构范围内）内使用 var 声明的变量在整个函数范围内都可见，如上例\n然而，从 ES2015 开始，let 和 const 的声明允许创建块级域变量\n运算符 JavaScript 数值运算符有+、-、*、/和%\n通过=赋值\n还有一些复合赋值操作，例如+=和-=，这相当于 x = x + y 或 x = x - y\n你可以使用++和--分别表示递增和递减，这些都可以被用作运算符前缀或后缀\n+运算符还可用作字符串连接符\n'hello' + 'world'; \"helloworld\" 如果你把一个字符串追加于一个数字或其他值，都会首先被转化为一个字符串\n\"3\" + 4 + 5; (\"345\"); 3 + 4 + \"5\"; (\"75\"); 为某个值追加一个空字符串是一个将其转换为字符串的方式\nJavaScript 使用\u003c、\u003e、\u003c=和\u003e=进行比较操作\n这些既对字符串有效，也对数字有效\n判断两个值相等并不是那么直接，如果给双等运算符==两个不同类型的值，会表现出类型约制\n123 == \"123\"; true; 1 == true; true; 为避免约制，使用三等运算符\n123 === \"123\"; false; 1 === true; false; 还有!=和!==\nJavaScript 还有**位运算符**\n控制结构 JavaScript 有一套类似 C 语言家族的控制结构\n条件语句通过 if 和 else 支持\nvar name = \"hello\"; if (name == \"test\") { name += \"test\"; } else if (name == \"hello\") { name += \"world\"; } else { name += \"!\"; } name == \"helloworld\"; true; JavaScript 拥有 while 循环和 do-while 循环，前者用于基本循环，后者用于你想确保循环至少执行一次\nwhile (true) { // an infinite loop! } var input; do { input = get_input(); } while (inputIsNotValid(input)); JavaScript 的 for 循环和 C 还有 Java 的一样，使你能够在一行内提供控制信息\nfor (var i = 0; i \u003c 5; i++) { // Will execute 5 times } JavaScript 还有两个高级 for 循环\nfor of for (let value of array) { // do something with value } for in for (let property in object) { // do something with object property } \u0026\u0026和||运算符有短路逻辑，意味着第二个运算值的是否执行决定于第一个运算值\n这有助于检查空对象在访问其属性之前\no = null; var name = o \u0026\u0026 o.getName(); null; 或进行缓存值（当假值无效时）??\nvar name = cachedName || (cachedName = getName()); JavaScript 对条件语句拥有一个三元运算符\nage = 19; var allowed = (age \u003e 18) ? 'yes' : 'no'; console.log(allowed); VM1682:3 yes switch语句可被用于基于一个数字或字符串的多分支判断\nswitch (action) { case \"draw\": drawIt(); break; case \"eat\": eatIt(); break; default: doNothing(); } 如果你没有添加 break 语句，将会在该条件下的内容执行后继续向下执行，这可能并不是你想要的，如果你的确想这么做用于调试，请添加注释表明\nswitch (a) { case 1: // fallthrough case 2: eatIt(); break; default: doNothing(); } 默认条款是可选的，你在 switch 部分和 case 部分都可以有表达式，比较会在二者使用了===运算符时发生\nswitch (1 + 3) { case 2 + 2: console.log('execute 4'); break; default: neverhappens(); } VM1831:3 execute 4 对象 JavaScript 的对象可以理解为一个键值对集合，类似于：\nPython 中的字典\nPerl 和 Ruby 中的 Hashes\nC 和 C++中的哈希表\nJava 中的 HashMap\nPHP 中的关联数组\n事实上这个数据结构被如此广泛的使用，是其多才多艺的一个佐证\n因为 JavaScript 中的一切都是对象\n任何 JavaScript 程序自然包含着一个强大的哈希表查找，这是个好事，因为很快\nJavaScript 对象的“键”部分是一个字符串，“值”部分可以是任何值\n这允许你可以构造任意复杂的数据结构\n有两种基本的创建对象的方法：\nvar obj = new Object(); 和\nvar obj = {}; 这二者语义上相等，后者称为 object literal syntax，并且更方便\n这种语法也是 JSON 格式的核心并总被偏爱\n文字对象语法可以用来完整初始化一个对象：\nvar obj = { name: 'test', _for: 'max', details: { color: 'orange', size: 12 } }; obj {name: \"test\", _for: \"max\", details: {…}} 属性可被链接到一起\nobj.details.color; (\"orange\"); obj[\"details\"][\"color\"]; (\"orange\"); 下面的例子创建了一个对象原型 Person 和一个原型实例 You\nfunction Person(name, age) { this.name = name; this.age = age; } var you = new Person('You', 24); console.log(you); VM2069:7 Person {name: \"You\", age: 24} 一经创建，一个对象的属性可被再次访问用以下两种方式：\nobj.name = \"magi\"; var name = obj.name; (\"magi\"); obj[\"name\"] = \"igma\"; var name = obj[\"name\"]; (\"igma\"); var user = prompt(\"what is your key?\"); obj[user] = prompt(\"what is your value?\"); (\"111\"); 这些也语义上相等，后者优势在于 name 属性作为一个字符串被提供，意味着可以在运行时被计算\n然而，使用这种方式可以防止了有些 JavaScript 引擎和优化器被应用\n另外，也因此可以使用关键字来设置和获得属性\nobj.for = \"Simon\"; // Syntax error, because 'for' is a reserved word obj[\"for\"] = \"Simon\"; // works fine 从 ECMAScript 5 开始，保留字可以用作对象属性名 in the buff。这意味着定义对象时不再需要引号来包裹，详情见the ES5 Spec\n更多关于对象和原型，见Object.prototype\n关于对象原型和对象原型链，见继承和原型链\n从 ECMAScript2015 开始，对象的键可以被使用括号符的变量定义\nvar userPhone = {['phoneType']: 12345}; console.log(userPhone); VM2470:2 {phoneType: 12345} 可以代替\nvar userPhone = {}; userPhone['phoneType'] = 12345; console.log(userPhone); VM2505:3 {phoneType: 12345} 数组 JavaScript 中的数组其实一种特殊类型的对象\n和常规的对象非常像（数值属性只能使用[]语法访问）\n但有一个神奇的属性叫做“length”\n其总是比数组最大索引值多一位\n创建数组的方式如下：\nvar a = new Array(); a[0] = \"dog\"; a[1] = \"cat\"; a[2] = \"hen\"; a.length; 3; 一个更方便的表示方式是使用数组文字（array literal）\nvar a = [\"dog\", \"cat\", \"hen\"]; a.length; 3; 注意 array.length 不必是数组项目的个数，考虑下面一种情况\nvar a = [\"dog\", \"cat\", \"hen\"]; a[100] = \"fox\"; a.length; 101; 谨记：数组的长度总比数组索引最大值大一位\n如果访问一个不存在的数组索引，会得到一个值为 undefined 的返回值\ntypeof a[90]; (\"undefined\"); 如果把上面的[]和 length 纳入考虑，你可以使用 for 循环迭代一个数组\nfor (var i = 0; i \u003c a.length; i++) { console.log(a[i]); } VM302:2 dog VM302:2 cat VM302:2 hen 97VM302:2 undefined VM302:2 fox ECMAScript 介绍了一种更加简明的循环 for of，用来迭代对象，比如数组：\nfor (const currentValue of a) { console.log(currentValue); } VM394:2 dog VM394:2 cat VM394:2 hen 97VM394:2 undefined VM394:2 fox 你也可以使用 for in 循环来迭代一个数组，但如果有人向 Array.prototype 添加了新的属性，它（新加的属性）在本次循环也会被迭代。所以这种循环类型不被推荐用于数组迭代\n另一种在 ECMAScript5 中添加的用来迭代数组的方式是 forEach()\n['dog', 'cat', 'hen'].forEach(function(currentValue, index, array) { console.log('currentIndex: ' + index + ' currentValue: ' + currentValue + ' array: ' + array); }); VM486:2 currentIndex: 0 currentValue: dog array: dog,cat,hen VM486:2 currentIndex: 1 currentValue: cat array: dog,cat,hen VM486:2 currentIndex: 2 currentValue: hen array: dog,cat,hen 如果想要为一个数组追加元素，只需要简单地：\na.push(item); 数组方法列表如下：\nMethod name Description Example a.toString 返回数组的每一个元素以逗号分隔的字符串 dog,cat,hen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,fox a.toLocaleString() 同 toString，不过先判断指定语言环境，没指定则使用默认语言环境，主要用于 Date 类型 - a.concat(item1[, item2[, …[,itemN]]]) 返回一个追加于其后的一个新的数组 a.concat(‘panda’,‘seal’)-\u003e [empty × 97, “hen”, “cat”, “dog”, “panda”, “seal”] a.join(sep) 转换数组为一个字符串，伴随着以 sep 参数分隔的值 dog-cat-hen————————————————————————————————–fox a.pop 移除并返回最后一项 “fox” a.push(item1, …, itemN) 向数组末端追加元素，并返回追加后的数组长度 101 a.reverse() 倒置数组 (101) [“fox”, empty × 97, “hen”, “cat”, “dog”] a.shift 移除并返回第一个元素 “fox” a.slice(start[, end]) 返回子数组 a.slice(98,100) -\u003e [“cat”, “dog”] a.sort([cmpfn]) 采用可选比较函数进行排序 a.sort()-\u003e[“cat”, “dog”, “hen”, empty × 97] a.splice(start, delcount[, item1[, …[, itemN]]]) 让你修改一个数组，通过删除一部分并使用更多条目替换之 a.splice(0, 2, ‘another cat’, ‘another dog’)-\u003e[“cat”, “dog”]-\u003ea-\u003e[“another cat”, “another dog”, “hen”, empty × 97] a.unshift(item1[, item2[, …[, itemN]]]) 预先考虑数组开头的条目 a.unshift(‘prepand item1’, ‘prepand item2’)-\u003e102-\u003ea-\u003e[“prepand item1”, “prepand item2”, “another cat”, “another dog”, “hen”, empty × 97] 更多详见array methods \u0026 toLocaleString\n函数 同对象一起，函数也是理解 JavaScript 的核心组件\n最基本的函数不能再简单\nfunction add(x, y) { var total = x + y; return tatal; } 这演示了一个基本的函数\n一个 JavaScript 函数可以有 0 个或更多的命名参数\n函数体可以包含任意多你想要的语句并且可以声明它对于它本身，自己的变量\nreturn 语句可以被用来在任何时候返回一个值，中断函数\n如果没有返回语句（或者一个空的 return 而不包含任何值），JavaScript 会返回 undefined\n命名参数比起其他任何事物更像是指导方针，只要你想，你可以调用一个函数而不用传递任何参数，这种情况它会传递 undefined 作为参数\n所以直接运行上面定义的函数，会报错，因为你给函数传递了参数 undefined\nfunction add(x, y) { var total = x + y; return total; } add(); NaN 你也可以传递函数期望的更多参数\nfunction add(x, y) { var total = x + y; return total; } add(2, 3, 4); 5 参数“4”会被忽略\n这可能会看起来有点蠢，但函数会访问其函数体内部的附加名为 arguments 的变量，它是一个类数组对象，承载了所有传递给函数的参数\n让我们重写这个 add 函数来取到和我们想要的参数一样多的参数\nfunction add() { var sum = 0; for (var i = 0, j = arguments.length; i \u003c j; i++) { sum += arguments[i]; } return sum; } add(2, 3, 4, 5); 14 再写一个平均值函数\nfunction avg() { var sum = 0; for (var i = 0, j = arguments.length; i \u003c j; i++) { sum += arguments[i]; } return sum / arguments.length; } avg(2, 3, 4, 5); 3.5 这非常有用，但有一点啰嗦。要再减少一点这份代码，我们可以考虑参数数组作取代，通过Rest parameter syntax\n用这种方式，我们可以保持代码最小化的同时传递任意数量的参数给函数\nrest 参数运算符用于函数参数列表使用\"…variable\"格式，它会包含进调用函数时整个未捕获参数列表\n我们也可以使用 for…of 循环取代 for 循环来返回变量中的值\nfunction avg(...args) { var sum = 0; for (let value of args) { sum += value; } return sum / args.length; } avg(2, 3, 4, 5); 3.5; 在上述的代码中，args 变量拥有我们传递进函数的所有函数\n很重要需要注意无论何时 rest 参数运算符被放置在一个函数声明，它都会在它声明后存储所有的参数，但不会在声明之前（存储参数），例如：function avg(firstValue, …args)将存储被传递进函数的第一个值 在 firstValue 中，剩余参数存储在 args 中。另一个有用的函数但也的确给我们带来一个新问题。avg()函数接收一个逗号分隔的参数列表——但是要是你想要得到一个数组的平均值？你只能重写这个函数如下：\nfunction avgArray(arr) { var sum = 0; for (var i = 0, j = arr.length; i \u003c j; i++) { sum += arr[i]; } return sum / arr.length; } avgArray([2, 3, 4, 5]); 3.5; 但使得这个我们创建的函数可被重用会更好。\n幸运的是，JavaScript 可以让你使用一个任意的参数数组来调用一个函数，通过使用任何函数对象的 apply()方法\navg.apply(null, [2, 3, 4, 5]); 3.5; apply()的第二个参数是用作参数的数组；第一个参数后面再讨论，这强调了一个事实——函数也是对象\n你可以在函数调用中使用 spread 操作符达到相同的结果，例如 avg(…numbers)\nJavaScript 让你可以创建匿名函数\nvar arg = function() { var sum = 0; for (var i = 0, j = arguments.length; i \u003c j; i++) { sum += arguments[i]; } return sum / arguments.length; }; 这在语义上等同于 function avg()形式\n这非常强大，因为它可以让你把一个函数定义放在任何你通常放置表达式的地方\n这使得所有种类的聪明的诀窍\n这是一种“隐藏”一些本地变量的方式——像 C 语言中的块级域\nvar a = 1; var b = 2; (function() { var b = 3; a += b; })(); console.log(a); console.log(b); VM2347:9 4 VM2347:10 2 JavaScript 允许你递归调用函数。\n这对于处理树结构尤其有用，比如那些浏览器中的 DOM\nfunction countChars(elm) { if (elm.nodeType == 3) { // TEXT_NODE return elm.nodeValue.length; } var count = 0; for (var i = 0, child; (child = elm.childNodes[i]); i++) { count += countChars(child); } return count; } 这强调了匿名函数的一个潜在问题：如果它没有名字，你怎么递归地调用它？\nJavaScript 对于此让你可以给函数表达式命名\n你可以使用命名了的 IIFEs（Immediately Invoked Function Expression）如下面所示：\nvar charsInBody = (function counter(elm) { if (elm.nodeType == 3) { // TEXT_NODE return elm.nodeValue.length; } var count = 0; for (var i = 0, child; child = elm.childNodes[i]; i++) { count += counter(child); } return count; })(document.body); undefined charsInBody 58670 如上提供给一个函数表达式的名字仅对这个函数自己的域内可用\n这允许更多的引擎优化并给出更多的可读代码\n这个名称也出现在调试器和一些堆栈信息中，这会让你在调试时节省更多时间\n注意 JavaScript 函数本身就是对象——像 JavaScript 中其他的一切一样——并且你可以添加或改变他们的属性，就像我们在对象部分所见过的\n自定义对象 更多 JavaScript 面向对象编程见Object-Oriented JavaScript\n在传统的面向对象语言编程中，对象是运算在数据上的数据和方法的集合\nJavaScript 是基于原型的语言，没有像是在 C++或 Java 中的类语句（这有时会使得习惯于使用类语句的语言的编程者感到困惑）\n取而代之，JavaScript 使用函数作为类\n让我们考虑一个有名有姓的人作为对象\n姓名可能会以两种方式展示：如“名 姓”或“姓 名”\n使用我们前面讨论的函数和对象，我们就能展示数据如下：\nfunction makePerson(first, last) { return { first: first, last: last }; } function personFullName(person) { return person.first + ' ' + person.last; } function personFullNameReversed(person) { return person.last + ', ' + person.first; } s = makePerson('Simon', 'Willison'); console.log(personFullName(s)); console.log(personFullNameReversed(s)); VM1137:15 Simon Willison VM1137:16 Willison, Simon 这有效，但很丑\n这样最后你会在全局域有很多函数\n我们真正需要的是一种把一个函数依附于一个对象的方式\n因为函数也是对象，所以这很容易：\nfunction makePerson(first, last) { return { first: first, last: last, fullName: function() { return this.first + ' ' + this.last; }, fullNameReversed: function() { return this.last + ', ' + this.first; } }; } s = makePerson('Simon', 'Willison'); console.log(s.fullName()); console.log(s.fullNameReversed()); VM1572:15 Simon Willison VM1572:16 Willison, Simon 这里有一些我们前面没见过的东西：this 关键字\n使用内部函数，this 指向当前对象\n这实际上意味着你调用函数的方式来指定\n如果你使用一个对象上的点符或括号符来调用，那么那个对象就是 this\n如果调用没用点符，this 指向全局对象\n注意 this 是一个频繁导致错误的东西，例如：\ns = makePerson(\"Simon\", \"Willison\"); var fullName = s.fullName; fullName(); (\"undefined undefined\"); 当我们单独调用 fullName()，而不用 s.fullName()，this 被绑定在全局对象\n因为没有全局变量叫 first 或者 last，所以我们对于二者都得到了 undefined\n我们可以利用 this 关键字来提高我们的 makePerson 函数\nfunction Person(first, last) { this.first = first; this.last = last; this.fullName = function () { return this.first + \" \" + this.last; }; this.fullNameReversed = function () { return this.last + \" \" + this.first; }; } var s = new Person(\"Simon\", \"Willison\"); 我们介绍了另一个关键字 new\nnew 和 this 强度关联\n它创造一个新的空对象，然后调用指定的函数，并使用 this 设置给那个新建的对象\n注意通过 this 指定的那个函数不返回一个值，但很少修改 this 对象\n是 new 返回了 this 对象到调用的地方\n被设计为通过 new 调用的函数称为构造函数\n常见的做法是利用这些函数作为一个使用 new 调用它们的提醒\n提高后的函数仍有和单独调用 fullName 相同的陷阱\n我们的 person 对象变得更好了，但对于它们仍有一些丑陋边缘\n每次我们创建一个 person 对象，我们都创建了其内的两个崭新的函数对象——如果这代码被分享不会变得更好吗？\nfunction personFullName() { return this.first + \" \" + this.last; } function personFullNameReversed() { return this.last + \", \" + this.first; } function Person(first, last) { this.first = first; this.last = last; this.fullName = personFullName; this.fullNameReversed = personFullNameReversed; } 这变得更好了，我们只创建了函数一次，并且在构造器里给它们的引用赋值\n我们能做的更好吗？答案是可以：\nfunction Person(first, last) { this.first = first; this.last = last; } Person.prototype.fullName = function() { return this.first + ' ' + this.last; }; Person.prototype.fullNameReversed = function() { return this.last + ', ' + this.first; }; ƒ () { return this.last + ', ' + this.first; } Person.prototype 是一个分享自 Person 所有实例的对象\n它形成一个查找链的一部分（有一个特殊的名字，原型链）：当任何时候你尝试去访问 Person 的一个属性时，JavaScript 会检查 Person.prototype 去看是否那个属性存在。\n然后任何赋值给 Person.prototype 的东西对于构造器的所有实例经 this 对象变得可用\n这是一个令人难以置信的强大工具\nJavaScript 让你可以修改某个东西的原型在任何时候，在你的程序里，意味着你可以在运行时对已存在的对象添加额外的方法\ns = new Person('Simon', 'Willison'); console.log(s.firstNameCaps()); VM587:2 Uncaught TypeError: s.firstNameCaps is not a function Person.prototype.firstNameCaps = function() { return this.first.toUpperCase(); }; console.log(s.firstNameCaps()); VM588:4 SIMON 有趣的是，你也可以向 JavaScript 内建对象添加东西\n让我们给 String 添加一个方法以返回字符串的倒转字符串：\nvar s = 'Simon'; s.reversed(); VM620:2 Uncaught TypeError: s.reversed is not a function String.prototype.reversed = function () { var r = \"\"; for (var i = this.length - 1; i \u003e= 0; i--) { r += this[i]; } return r; }; s.reversed(); (\"nomiS\"); 我们的新方法甚至在字符串文字上有效！\n\"This can now be reversed.\".reversed(); (\".desrever eb won nac sihT\"); 像之前提到的，原型形成链的一部分\n链根是 Object.prototype，它的方法包括 toString()——是这个方法被调用当你试图呈现一个对象为一个字符串时\n这对于调试我们的 Person 对象很有用\nvar s = new Person(\"Simon\", \"Willison\"); s.toString(); [object, object]; Person.prototype.toString = function () { return \"","wordCount":"2309","inLanguage":"zh","datePublished":"2018-02-01T21:28:22Z","dateModified":"2018-02-01T21:28:22Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/"},"publisher":{"@type":"Organization","name":"Wilson's Blog","logo":{"@type":"ImageObject","url":"https://barnett617.github.io/wilson-blog/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://barnett617.github.io/wilson-blog/ accesskey=h title="Wilson's Blog (Alt + H)"><img src=https://barnett617.github.io/wilson-blog/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Wilson's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://barnett617.github.io/wilson-blog/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://barnett617.github.io/wilson-blog/archives title=时间线><span>时间线</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/tags/ title=标签分类><span>标签分类</span></a></li><li><a href=https://barnett617.github.io/wilson-blog/about/ title=关于我><span>关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">JavaScript知识巩固</h1><div class=post-meta><span title='2018-02-01 21:28:22 +0000 UTC'>2018-02-01 21:28:22</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;2309 字&nbsp;|&nbsp;<a href=https://github.com/barnett617/wilson-blog/tree/main/content//posts/2018-02-01-js-refresh.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#javascript-知识巩固>JavaScript 知识巩固</a><ul><li><a href=#诞生>诞生</a></li><li><a href=#发展历程>发展历程</a></li><li><a href=#应用场景>应用场景</a></li><li><a href=#概述>概述</a></li><li><a href=#javascript-类型>JavaScript 类型</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Refresh your JavaScript Knowledge</p><h2 id=javascript-知识巩固>JavaScript 知识巩固<a hidden class=anchor aria-hidden=true href=#javascript-知识巩固>#</a></h2><h3 id=诞生>诞生<a hidden class=anchor aria-hidden=true href=#诞生>#</a></h3><p>JavaScript 于 1995 年被网景的一名工程师 Brendan Eich 所创造</p><p>第一次发布于 1996 年早期的 Netscape 2</p><p>最初叫 LiveScript</p><p>但由于不幸的营销决策，为了利用 Java 的热度，而改名为 JavaScript（但与 Java 毫无联系）</p><h3 id=发展历程>发展历程<a hidden class=anchor aria-hidden=true href=#发展历程>#</a></h3><p>几个月后，微软在 IE 3 中发布了 JScript</p><p>几个月后，网景向 ECMA（欧洲标准组织）国际组织提交了 JavaScript</p><p>于是在那一年诞生了 ECMAScript 标准的第一个版本</p><p>这个标准在 1999 年收到了一个具有象征意义的更新，定为 ECMAScript 第三版本，从那以后版本趋于稳定</p><p>由于有关语言复杂性的政治分歧，第四个版本被废弃掉</p><p>随后第四版本的许多部分成为了第五个版本的基础，发版于 2009 年 12 月</p><p>第六版发布于 2015 年 6 月</p><h3 id=应用场景>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景>#</a></h3><p>不像大多数语言，JavaScript 没有输入和输出的概念</p><p>它被设计用来在宿主环境作为一种脚本语言运行，并且由宿主环境决定其与外部世界沟通的机制</p><p>最普遍的宿主环境是<strong>浏览器</strong></p><p>但 JavaScript 解释器还能在以下地方找到：</p><ul><li>Adobe Acrobat</li><li>Adobe Photoshop</li><li>SVG images（矢量图）</li><li>Yahoo&rsquo;s Widget engine（雅虎组件引擎）</li><li>服务端环境，例如 Node.js</li><li>非关系型数据库，例如开源的 Apache CouchDB</li><li>嵌入式计算机</li><li>复杂的桌面环境，例如 GNOME（GNU/Linux 操作系统最著名的图形界面系统之一）</li><li>其他</li></ul><h3 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h3><p>JavaScript 是一种多范式、动态语言，拥有类型、操作符、标准内建对象和方法</p><p>它的语法基于 Java 和 C（许多这二者语言的结构都被应用于 JavaScript）</p><p>JavaScript 支持面向对象编程通过使用对象原型（object prototypes）取代类（更多见**原型继承<strong>和 ES2015</strong>类**概念）</p><p>JavaScript 也支持函数式编程——函数是对象，给予函数容纳可执行代码的能力并将像其他对象一样进行传递</p><h3 id=javascript-类型>JavaScript 类型<a hidden class=anchor aria-hidden=true href=#javascript-类型>#</a></h3><ol><li>Number</li><li>String</li><li>Boolean</li><li>Function</li><li>Object</li><li>Symbol（ES2015 新加）</li></ol><p>技术上更严谨的分类如下：</p><ol><li><p>Number</p></li><li><p>String</p></li><li><p>Boolean</p></li><li><p>Symbol（ES2015 新加）</p></li><li><p>Object</p><ul><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Math</li></ul></li><li><p>null</p></li><li><p>undefined</p></li></ol><p>还有一些内建的 Error 类型</p><h4 id=number>Number<a hidden class=anchor aria-hidden=true href=#number>#</a></h4><p>JavaScript 的 Numbers 是 double-precision 64-bit format IEEE 754 values</p><p>由于这个特点，JavaScript 中没有整型，所以在 C 或 Java 中使用到的算数运算要在 JavaScript 中留意</p><p>比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0.1+0.2
</span></span><span class=line><span class=cl>0.30000000000000004
</span></span></code></pre></div><p>实践中，整型值会被当做 32 位整数，并且甚至有些实现以这种方式存储，直到被要求去执行一条在 Number 上有效但在 32 位整型上无效的指令，这对于位运算来说很重要</p><blockquote><p>原文：In practice, integer values are treated as 32-bit ints, and some implementations even store it that way until they are asked to perform an instruction that&rsquo;s valid on a Number but not on a 32-bit integer. This can be important for bit-wise operations.</p></blockquote><p>标准的算数运算符被支持，包括加、减、取模、取余等等</p><p>内建对象 Math 提供了高级数学运算函数和常量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Math.sin(3.5);
</span></span><span class=line><span class=cl>-0.35078322768961984
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>var</span> <span class=n>circumference</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>Math</span><span class=o>.</span><span class=n>PI</span> <span class=o>*</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>circumference</span><span class=p>)</span>
</span></span></code></pre></div><p>使用内建函数 parseInt()可以将一个字符串转换为整型数，但是要注意给该函数指定第二个参数（要转换的进制），如果不填会得到意想不到的结果</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>parseInt(&#39;010&#39;)
</span></span><span class=line><span class=cl>10
</span></span><span class=line><span class=cl>parseInt(&#39;0x10&#39;)
</span></span><span class=line><span class=cl>16
</span></span><span class=line><span class=cl>parseInt(&#39;010&#39;, 8)
</span></span><span class=line><span class=cl>8
</span></span><span class=line><span class=cl>parseInt(&#39;0x10&#39;, 16)
</span></span><span class=line><span class=cl>16
</span></span><span class=line><span class=cl>parseInt(&#39;11&#39;,2)
</span></span><span class=line><span class=cl>3
</span></span></code></pre></div><p>转换为八进制省略第二个参数的方式在 2013 年后被废除，但十六进制忽略第二个参数的用法仍存在，因为可以识别到十六进制前缀<code>0x</code></p><p>还有内建函数 parseFloat 用于将字符串转换为浮点数，但不同于 parseInt()，它总是默认以十进制方式转换</p><p>另外，还可以通过一元运算符<code>+</code>将值转换为数值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>parseFloat(&#39;12.34&#39;)
</span></span><span class=line><span class=cl>12.34
</span></span><span class=line><span class=cl>+ &#39;56.78&#39;;
</span></span><span class=line><span class=cl>56.78
</span></span><span class=line><span class=cl>+ &#39;0x10&#39;
</span></span><span class=line><span class=cl>16
</span></span><span class=line><span class=cl>+ &#39;42&#39;
</span></span><span class=line><span class=cl>42
</span></span></code></pre></div><p>如果字符串是非数值，转换会返回一个特殊值 NaN（Not a Number）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>parseInt(&#39;hello&#39;, 10)
</span></span><span class=line><span class=cl>NaN
</span></span></code></pre></div><p>如果将 NaN 作为输入，做任何算数运算所得都是 NaN</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>parseInt(&#39;hello&#39;, 10) + 5
</span></span><span class=line><span class=cl>NaN
</span></span></code></pre></div><p>可通过内建函数 isNaN()判定是否为 NaN</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>isNaN(parseInt(&#39;hello&#39;, 10) + 5)
</span></span><span class=line><span class=cl>true
</span></span></code></pre></div><p>JavaScript 还提供了特殊值：Infinity 和-Infinity</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1 / 0;
</span></span><span class=line><span class=cl>Infinity
</span></span><span class=line><span class=cl>-1 / 0;
</span></span><span class=line><span class=cl>-Infinity
</span></span></code></pre></div><p>可以使用内建函数 isFinite()判断 Infinity、-Infinity 和 NaN</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>isFinite(1 / 0);
</span></span><span class=line><span class=cl>false
</span></span><span class=line><span class=cl>isFinite(-1 / 0);
</span></span><span class=line><span class=cl>false
</span></span><span class=line><span class=cl>isFinite(NaN);
</span></span><span class=line><span class=cl>false
</span></span></code></pre></div><blockquote><p>parseInt()、parseFloat()和<code>+</code>的区别：前两者会将字符串转换，直到遇到不是有效的数字止，而<code>+</code>会直接将字符串转换为 NaN 如果字符串内包含无效字符</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>parseInt(&#39;10.2abc&#39;);
</span></span><span class=line><span class=cl>10
</span></span><span class=line><span class=cl>+ &#39;10.2abc&#39;
</span></span><span class=line><span class=cl>NaN
</span></span></code></pre></div><h4 id=string>String<a hidden class=anchor aria-hidden=true href=#string>#</a></h4><p>JavaScript 中的字符串是 Unicode 字符序列，这对于处理国家化问题来说很方便，更准确地讲，是 sequences of UTF-16 code units，每一个码单元通过一个 16 位数字呈现，每一个 Unicode 字符通过 1 个或 2 个码单元呈现</p><p>如果想呈现一个单字符，只需要使用一个包含单个字符的字符串</p><p>如果想知道一个（码单元中的）字符串的长度，访问其 length 属性</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#39;hello&#39;.length
</span></span><span class=line><span class=cl>5
</span></span></code></pre></div><p>字符串也可当做对象，并通过方法来操作字符串的信息</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#39;hello&#39;.charAt(0);
</span></span><span class=line><span class=cl>&#34;h&#34;
</span></span><span class=line><span class=cl>&#39;hello, world&#39;.replace(&#39;hello&#39;, &#39;hola&#39;);
</span></span><span class=line><span class=cl>&#34;hola, world&#34;
</span></span><span class=line><span class=cl>&#39;hello&#39;.toUpperCase();
</span></span><span class=line><span class=cl>&#34;HELLO&#34;
</span></span></code></pre></div><h4 id=其他类型>其他类型<a hidden class=anchor aria-hidden=true href=#其他类型>#</a></h4><p>JavaScript 用 null 表示 non-value（并且也仅能通过<code>null</code>访问）</p><p>还有 undefined 表示一个尚未初始化的值（表示一个还未被赋值的变量）</p><p>如果你声明一个变量，但没对其赋值（assign），这个变量的类型就是 undefined，但 undefined 实际上是一个常量</p><p>JavaScript 还有一个布尔类型，只有两个值，true 和 false</p><p>任何值都能被转换成一个布尔值通过以下方式：</p><ol><li><p>false、0、空字符串（""）、NaN、null 和 undefined</p></li><li><p>所以其他都被判定为布尔中的 true</p></li></ol><p>使用 Boolean()函数来具体实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Boolean(&#39;&#39;);
</span></span><span class=line><span class=cl>false
</span></span><span class=line><span class=cl>Boolean(234);
</span></span><span class=line><span class=cl>true
</span></span></code></pre></div><p>这很少情况需要这样处理，当 JavaScript 期望一个布尔值时，会静默执行布尔转换，例如<code>if</code>statement</p><p>布尔操作符，例如&&（逻辑与）、||（逻辑或）和！（逻辑非）都被支持</p><h4 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h4><p>JavaScript 通过三个关键字声明新的变量：let、const 和 var</p><p>let 允许声明块级变量，其声明的变量仅在封闭块中有效</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for (let i = 1; i &lt; 5; i++) {
</span></span><span class=line><span class=cl>  console.log(i);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>console.log(i);
</span></span><span class=line><span class=cl>VM959:2 1
</span></span><span class=line><span class=cl>VM959:2 2
</span></span><span class=line><span class=cl>VM959:2 3
</span></span><span class=line><span class=cl>VM959:2 4
</span></span><span class=line><span class=cl>VM959:4 Uncaught ReferenceError: i is not defined
</span></span><span class=line><span class=cl>    at &lt;anonymous&gt;:4:13
</span></span></code></pre></div><p>const 允许声明永远不会企图改变的变量，并且也仅在所声明的块范围内有效</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>VM1175</span><span class=p>:</span><span class=mi>2</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>VM1175</span><span class=p>:</span><span class=mi>1</span> <span class=n>Uncaught</span> <span class=n>TypeError</span><span class=p>:</span> <span class=n>Assignment</span> <span class=n>to</span> <span class=n>constant</span> <span class=n>variable</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=n>at</span> <span class=o>&lt;</span><span class=n>anonymous</span><span class=o>&gt;</span><span class=p>:</span><span class=mi>1</span><span class=p>:</span><span class=mi>27</span>
</span></span></code></pre></div><p>var 是最通用的声明关键字，它没有 let 和 const 的限制</p><p>它是传统 JavaScript 唯一的声明变量的关键字</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>var</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>7</span><span class=p>;</span> <span class=n>k</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>VM1257</span><span class=p>:</span><span class=mi>2</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>VM1257</span><span class=p>:</span><span class=mi>2</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>VM1257</span><span class=p>:</span><span class=mi>2</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=n>VM1257</span><span class=p>:</span><span class=mi>2</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl><span class=n>VM1257</span><span class=p>:</span><span class=mi>4</span> <span class=mi>7</span>
</span></span></code></pre></div><p>JavaScript 和其他语言（比如 Java）很重要的一个区别是代码块并没有域，只有函数才有域</p><p>所以如果在一个 compound statement（例如在 if 控制结构范围内）内使用 var 声明的变量在整个函数范围内都可见，如上例</p><p>然而，从 ES2015 开始，let 和 const 的声明允许创建块级域变量</p><h4 id=运算符>运算符<a hidden class=anchor aria-hidden=true href=#运算符>#</a></h4><p>JavaScript 数值运算符有<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和<code>%</code></p><p>通过<code>=</code>赋值</p><p>还有一些复合赋值操作，例如<code>+=</code>和<code>-=</code>，这相当于 x = x + y 或 x = x - y</p><p>你可以使用<code>++</code>和<code>--</code>分别表示递增和递减，这些都可以被用作运算符前缀或后缀</p><p><code>+</code>运算符还可用作字符串连接符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#39;hello&#39; + &#39;world&#39;;
</span></span><span class=line><span class=cl>&#34;helloworld&#34;
</span></span></code></pre></div><p>如果你把一个字符串追加于一个数字或其他值，都会首先被转化为一个字符串</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=s2>&#34;3&#34;</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;345&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=mi>3</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>+</span> <span class=s2>&#34;5&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;75&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>为某个值追加一个空字符串是一个将其转换为字符串的方式</p><p>JavaScript 使用<code>&lt;</code>、<code>></code>、<code>&lt;=</code>和<code>>=</code>进行比较操作</p><p>这些既对字符串有效，也对数字有效</p><p>判断两个值相等并不是那么直接，如果给双等运算符<code>==</code>两个不同类型的值，会表现出类型约制</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=mi>123</span> <span class=o>==</span> <span class=s2>&#34;123&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=o>==</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kc>true</span><span class=p>;</span>
</span></span></code></pre></div><p>为避免约制，使用三等运算符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=mi>123</span> <span class=o>===</span> <span class=s2>&#34;123&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=o>===</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kc>false</span><span class=p>;</span>
</span></span></code></pre></div><p>还有!=和!==</p><p>JavaScript 还有**位运算符**</p><h4 id=控制结构>控制结构<a hidden class=anchor aria-hidden=true href=#控制结构>#</a></h4><p>JavaScript 有一套类似 C 语言家族的控制结构</p><p>条件语句通过 if 和 else 支持</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>name</span> <span class=o>==</span> <span class=s2>&#34;test&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span> <span class=o>+=</span> <span class=s2>&#34;test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>name</span> <span class=o>==</span> <span class=s2>&#34;hello&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span> <span class=o>+=</span> <span class=s2>&#34;world&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span> <span class=o>+=</span> <span class=s2>&#34;!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>name</span> <span class=o>==</span> <span class=s2>&#34;helloworld&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kc>true</span><span class=p>;</span>
</span></span></code></pre></div><p>JavaScript 拥有 while 循环和 do-while 循环，前者用于基本循环，后者用于你想确保循环至少执行一次</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// an infinite loop!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>input</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>input</span> <span class=o>=</span> <span class=nx>get_input</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nx>inputIsNotValid</span><span class=p>(</span><span class=nx>input</span><span class=p>));</span>
</span></span></code></pre></div><p>JavaScript 的 for 循环和 C 还有 Java 的一样，使你能够在一行内提供控制信息</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Will execute 5 times
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>JavaScript 还有两个高级 for 循环</p><ul><li>for of</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>value</span> <span class=k>of</span> <span class=nx>array</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// do something with value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>for in</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>property</span> <span class=k>in</span> <span class=nx>object</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// do something with object property
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>&&和||运算符有短路逻辑，意味着第二个运算值的是否执行决定于第一个运算值</p><p>这有助于检查空对象在访问其属性之前</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>o</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>name</span> <span class=o>=</span> <span class=nx>o</span> <span class=o>&amp;&amp;</span> <span class=nx>o</span><span class=p>.</span><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kc>null</span><span class=p>;</span>
</span></span></code></pre></div><p>或进行缓存值（当假值无效时）??</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=n>name</span> <span class=o>=</span> <span class=n>cachedName</span> <span class=o>||</span> <span class=p>(</span><span class=n>cachedName</span> <span class=o>=</span> <span class=n>getName</span><span class=p>());</span>
</span></span></code></pre></div><p>JavaScript 对条件语句拥有一个三元运算符</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>age</span> <span class=o>=</span> <span class=mi>19</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>allowed</span> <span class=o>=</span> <span class=p>(</span><span class=nx>age</span> <span class=o>&gt;</span> <span class=mi>18</span><span class=p>)</span> <span class=o>?</span> <span class=s1>&#39;yes&#39;</span> <span class=o>:</span> <span class=s1>&#39;no&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>allowed</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>VM1682</span><span class=o>:</span><span class=mi>3</span> <span class=nx>yes</span>
</span></span></code></pre></div><p><code>switch</code>语句可被用于基于一个数字或字符串的多分支判断</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=nx>action</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=s2>&#34;draw&#34;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>drawIt</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=s2>&#34;eat&#34;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>eatIt</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>doNothing</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果你没有添加 break 语句，将会在该条件下的内容执行后继续向下执行，这可能并不是你想要的，如果你的确想这么做用于调试，请添加注释表明</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=nx>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=c1>// fallthrough
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>eatIt</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>doNothing</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>默认条款是可选的，你在 switch 部分和 case 部分都可以有<strong>表达式</strong>，比较会在二者使用了===运算符时发生</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;execute 4&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=nx>neverhappens</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>VM1831</span><span class=o>:</span><span class=mi>3</span> <span class=nx>execute</span> <span class=mi>4</span>
</span></span></code></pre></div><h4 id=对象>对象<a hidden class=anchor aria-hidden=true href=#对象>#</a></h4><p>JavaScript 的对象可以理解为一个键值对集合，类似于：</p><ul><li><p>Python 中的字典</p></li><li><p>Perl 和 Ruby 中的 Hashes</p></li><li><p>C 和 C++中的哈希表</p></li><li><p>Java 中的 HashMap</p></li><li><p>PHP 中的关联数组</p></li></ul><p>事实上这个数据结构被如此广泛的使用，是其多才多艺的一个佐证</p><p>因为 JavaScript 中的一切都是对象</p><p>任何 JavaScript 程序自然包含着一个强大的哈希表查找，这是个好事，因为很快</p><p>JavaScript 对象的“键”部分是一个字符串，“值”部分可以是任何值</p><p>这允许你可以构造任意复杂的数据结构</p><p>有两种基本的创建对象的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Object</span><span class=p>();</span>
</span></span></code></pre></div><p>和</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{};</span>
</span></span></code></pre></div><p>这二者语义上相等，后者称为 object literal syntax，并且更方便</p><p>这种语法也是 JSON 格式的核心并总被偏爱</p><p>文字对象语法可以用来完整初始化一个对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;test&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>_for</span><span class=o>:</span> <span class=s1>&#39;max&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>details</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>color</span><span class=o>:</span> <span class=s1>&#39;orange&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>size</span><span class=o>:</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;test&#34;</span><span class=p>,</span> <span class=nx>_for</span><span class=o>:</span> <span class=s2>&#34;max&#34;</span><span class=p>,</span> <span class=nx>details</span><span class=o>:</span> <span class=p>{</span><span class=err>…</span><span class=p>}}</span>
</span></span></code></pre></div><p>属性可被链接到一起</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>details</span><span class=p>.</span><span class=nx>color</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;orange&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>[</span><span class=s2>&#34;details&#34;</span><span class=p>][</span><span class=s2>&#34;color&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;orange&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>下面的例子创建了一个对象原型 Person 和一个原型实例 You</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>you</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s1>&#39;You&#39;</span><span class=p>,</span> <span class=mi>24</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>you</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>VM2069</span><span class=o>:</span><span class=mi>7</span> <span class=nx>Person</span> <span class=p>{</span><span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;You&#34;</span><span class=p>,</span> <span class=nx>age</span><span class=o>:</span> <span class=mi>24</span><span class=p>}</span>
</span></span></code></pre></div><p>一经创建，一个对象的属性可被再次访问用以下两种方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;magi&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>name</span> <span class=o>=</span> <span class=nx>obj</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;magi&#34;</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>obj</span><span class=p>[</span><span class=s2>&#34;name&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;igma&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>name</span> <span class=o>=</span> <span class=nx>obj</span><span class=p>[</span><span class=s2>&#34;name&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;igma&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>user</span> <span class=o>=</span> <span class=nx>prompt</span><span class=p>(</span><span class=s2>&#34;what is your key?&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>[</span><span class=nx>user</span><span class=p>]</span> <span class=o>=</span> <span class=nx>prompt</span><span class=p>(</span><span class=s2>&#34;what is your value?&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;111&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>这些也语义上相等，后者优势在于 name 属性作为一个字符串被提供，意味着可以在运行时被计算</p><p>然而，使用这种方式可以防止了有些 JavaScript 引擎和优化器被应用</p><p>另外，也因此可以使用关键字来设置和获得属性</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=k>for</span> <span class=o>=</span> <span class=s2>&#34;Simon&#34;</span><span class=p>;</span> <span class=c1>// Syntax error, because &#39;for&#39; is a reserved word
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>obj</span><span class=p>[</span><span class=s2>&#34;for&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;Simon&#34;</span><span class=p>;</span> <span class=c1>// works fine
</span></span></span></code></pre></div><blockquote><p>从 ECMAScript 5 开始，保留字可以用作对象属性名 in the buff。这意味着定义对象时不再需要引号来包裹，详情见the ES5 Spec</p></blockquote><p>更多关于对象和原型，见Object.prototype</p><p>关于对象原型和对象原型链，见继承和原型链</p><p>从 ECMAScript2015 开始，对象的键可以被使用括号符的变量定义</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>userPhone</span> <span class=o>=</span> <span class=p>{[</span><span class=s1>&#39;phoneType&#39;</span><span class=p>]</span><span class=o>:</span> <span class=mi>12345</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>userPhone</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>VM2470</span><span class=o>:</span><span class=mi>2</span> <span class=p>{</span><span class=nx>phoneType</span><span class=o>:</span> <span class=mi>12345</span><span class=p>}</span>
</span></span></code></pre></div><p>可以代替</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>userPhone</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=nx>userPhone</span><span class=p>[</span><span class=s1>&#39;phoneType&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>12345</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>userPhone</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>VM2505</span><span class=o>:</span><span class=mi>3</span> <span class=p>{</span><span class=nx>phoneType</span><span class=o>:</span> <span class=mi>12345</span><span class=p>}</span>
</span></span></code></pre></div><h4 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h4><p>JavaScript 中的数组其实一种特殊类型的对象</p><p>和常规的对象非常像（数值属性只能使用[]语法访问）</p><p>但有一个神奇的属性叫做“length”</p><p>其总是比数组最大索引值多一位</p><p>创建数组的方式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Array</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;dog&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;cat&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;hen&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=mi>3</span><span class=p>;</span>
</span></span></code></pre></div><p>一个更方便的表示方式是使用数组文字（array literal）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;dog&#34;</span><span class=p>,</span> <span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;hen&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=mi>3</span><span class=p>;</span>
</span></span></code></pre></div><p>注意 array.length 不必是数组项目的个数，考虑下面一种情况</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;dog&#34;</span><span class=p>,</span> <span class=s2>&#34;cat&#34;</span><span class=p>,</span> <span class=s2>&#34;hen&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;fox&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=mi>101</span><span class=p>;</span>
</span></span></code></pre></div><p>谨记：数组的长度总比数组索引最大值大一位</p><p>如果访问一个不存在的数组索引，会得到一个值为 undefined 的返回值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>typeof</span> <span class=nx>a</span><span class=p>[</span><span class=mi>90</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;undefined&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>如果把上面的[]和 length 纳入考虑，你可以使用 for 循环迭代一个数组</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>a</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>VM302</span><span class=o>:</span><span class=mi>2</span> <span class=nx>dog</span>
</span></span><span class=line><span class=cl><span class=nx>VM302</span><span class=o>:</span><span class=mi>2</span> <span class=nx>cat</span>
</span></span><span class=line><span class=cl><span class=nx>VM302</span><span class=o>:</span><span class=mi>2</span> <span class=nx>hen</span>
</span></span><span class=line><span class=cl><span class=mi>97</span><span class=nx>VM302</span><span class=o>:</span><span class=mi>2</span> <span class=kc>undefined</span>
</span></span><span class=line><span class=cl><span class=nx>VM302</span><span class=o>:</span><span class=mi>2</span> <span class=nx>fox</span>
</span></span></code></pre></div><p>ECMAScript 介绍了一种更加简明的循环 for of，用来迭代对象，比如数组：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kr>const</span> <span class=nx>currentValue</span> <span class=k>of</span> <span class=nx>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>currentValue</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>VM394</span><span class=o>:</span><span class=mi>2</span> <span class=nx>dog</span>
</span></span><span class=line><span class=cl><span class=nx>VM394</span><span class=o>:</span><span class=mi>2</span> <span class=nx>cat</span>
</span></span><span class=line><span class=cl><span class=nx>VM394</span><span class=o>:</span><span class=mi>2</span> <span class=nx>hen</span>
</span></span><span class=line><span class=cl><span class=mi>97</span><span class=nx>VM394</span><span class=o>:</span><span class=mi>2</span> <span class=kc>undefined</span>
</span></span><span class=line><span class=cl><span class=nx>VM394</span><span class=o>:</span><span class=mi>2</span> <span class=nx>fox</span>
</span></span></code></pre></div><p>你也可以使用 for in 循环来迭代一个数组，但如果有人向 Array.prototype 添加了新的属性，它（新加的属性）在本次循环也会被迭代。所以这种循环类型不被推荐用于数组迭代</p><p>另一种在 ECMAScript5 中添加的用来迭代数组的方式是 forEach()</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;dog&#39;</span><span class=p>,</span> <span class=s1>&#39;cat&#39;</span><span class=p>,</span> <span class=s1>&#39;hen&#39;</span><span class=p>].</span><span class=nx>forEach</span><span class=p>(</span><span class=kd>function</span><span class=p>(</span><span class=nx>currentValue</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>array</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;currentIndex: &#39;</span> <span class=o>+</span> <span class=nx>index</span> <span class=o>+</span> <span class=s1>&#39; currentValue: &#39;</span> <span class=o>+</span> <span class=nx>currentValue</span> <span class=o>+</span> <span class=s1>&#39; array: &#39;</span> <span class=o>+</span> <span class=nx>array</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=nx>VM486</span><span class=o>:</span><span class=mi>2</span> <span class=nx>currentIndex</span><span class=o>:</span> <span class=mi>0</span> <span class=nx>currentValue</span><span class=o>:</span> <span class=nx>dog</span> <span class=nx>array</span><span class=o>:</span> <span class=nx>dog</span><span class=p>,</span><span class=nx>cat</span><span class=p>,</span><span class=nx>hen</span>
</span></span><span class=line><span class=cl><span class=nx>VM486</span><span class=o>:</span><span class=mi>2</span> <span class=nx>currentIndex</span><span class=o>:</span> <span class=mi>1</span> <span class=nx>currentValue</span><span class=o>:</span> <span class=nx>cat</span> <span class=nx>array</span><span class=o>:</span> <span class=nx>dog</span><span class=p>,</span><span class=nx>cat</span><span class=p>,</span><span class=nx>hen</span>
</span></span><span class=line><span class=cl><span class=nx>VM486</span><span class=o>:</span><span class=mi>2</span> <span class=nx>currentIndex</span><span class=o>:</span> <span class=mi>2</span> <span class=nx>currentValue</span><span class=o>:</span> <span class=nx>hen</span> <span class=nx>array</span><span class=o>:</span> <span class=nx>dog</span><span class=p>,</span><span class=nx>cat</span><span class=p>,</span><span class=nx>hen</span>
</span></span></code></pre></div><p>如果想要为一个数组追加元素，只需要简单地：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>item</span><span class=p>);</span>
</span></span></code></pre></div><p>数组方法列表如下：</p><table><thead><tr><th>Method name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>a.toString</td><td>返回数组的每一个元素以逗号分隔的字符串</td><td>dog,cat,hen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,fox</td></tr><tr><td>a.toLocaleString()</td><td>同 toString，不过先判断指定语言环境，没指定则使用默认语言环境，主要用于 Date 类型</td><td>-</td></tr><tr><td>a.concat(item1[, item2[, &mldr;[,itemN]]])</td><td>返回一个追加于其后的一个新的数组</td><td>a.concat(&lsquo;panda&rsquo;,&lsquo;seal&rsquo;)-> [empty × 97, &ldquo;hen&rdquo;, &ldquo;cat&rdquo;, &ldquo;dog&rdquo;, &ldquo;panda&rdquo;, &ldquo;seal&rdquo;]</td></tr><tr><td>a.join(sep)</td><td>转换数组为一个字符串，伴随着以 sep 参数分隔的值</td><td>dog-cat-hen&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;fox</td></tr><tr><td>a.pop</td><td>移除并返回最后一项</td><td>&ldquo;fox&rdquo;</td></tr><tr><td>a.push(item1, &mldr;, itemN)</td><td>向数组末端追加元素，并返回追加后的数组长度</td><td>101</td></tr><tr><td>a.reverse()</td><td>倒置数组</td><td>(101) [&ldquo;fox&rdquo;, empty × 97, &ldquo;hen&rdquo;, &ldquo;cat&rdquo;, &ldquo;dog&rdquo;]</td></tr><tr><td>a.shift</td><td>移除并返回第一个元素</td><td>&ldquo;fox&rdquo;</td></tr><tr><td>a.slice(start[, end])</td><td>返回子数组</td><td>a.slice(98,100) -> [&ldquo;cat&rdquo;, &ldquo;dog&rdquo;]</td></tr><tr><td>a.sort([cmpfn])</td><td>采用可选比较函数进行排序</td><td>a.sort()->[&ldquo;cat&rdquo;, &ldquo;dog&rdquo;, &ldquo;hen&rdquo;, empty × 97]</td></tr><tr><td>a.splice(start, delcount[, item1[, &mldr;[, itemN]]])</td><td>让你修改一个数组，通过删除一部分并使用更多条目替换之</td><td>a.splice(0, 2, &lsquo;another cat&rsquo;, &lsquo;another dog&rsquo;)->[&ldquo;cat&rdquo;, &ldquo;dog&rdquo;]->a->[&ldquo;another cat&rdquo;, &ldquo;another dog&rdquo;, &ldquo;hen&rdquo;, empty × 97]</td></tr><tr><td>a.unshift(item1[, item2[, &mldr;[, itemN]]])</td><td>预先考虑数组开头的条目</td><td>a.unshift(&lsquo;prepand item1&rsquo;, &lsquo;prepand item2&rsquo;)->102->a->[&ldquo;prepand item1&rdquo;, &ldquo;prepand item2&rdquo;, &ldquo;another cat&rdquo;, &ldquo;another dog&rdquo;, &ldquo;hen&rdquo;, empty × 97]</td></tr></tbody></table><p>更多详见array methods & toLocaleString</p><h4 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h4><p>同对象一起，函数也是理解 JavaScript 的核心组件</p><p>最基本的函数不能再简单</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>total</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>tatal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这演示了一个基本的函数</p><p>一个 JavaScript 函数可以有 0 个或更多的命名参数</p><p>函数体可以包含任意多你想要的语句并且可以声明它对于它本身，自己的变量</p><p>return 语句可以被用来在任何时候返回一个值，中断函数</p><p>如果没有返回语句（或者一个空的 return 而不包含任何值），JavaScript 会返回 undefined</p><p>命名参数比起其他任何事物更像是指导方针，只要你想，你可以调用一个函数而不用传递任何参数，这种情况它会传递 undefined 作为参数</p><p>所以直接运行上面定义的函数，会报错，因为你给函数传递了参数 undefined</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>total</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kc>NaN</span>
</span></span></code></pre></div><p>你也可以传递函数期望的更多参数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>total</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=mi>5</span>
</span></span></code></pre></div><p>参数“4”会被忽略</p><p>这可能会看起来有点蠢，但函数会访问其函数体内部的附加名为 arguments 的变量，它是一个类数组对象，承载了所有传递给函数的参数</p><p>让我们重写这个 add 函数来取到和我们想要的参数一样多的参数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>j</span> <span class=o>=</span> <span class=nx>arguments</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>j</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>arguments</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=mi>14</span>
</span></span></code></pre></div><p>再写一个平均值函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>avg</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>j</span> <span class=o>=</span> <span class=nx>arguments</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>j</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>arguments</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span> <span class=o>/</span> <span class=nx>arguments</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>avg</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=mf>3.5</span>
</span></span></code></pre></div><p>这非常有用，但有一点啰嗦。要再减少一点这份代码，我们可以考虑参数数组作取代，通过Rest parameter syntax</p><p>用这种方式，我们可以保持代码最小化的同时传递任意数量的参数给函数</p><p>rest 参数运算符用于函数参数列表使用"&mldr;variable"格式，它会包含进调用函数时整个未捕获参数列表</p><p>我们也可以使用 for&mldr;of 循环取代 for 循环来返回变量中的值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>avg</span><span class=p>(...</span><span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>value</span> <span class=k>of</span> <span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span> <span class=o>/</span> <span class=nx>args</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>avg</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=mf>3.5</span><span class=p>;</span>
</span></span></code></pre></div><p>在上述的代码中，args 变量拥有我们传递进函数的所有函数</p><p>很重要需要注意无论何时 rest 参数运算符被放置在一个函数声明，它都会在它声明后存储所有的参数，但不会在声明之前（存储参数），例如：function avg(firstValue, &mldr;args)将存储被传递进函数的第一个值
在 firstValue 中，剩余参数存储在 args 中。另一个有用的函数但也的确给我们带来一个新问题。avg()函数接收一个逗号分隔的参数列表——但是要是你想要得到一个<strong>数组</strong>的平均值？你只能重写这个函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>avgArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>j</span> <span class=o>=</span> <span class=nx>arr</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>j</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span> <span class=o>/</span> <span class=nx>arr</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>avgArray</span><span class=p>([</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=mf>3.5</span><span class=p>;</span>
</span></span></code></pre></div><p>但使得这个我们创建的函数可被重用会更好。</p><p>幸运的是，JavaScript 可以让你使用一个任意的参数数组来调用一个函数，通过使用任何函数对象的 apply()方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>avg</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=mf>3.5</span><span class=p>;</span>
</span></span></code></pre></div><p>apply()的第二个参数是用作参数的数组；第一个参数后面再讨论，这强调了一个事实——函数也是对象</p><blockquote><p>你可以在函数调用中使用 spread 操作符达到相同的结果，例如 avg(&mldr;numbers)</p></blockquote><p>JavaScript 让你可以创建匿名函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>arg</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>j</span> <span class=o>=</span> <span class=nx>arguments</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>j</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>arguments</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span> <span class=o>/</span> <span class=nx>arguments</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这在语义上等同于 function avg()形式</p><p>这非常强大，因为它可以让你把一个函数定义放在任何你通常放置表达式的地方</p><p>这使得所有种类的聪明的诀窍</p><p>这是一种“隐藏”一些本地变量的方式——像 C 语言中的块级域</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>+=</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>})();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>VM2347</span><span class=o>:</span><span class=mi>9</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=nx>VM2347</span><span class=o>:</span><span class=mi>10</span> <span class=mi>2</span>
</span></span></code></pre></div><p>JavaScript 允许你递归调用函数。</p><p>这对于处理树结构尤其有用，比如那些浏览器中的 DOM</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>countChars</span><span class=p>(</span><span class=nx>elm</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>elm</span><span class=p>.</span><span class=nx>nodeType</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TEXT_NODE
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>elm</span><span class=p>.</span><span class=nx>nodeValue</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>child</span><span class=p>;</span> <span class=p>(</span><span class=nx>child</span> <span class=o>=</span> <span class=nx>elm</span><span class=p>.</span><span class=nx>childNodes</span><span class=p>[</span><span class=nx>i</span><span class=p>]);</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span> <span class=o>+=</span> <span class=nx>countChars</span><span class=p>(</span><span class=nx>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这强调了匿名函数的一个潜在问题：如果它没有名字，你怎么递归地调用它？</p><p>JavaScript 对于此让你可以给函数表达式命名</p><p>你可以使用命名了的 IIFEs（Immediately Invoked Function Expression）如下面所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>charsInBody</span> <span class=o>=</span> <span class=p>(</span><span class=kd>function</span> <span class=nx>counter</span><span class=p>(</span><span class=nx>elm</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>elm</span><span class=p>.</span><span class=nx>nodeType</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// TEXT_NODE
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>elm</span><span class=p>.</span><span class=nx>nodeValue</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>child</span><span class=p>;</span> <span class=nx>child</span> <span class=o>=</span> <span class=nx>elm</span><span class=p>.</span><span class=nx>childNodes</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span> <span class=o>+=</span> <span class=nx>counter</span><span class=p>(</span><span class=nx>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>})(</span><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kc>undefined</span>
</span></span><span class=line><span class=cl><span class=nx>charsInBody</span>
</span></span><span class=line><span class=cl><span class=mi>58670</span>
</span></span></code></pre></div><p>如上提供给一个函数表达式的名字仅对这个函数自己的域内可用</p><p>这允许更多的引擎优化并给出更多的可读代码</p><p>这个名称也出现在调试器和一些堆栈信息中，这会让你在调试时节省更多时间</p><p>注意 JavaScript 函数本身就是对象——像 JavaScript 中其他的一切一样——并且你可以添加或改变他们的属性，就像我们在对象部分所见过的</p><h4 id=自定义对象>自定义对象<a hidden class=anchor aria-hidden=true href=#自定义对象>#</a></h4><p>更多 JavaScript 面向对象编程见Object-Oriented JavaScript</p><p>在传统的面向对象语言编程中，对象是运算在数据上的数据和方法的集合</p><p>JavaScript 是基于原型的语言，没有像是在 C++或 Java 中的类语句（这有时会使得习惯于使用类语句的语言的编程者感到困惑）</p><p>取而代之，JavaScript 使用函数作为类</p><p>让我们考虑一个有名有姓的人作为对象</p><p>姓名可能会以两种方式展示：如“名 姓”或“姓 名”</p><p>使用我们前面讨论的函数和对象，我们就能展示数据如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>makePerson</span><span class=p>(</span><span class=nx>first</span><span class=p>,</span> <span class=nx>last</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>first</span><span class=o>:</span> <span class=nx>first</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>last</span><span class=o>:</span> <span class=nx>last</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>personFullName</span><span class=p>(</span><span class=nx>person</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>person</span><span class=p>.</span><span class=nx>first</span> <span class=o>+</span> <span class=s1>&#39; &#39;</span> <span class=o>+</span> <span class=nx>person</span><span class=p>.</span><span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>personFullNameReversed</span><span class=p>(</span><span class=nx>person</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>person</span><span class=p>.</span><span class=nx>last</span> <span class=o>+</span> <span class=s1>&#39;, &#39;</span> <span class=o>+</span> <span class=nx>person</span><span class=p>.</span><span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=o>=</span> <span class=nx>makePerson</span><span class=p>(</span><span class=s1>&#39;Simon&#39;</span><span class=p>,</span> <span class=s1>&#39;Willison&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>personFullName</span><span class=p>(</span><span class=nx>s</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>personFullNameReversed</span><span class=p>(</span><span class=nx>s</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>VM1137</span><span class=o>:</span><span class=mi>15</span> <span class=nx>Simon</span> <span class=nx>Willison</span>
</span></span><span class=line><span class=cl><span class=nx>VM1137</span><span class=o>:</span><span class=mi>16</span> <span class=nx>Willison</span><span class=p>,</span> <span class=nx>Simon</span>
</span></span></code></pre></div><p>这有效，但很丑</p><p>这样最后你会在全局域有很多函数</p><p>我们真正需要的是一种把一个函数依附于一个对象的方式</p><p>因为函数也是对象，所以这很容易：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>makePerson</span><span class=p>(</span><span class=nx>first</span><span class=p>,</span> <span class=nx>last</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>first</span><span class=o>:</span> <span class=nx>first</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>last</span><span class=o>:</span> <span class=nx>last</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>fullName</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>+</span> <span class=s1>&#39; &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>fullNameReversed</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>+</span> <span class=s1>&#39;, &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=o>=</span> <span class=nx>makePerson</span><span class=p>(</span><span class=s1>&#39;Simon&#39;</span><span class=p>,</span> <span class=s1>&#39;Willison&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>fullName</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>fullNameReversed</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=nx>VM1572</span><span class=o>:</span><span class=mi>15</span> <span class=nx>Simon</span> <span class=nx>Willison</span>
</span></span><span class=line><span class=cl><span class=nx>VM1572</span><span class=o>:</span><span class=mi>16</span> <span class=nx>Willison</span><span class=p>,</span> <span class=nx>Simon</span>
</span></span></code></pre></div><p>这里有一些我们前面没见过的东西：this 关键字</p><p>使用内部函数，this 指向当前对象</p><p>这实际上意味着你调用函数的方式来指定</p><p>如果你使用一个对象上的点符或括号符来调用，那么那个对象就是 this</p><p>如果调用没用点符，this 指向全局对象</p><p>注意 this 是一个频繁导致错误的东西，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>s</span> <span class=o>=</span> <span class=nx>makePerson</span><span class=p>(</span><span class=s2>&#34;Simon&#34;</span><span class=p>,</span> <span class=s2>&#34;Willison&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>fullName</span> <span class=o>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>fullName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>fullName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;undefined undefined&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>当我们单独调用 fullName()，而不用 s.fullName()，this 被绑定在全局对象</p><p>因为没有全局变量叫 first 或者 last，所以我们对于二者都得到了 undefined</p><p>我们可以利用 this 关键字来提高我们的 makePerson 函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>first</span><span class=p>,</span> <span class=nx>last</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>=</span> <span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>=</span> <span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>fullName</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>fullNameReversed</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;Simon&#34;</span><span class=p>,</span> <span class=s2>&#34;Willison&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>我们介绍了另一个关键字 new</p><p>new 和 this 强度关联</p><p>它创造一个新的空对象，然后调用指定的函数，并使用 this 设置给那个新建的对象</p><p>注意通过 this 指定的那个函数不返回一个值，但很少修改 this 对象</p><p>是 new 返回了 this 对象到调用的地方</p><p>被设计为通过 new 调用的函数称为构造函数</p><p>常见的做法是利用这些函数作为一个使用 new 调用它们的提醒</p><p>提高后的函数仍有和单独调用 fullName 相同的陷阱</p><p>我们的 person 对象变得更好了，但对于它们仍有一些丑陋边缘</p><p>每次我们创建一个 person 对象，我们都创建了其内的两个崭新的函数对象——如果这代码被分享不会变得更好吗？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>personFullName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>personFullNameReversed</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>+</span> <span class=s2>&#34;, &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>first</span><span class=p>,</span> <span class=nx>last</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>=</span> <span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>=</span> <span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>fullName</span> <span class=o>=</span> <span class=nx>personFullName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>fullNameReversed</span> <span class=o>=</span> <span class=nx>personFullNameReversed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这变得更好了，我们只创建了函数一次，并且在构造器里给它们的引用赋值</p><p>我们能做的更好吗？答案是可以：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>first</span><span class=p>,</span> <span class=nx>last</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>=</span> <span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>=</span> <span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>fullName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span> <span class=o>+</span> <span class=s1>&#39; &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>fullNameReversed</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>+</span> <span class=s1>&#39;, &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>ƒ</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span> <span class=o>+</span> <span class=s1>&#39;, &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Person.prototype 是一个分享自 Person 所有实例的对象</p><p>它形成一个查找链的一部分（有一个特殊的名字，原型链）：当任何时候你尝试去访问 Person 的一个属性时，JavaScript 会检查 Person.prototype 去看是否那个属性存在。</p><p>然后任何赋值给 Person.prototype 的东西对于构造器的所有实例经 this 对象变得可用</p><p>这是一个令人难以置信的强大工具</p><p>JavaScript 让你可以修改某个东西的原型在任何时候，在你的程序里，意味着你可以在运行时对已存在的对象添加额外的方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>s</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s1>&#39;Simon&#39;</span><span class=p>,</span> <span class=s1>&#39;Willison&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>firstNameCaps</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=nx>VM587</span><span class=o>:</span><span class=mi>2</span> <span class=nx>Uncaught</span> <span class=nx>TypeError</span><span class=o>:</span> <span class=nx>s</span><span class=p>.</span><span class=nx>firstNameCaps</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>a</span> <span class=kd>function</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>firstNameCaps</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>first</span><span class=p>.</span><span class=nx>toUpperCase</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>firstNameCaps</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=nx>VM588</span><span class=o>:</span><span class=mi>4</span> <span class=nx>SIMON</span>
</span></span></code></pre></div><p>有趣的是，你也可以向 JavaScript 内建对象添加东西</p><p>让我们给 String 添加一个方法以返回字符串的倒转字符串：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=o>=</span> <span class=s1>&#39;Simon&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nx>reversed</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>VM620</span><span class=o>:</span><span class=mi>2</span> <span class=nx>Uncaught</span> <span class=nx>TypeError</span><span class=o>:</span> <span class=nx>s</span><span class=p>.</span><span class=nx>reversed</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>a</span> <span class=kd>function</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nb>String</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>reversed</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>r</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>r</span> <span class=o>+=</span> <span class=k>this</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nx>reversed</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;nomiS&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>我们的新方法甚至在字符串文字上有效！</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=s2>&#34;This can now be reversed.&#34;</span><span class=p>.</span><span class=nx>reversed</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;.desrever eb won nac sihT&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>像之前提到的，原型形成链的一部分</p><p>链根是 Object.prototype，它的方法包括 toString()——是这个方法被调用当你试图呈现一个对象为一个字符串时</p><p>这对于调试我们的 Person 对象很有用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;Simon&#34;</span><span class=p>,</span> <span class=s2>&#34;Willison&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nx>toString</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nx>object</span><span class=p>,</span> <span class=nx>object</span><span class=p>];</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s2>&#34;&lt;Person: &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>fullName</span><span class=p>()</span> <span class=o>+</span> <span class=s2>&#34;&gt;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nx>toString</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;&lt;Person: Simon Willison&gt;&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>记得 avg.apply 是如何获得一个 null 作为第一个参数的吗？</p><p>我们可以现在回看</p><p>apply()的第一个参数是应该被视为 this 的对象</p><p>例如：这里有一个粗糙的 new 实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>trivialNew</span><span class=p>(</span><span class=nx>constructor</span><span class=p>,</span> <span class=p>...</span><span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>o</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=nx>o</span><span class=p>,</span> <span class=nx>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>o</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这不是一个准确的 new 的复制品，因为没有建立原型链（很难说明这一点）</p><p>这不是你经常使用的东西，但知道这很有用</p><p>在这个片段，&mldr;args（包括省略号）被称为 rest 参数——正如其名暗示，这包含了参数余下的部分</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JavaScript data-lang=JavaScript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>bill</span> <span class=o>=</span> <span class=nx>trivialNew</span><span class=p>(</span><span class=nx>Person</span><span class=p>,</span> <span class=s1>&#39;William&#39;</span><span class=p>,</span> <span class=s1>&#39;Orange&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kc>undefined</span>
</span></span><span class=line><span class=cl><span class=nx>bill</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=nx>first</span><span class=o>:</span> <span class=s2>&#34;William&#34;</span><span class=p>,</span> <span class=nx>last</span><span class=o>:</span> <span class=s2>&#34;Orange&#34;</span><span class=p>}</span>
</span></span></code></pre></div><p>所以这几乎等同于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>bill</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;William&#34;</span><span class=p>,</span> <span class=s2>&#34;Orange&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>apply()有一个姐妹叫做 call，再一次让你设置 this，但用一个不同于数组的拓展参数列表</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>lastNameCaps</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>last</span><span class=p>.</span><span class=nx>toUpperCase</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;Simon&#34;</span><span class=p>,</span> <span class=s2>&#34;Willison&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>lastNameCaps</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;WILLISON&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>这等同于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nx>lastNameCaps</span> <span class=o>=</span> <span class=nx>lastNameCaps</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nx>lastNameCaps</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=s2>&#34;WILLISON&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>内部函数：</p><p>JavaScript 函数声明允许在其他函数内部</p><p>我们之前见过一次，一个更早版本的 makePerson()函数</p><p>JavaScript 的嵌套函数的一个重要细节是他们可以访问它们父函数域的变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>parentFunc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>nestedFunc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>nestedFunc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这为写可维护代码提供了一个强大的处理工具</p><p>如果一个函数依赖一个或两个对你代码其他部分没有用的其他函数，你可以嵌套那些工具函数在函数内部，以被其他任何地方调用</p><p>这保持了全局域范围内的函数数量，总会是件好事</p><p>这也是一个强大的全局变量诱饵的计数器（原文：This is also a great counter to the lure of global variables.）</p><p>当写复杂代码时，经常尝试使用全局变量去在多个函数间分享——导致难以维护的代码</p><p>嵌套函数可以在它们的父内分享，所以你可以将那种机制用于对函数，当不污染你的全局命名空间讲得通时——“本地全局变量”</p><p>这个技术应当被小心使用，但它的确是一个有用能力</p><h4 id=闭包>闭包<a hidden class=anchor aria-hidden=true href=#闭包>#</a></h4><p>这带领我们走向 JavaScript 提供的最强大的抽象——但也是最潜在令人迷惑的</p><p>这是什么呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>makeAdder</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>function</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>x</span> <span class=o>=</span> <span class=nx>makeAdder</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>y</span> <span class=o>=</span> <span class=nx>makeAdder</span><span class=p>(</span><span class=mi>20</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>(</span><span class=mi>6</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>y</span><span class=p>(</span><span class=mi>7</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>VM1955</span><span class=o>:</span><span class=mi>8</span> <span class=mi>11</span>
</span></span><span class=line><span class=cl><span class=nx>VM1955</span><span class=o>:</span><span class=mi>9</span> <span class=mi>27</span>
</span></span></code></pre></div><p>makeAdder 函数的名字应该放弃：它创造新的 adder 函数，每一个伴随着一个参数调用的函数，都将其添加到创建它的参数（原文：it creates new &lsquo;adder&rsquo; functions, each of which, when called with one argument, adds it to the argument that it was created with.）</p><p>这里发生的事和内部函数非常相同：一个定义在另一个函数内部的函数访问了外部函数的变量</p><p>这里唯一不同的是外部函数有返回值，因此常识似乎指明它的局部变量不再存在</p><p>但它们仍存在——否则 adder 函数将无法工作</p><p>更重要的是，有 makeAdder()本地变量的两份不同的“拷贝”——一个在 a 中是 5，另一个 a 是 20</p><p>所以函数调用的结果是 11 和 27</p><p>这是真实正在发生的</p><p>无论何时 JavaScript 执行一个函数，“域”对象被创建来承载那个函数内部创建的本地变量</p><p>任何被传递进函数作为函数参数的变量将其初始化</p><p>这和承载全局变量和函数的全局对象类似，但一组不同的地方是：首先，一个崭新的域对象每次函数开始执行时被创建，其次，不像全局对象（类似通过 this 访问或浏览器中的 window），这些域对象在你的 JavaScript 代码中不能直接被访问到，比如没有机制被用来迭代当前域对象属性</p><p>所以当 makeAdder()被调用，一个域对象被创建，伴随一个属性 a，也就是被传给 makeAdder()的参数</p><p>makeAdder()然后返回一个新创建的函数</p><p>通常 JavaScript 的垃圾回收器会在这个点清除掉 makeAdder()创建的域对象，但返回的函数维护了一个引用到域对象</p><p>结果，域对象不会被垃圾回收器回收直到不再有 makeAdder()返回的函数对象的引用</p><p>域对象形成一个叫做域链的链，和 JavaScript 对象系统使用的原型链类似</p><p>闭包就是一个函数和其创造的域对象的集合体</p><p>闭包使你保持状态——如此，你会发现它们被用在对象的地方</p><p>see more closure@ closures</p><p>参考链接：</p><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript>https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript</a></li><li><a href=http://crockford.com/javascript/>http://crockford.com/javascript/</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Unicode>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Unicode</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://barnett617.github.io/wilson-blog/tags/javascript/>JavaScript</a></li></ul><nav class=paginav><a class=prev href=https://barnett617.github.io/wilson-blog/notes/2018-02-02-browser-cache/><span class=title>« 上一页</span><br><span>关于浏览器缓存</span>
</a><a class=next href=https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/><span class=title>下一页 »</span><br><span>React教程之快速上手篇</span></a></nav><script async crossorigin=anonymous src=/wilson-blog/assets/js/qrcode.a817fc490b9066afefa35cf981f6f003a76441b45cc519492334607a8cbcb264.js integrity="sha256-qBf8SQuQZq/vo1z5gfbwA6dkQbRcxRlJIzRgeoy8smQ=" onload='const wechatShareBtnFingerprint=document.getElementById("wechat-share-btn");if(wechatShareBtnFingerprint){wechatShareBtnFingerprint.style.position="relative";const e=document.createElement("div");e.id="qrcode",Object.assign(e.style,{position:"absolute",background:"#fff",padding:"8px",bottom:0,"box-sizing":"content-box","box-shadow":"rgba(0, 0, 0, 0.2) 0px 0px 10px 4px",width:"96px",height:"96px",left:"50%",transform:"translate(-50%, -43%)",visibility:"hidden"}),window.wechatShareQrCode=e,wechatShareBtnFingerprint.appendChild(e),new QRCode(document.getElementById("qrcode"),{text:window.location.href,width:128,height:128,colorDark:"#000",colorLight:"#fff",correctLevel:QRCode.CorrectLevel.H})}'></script><div class=share-buttons><a id=wechat-share-btn target=_blank rel="noopener noreferrer" aria-label="share JavaScript知识巩固 on wechat" href=javascript:void(0) onclick=return!1 onfocus='const shareBtnsPointer=document.getElementsByClassName("share-buttons")[0];shareBtnsPointer&&(shareBtnsPointer.style.overflowX="initial"),wechatShareQrCode.style.visibility="visible"' onblur='wechatShareQrCode.style.visibility="hidden"'><svg role="img" viewBox="0 0 24 24" height="30" width="30" fill="currentcolor"><path d="M8.691 2.188C3.891 2.188.0 5.476.0 9.53c0 2.212 1.17 4.203 3.002 5.55a.59.59.0 01.213.665l-.39 1.48c-.019.07-.048.141-.048.213.0.163.13.295.29.295a.326.326.0 00.167-.054l1.903-1.114a.864.864.0 01.717-.098 10.16 10.16.0 002.837.403c.276.0.543-.027.811-.05-.857-2.578.157-4.972 1.932-6.446 1.703-1.415 3.882-1.98 5.853-1.838-.576-3.583-4.196-6.348-8.596-6.348zM5.785 5.991c.642.0 1.162.529 1.162 1.18A1.17 1.17.0 015.785 8.349 1.17 1.17.0 014.623 7.17c0-.651.52-1.18 1.162-1.18zm5.813.0c.642.0 1.162.529 1.162 1.18a1.17 1.17.0 01-1.162 1.178 1.17 1.17.0 01-1.162-1.178c0-.651.52-1.18 1.162-1.18zm5.34 2.867c-1.797-.052-3.746.512-5.28 1.786-1.72 1.428-2.687 3.72-1.78 6.22.942 2.453 3.666 4.229 6.884 4.229.826.0 1.622-.12 2.361-.336a.722.722.0 01.598.082l1.584.926a.272.272.0 00.14.047c.134.0.24-.111.24-.247.0-.06-.023-.12-.038-.177l-.327-1.233a.582.582.0 01-.023-.156.49.49.0 01.201-.398C23.024 18.48 24 16.82 24 14.98c0-3.21-2.931-5.837-6.656-6.088V8.89c-.135-.01-.27-.027-.407-.03zm-2.53 3.274c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.97-.982zm4.844.0c.535.0.969.44.969.982a.976.976.0 01-.969.983.976.976.0 01-.969-.983c0-.542.434-.982.969-.982z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript知识巩固 on x" href="https://x.com/intent/tweet/?text=JavaScript%e7%9f%a5%e8%af%86%e5%b7%a9%e5%9b%ba&amp;url=https%3a%2f%2fbarnett617.github.io%2fwilson-blog%2fposts%2f2018-02-01-js-refresh%2f&amp;hashtags=JavaScript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://barnett617.github.io/wilson-blog/>Wilson's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>