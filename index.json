[{"content":" 接上篇\n环境准备好以后的使用还是比较简单的，我准备直接在原本基于 hexo 的博客项目中进行，因为想保留原先仓库的 git 提交记录。\n但是发现 hugo 使用文档 中并没有介绍在已有项目中初始化的方式，因此先建了一个新的站点，看下目录结构和配置文件和 hexo 有什么异同。\n目录结构 首先使用 tree 命令看下 hugo 生成的目录结构\n. ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes 8 directories, 2 files 主题选择 通过上面的命令初始化了 hugo 工程，但其实还没什么主要文件。\n因为整个 hugo 站点的内容是基于主题进行搭建的，可以在网上寻找适合自己的主题，官网提供了 300+个 主题\n这里我选择了 PaperMod 这个主题，这是一个基于 Paper 拓展的一个主题，相比 Paper 丰富了更多功能（一开始我尝试的是 Paper，发现很简洁，但是太简洁了）\n这里我选择将主题项目作为 git 子模块集成到项目的方式，在 hugo 工程的目录下载主题文件后，在主配置文件内设置 theme 配置项，然后就可以启动项目了\ngit submodule add https://github.com/nanxiaobei/hugo-paper themes/paper 项目启动 hugo server hugo server Watching for changes in /Users/xxx/xxx/{archetypes,assets,content,data,i18n,layouts,static,themes} Watching for config changes in /Users/xxx/xxx/hugo.toml Start building sites … hugo v0.120.4+extended darwin/arm64 BuildDate=unknown | EN -------------------+----- Pages | 7 Paginator pages | 0 Non-page files | 0 Static files | 11 Processed images | 0 Aliases | 3 Sitemaps | 1 Cleaned | 0 Built in 17 ms Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 可见 hugo 是启动了一个静态站点的服务将内容渲染到网页上，并且支持内容文件和配置文件修改的热更新\n这是一开始使用 Paper 截的图\n新建内容 hugo new content posts/xxx.md 这应该是最常用的命令，即新建一篇内容。\n执行后会根据输入的 md 文件名在 posts 目录新建对应的 md 文件，并且预设一些配置\n+++ title = \u0026#39;Use Hugo to Make a Blog Site\u0026#39; date = 2023-11-26T23:30:59+08:00 draft = true +++ 这里的 draft = true 表示新创建的文件默认为 草稿 状态，草稿内容不会被发布到站点的预览。\n更多关于 hugo 内容状态的设计可查看 https://gohugo.io/getting-started/usage/#draft-future-and-expired-content\n如果想让本地启动的预览服务能够展示草稿的内容，需要使用 hugo server -D（即 hugo server \u0026ndash;buildDrafts）来运行本地服务。\n发布站点 发布的命令很简单，就是一个hugo，它会根据配置文件将内容发布成最终的站点目录 public，里面包含的内容就是组成站点的 HTML、CSS 和 JavaScript 文件。\n这里的发布其实是 hugo 将 markdown 文件转换成 HTML。所谓发布是指生成发布目录 public，所以 public 目录是在 .gitignore 文件内的。因为真实的发布很少会手动拿着 public 目录去放到服务器目录，而是通过一些 CI/CD 流程在云端进行发布。\n但 public 里的目录基本就是最终可访问的站点全部内容了，都是一些静态资源，本地也可以直接访问 HTML 来查看\n远程发布 虽然 public 目录已经是一个可访问的静态站点目录，但是如果想在互联网上可访问，还需要将这个站点目录部署在线上的站点服务器，这样所有人都可以通过站点的 URL 进行访问。\n这里我选择使用 GitHub 提供的静态站点部署服务——GitHub Pages，它与 GitHub 仓库深度集成，可以将某个符合静态站点规则的仓库部署在仓库同名的 pages 域名下，并且还可以借助 GitHub Actions 将仓库的更新与站点部署更新集成起来，非常方便。\nHugo 也提供了与 GitHub Pages 集成的方式：https://gohugo.io/hosting-and-deployment/hosting-on-github/\n但这个配置感觉有点疏于更新，实际用起来会有些问题，最终我参考网上其他使用者的讨论，找到了最新的配置方式。\n这就体现出一个相对成熟框架的优势，有足够多的使用者和相对活跃的社区非常重要，这对于新用户遇到问题后能否找到解决方法很有帮助。比如 hugo 有自己的社区论坛\n感想 每次折腾博客站点，就感觉像是在装修房子，对于主题的选择和站点内的配置一次次考验着个人的审美以及取舍观。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-11-26-hugo-blog-2/","summary":"接上篇\n环境准备好以后的使用还是比较简单的，我准备直接在原本基于 hexo 的博客项目中进行，因为想保留原先仓库的 git 提交记录。\n但是发现 hugo 使用文档 中并没有介绍在已有项目中初始化的方式，因此先建了一个新的站点，看下目录结构和配置文件和 hexo 有什么异同。\n目录结构 首先使用 tree 命令看下 hugo 生成的目录结构\n. ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes 8 directories, 2 files 主题选择 通过上面的命令初始化了 hugo 工程，但其实还没什么主要文件。\n因为整个 hugo 站点的内容是基于主题进行搭建的，可以在网上寻找适合自己的主题，官网提供了 300+个 主题\n这里我选择了 PaperMod 这个主题，这是一个基于 Paper 拓展的一个主题，相比 Paper 丰富了更多功能（一开始我尝试的是 Paper，发现很简洁，但是太简洁了）\n这里我选择将主题项目作为 git 子模块集成到项目的方式，在 hugo 工程的目录下载主题文件后，在主配置文件内设置 theme 配置项，然后就可以启动项目了\ngit submodule add https://github.","title":"使用Hugo搭建博客站点下篇——正式使用"},{"content":"Hugo 简介\u0026amp;对比 Hexo Hugo 是一款基于 Go 的开源静态站点框架，从 Github 记录来看，应该是 Hexo 的前身（一款基于 Node.js 的博客框架）。\nHugo 的简介是“世界上构建网站最快的框架”，这个不可否认，因为 Go 语言的优势就是并发性能高。不过对于搭建博客这种相对静态的站点来说，多少有点 Over Kill。\n那么既然它的简介是可以“构建网站“，扩展性上应该还是不错的吧，可能如果真的用于维护相对大型的网站，可能效果要比 Hexo 好一些？\n环境准备 按照 Hugo 安装说明准备好环境，我选择使用 Hugo 源码本地构建的方式，这里主要是准备 git、go 以及 c 编译器的配置。\n这几项对于 Mac OS 来说都还好，主要是就是安装 Go，不过之前本地装过 Go，最终准备好的环境状态如下：\n➜ ~ git --version git version 2.39.2 (Apple Git-143) ➜ ~ go version go version go1.21.3 darwin/arm64 ➜ ~ gcc --version Apple clang version 14.0.3 (clang-1403.0.22.14.1) Target: arm64-apple-darwin22.5.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 安装 Hugo 使用源码构建的方式，就是执行一条命令\nGGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest 这应该是把 Hugo 这个模块安装到 Go 的环境里，但是一上来就遇到了国内老生长谈的资源代理问题\nGGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest go: github.com/gohugoio/hugo@latest: module github.com/gohugoio/hugo: Get \u0026#34;https://proxy.golang.org/github.com/gohugoio/hugo/@v/list\u0026#34;: dial tcp 142.251.43.17:443: i/o timeout 于是查了一下网上的解决方法，尽管使用了谷歌搜索，排名靠前的搜索结却依然是 CSDN 的回答，方法就是改用国内代理\ngo env -w GOPROXY=https://goproxy.cn 这种方法可能立竿见影，但是怕后续安装其他包有问题，所以继续看看有没有更通用的解决方法。\n接着搜到 Go 的 Github 仓库下相关的 issue ，里面讨论出的方法看上去更加简单粗暴\ngo env -w GOPROXY=direct go env -w GOSUMDB=off 看上去像是把代理修改为了直连，还关闭了一个配置，但这确实大家一致认同（👍🏻）的解决方法\n再看看还有没有更靠谱的方法（开始好奇国内那么多 Go 开发者又是怎么面对代理这个问题的，真是难）\n还发现了第一个方法（修改代理源）相关的 Github 讨论，这个工具应该是中国人开发的，以至于 issue 内都直接是全中文讨论。\n开始感慨国内环境下学一门新的编程技术时，往往遇到的最大问题就是环境问题，这也是最劝退的环节，但这本不应该是阻挠初学者入门的问题。\n接着打开了一篇 StackOverflow 的帖子\n没想到这问题在 2022 年也有讨论，好像是 Go 本身存在已久的问题，再次感叹 Go 的开发者不易。\n翻了下一开始检查的 Go 版本号，是 go1.21.3，而 Node.js 的主版本好像都到 20 了吧，难道 Go 生态的迭代好像还不是很成熟的状态？\n不过经过 StackOverflow 帖子的确认，准备考虑试一下把代理修改为直连的方式，希望奏效。\n不过我开始好奇对 Go 有更多的了解，比如如何查看我本地 Go 的环境的完整配置现状是什么样呢？比如修改 GOPROXY=direct，那其他配置是什么样的呢？我修改完这个怎么确认我的修改有效呢？以及修改完这个配置还需要做什么来让这个配置修改生效呢？\n就在思考这些的同时，刚刚修改完配置的执行已经结束了，结果是再次失败\nGGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest go: downloading github.com/gohugoio/hugo v0.120.4 go: github.com/gohugoio/hugo@latest: github.com/gohugoio/hugo@v0.120.4: verifying module: github.com/gohugoio/hugo@v0.120.4: Get \u0026#34;https://sum.golang.org/lookup/github.com/gohugoio/hugo@v0.120.4\u0026#34;: dial tcp 142.251.43.17:443: i/o timeout 不过这次的失败原因好像不一样，看上去 Hugo 本身的下载好像有些进展，最后失败的是下载 sum 相关的东西。\n这不就跟上面查到的对上了么，因为我只是把代理修改为了直连，而没有关闭那个和 sum 相关的配置，原因是为了做最小改动，但是看样子这个还是避不开要做。\nsum 这个东西从名字上来看像是对包的校验，所以我决定暂时完全按照大家试过的方式先解决这个问题。\n而且刚才我使用的是 StackOverflow 帖子里提供的方式，也就是\nexport GOPROXY=direct 这种 export 的方式我记得是修改 shell 环境的环境变量设置，不知道下面的设置方式本质是不是也是这个效果。\ngo env -w GOPROXY=direct go env -w GOSUMDB=off 不过，这样来看 go env 应该是 go 的一个命令，那么可以通过 help 命令看下具体的当前配置情况，也顺便解开刚才的迷惑。\ngo help Go is a tool for managing Go source code. Usage: go \u0026lt;command\u0026gt; [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance work workspace maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 发现一个好东西，go env ，原来这个命令默认是可以查看所有的环境配置信息，如果在后面跟随内容则是对环境配置进行设置，这样看 -w 应该是写入的意思，有点像 git 修改配置的方式。\n同时，我也在打印出的环境配置信息中发现了我想知道的，如下：\nGOPROXY=\u0026#39;direct\u0026#39; 这意味着刚才通过 export 设置的应该是生效了，但是 GOSUMDB 如下：\nGOSUMDB=\u0026#39;sum.golang.org\u0026#39; 这明显和预期的 off 不同，可能就是这个默认配置导致我的步骤进行不下去，那么赶紧修改它试一下\ngo env -w GOSUMDB=off 这次果然顺利，控制台展示出各个模块的下载\nGGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest go: downloading github.com/gohugoio/hugo v0.120.4 go: downloading github.com/alecthomas/chroma/v2 v2.10.0 go: downloading github.com/bep/clocks v0.5.0 go: downloading github.com/bep/debounce v1.2.0 go: downloading github.com/bep/lazycache v0.2.0 go: downloading github.com/bep/logg v0.3.0 go: downloading github.com/bep/mclib v1.20400.20402 go: downloading github.com/bep/overlayfs v0.6.0 go: downloading github.com/bep/simplecobra v0.3.2 go: downloading github.com/fsnotify/fsnotify v1.7.0 go: downloading github.com/spf13/afero v1.10.0 go: downloading github.com/spf13/cobra v1.7.0 go: downloading github.com/spf13/fsync v0.9.0 go: downloading github.com/spf13/pflag v1.0.5 go: downloading go.uber.org/automaxprocs v1.5.3 go: downloading golang.org/x/sync v0.4.0 go: downloading gopkg.in/yaml.v2 v2.4.0 go: downloading github.com/hashicorp/golang-lru/v2 v2.0.1 go: downloading github.com/bep/godartsass v1.2.0 ... 后面有时间等有必要时再了解一下这里的 sum 究竟是什么作用，目前配置上先把它设置为 off 了，如果是包校验什么的，应该也不会影响 go module 的正常使用\n模块的下载过程就是普通的网络 IO，不过看到控制台展示的内容突然想起来之前看到过的 Go 代码，Go 的模块引用路径好像是可以写远程 URL 的，难道 Deno（Node.js 之后的 JavaScript 服务端运行时）也是借鉴了这种方式？\n还在想这些的时候，没想到下载过程又失败了，这次虽然应该是成功下载了一部分模块，但还是有很多模块因 tcp 拨号超时导致没下载下来。\ngo: downloading github.com/josharian/intern v1.0.0 pkg/mod/github.com/bep/mclib@v1.20400.20402/internal/main.go:27:2: unrecognized import path \u0026#34;golang.org/x/net\u0026#34;: https fetch: Get \u0026#34;https://golang.org/x/net?go-get=1\u0026#34;: dial tcp 172.217.163.49:443: i/o timeout pkg/mod/software.sslmate.com/src/go-pkcs12@v0.2.0/crypto.go:20:2: unrecognized import path \u0026#34;golang.org/x/crypto\u0026#34;: https fetch: Get \u0026#34;https://golang.org/x/crypto?go-get=1\u0026#34;: dial tcp 172.217.163.49:443: i/o timeout pkg/mod/github.com/spf13/afero@v1.10.0/util.go:28:2: unrecognized import path \u0026#34;golang.org/x/text\u0026#34;: https fetch: Get \u0026#34;https://golang.org/x/text?go-get=1\u0026#34;: dial tcp 142.251.43.17:443: i/o timeout pkg/mod/github.com/spf13/afero@v1.10.0/util.go:29:2: unrecognized import path \u0026#34;golang.org/x/text\u0026#34;: https fetch: Get \u0026#34;https://golang.org/x/text?go-get=1\u0026#34;: dial tcp 142.251.43.17:443: i/o timeout pkg/mod/github.com/spf13/afero@v1.10.0/util.go:30:2: unrecognized import path \u0026#34;golang.org/x/text\u0026#34;: https fetch: Get \u0026#34;https://golang.org/x/text?go-get=1\u0026#34;: dial tcp 142.251.43.17:443: i/o timeout pkg/mod/github.com/fsnotify/fsnotify@v1.7.0/backend_kqueue.go:16:2: unrecognized import path \u0026#34;golang.org/x/sys\u0026#34;: https fetch: Get \u0026#34;https://golang.org/x/sys?go-get=1\u0026#34;: dial tcp 172.217.163.49:443: i/o timeout ... 先试一下 Hugo 现在能不能运行\nhugo --version zsh: command not found: hugo 可惜，看来 hugo 还没成功下载。于是接着拿控制台的内容去搜索解决方法。\n这回搜到的是知乎的回答\n感觉标准的方式行不通了，为了不在环境准备这一步花费太多时间，我决定妥协使用国人的工具，也就是 goproxy.cn，毕竟有些问题本质就是网络环境的问题。\ngo env -w GOPROXY=https://goproxy.cn warning: go env -w GOPROXY=... does not override conflicting OS environment variable 竟然这也不顺利\n有点回想起当初折腾 Java 的感觉，果然服务端的东西很多时候还是环境的问题，docker 也算解决了一部分这些问题吧，毕竟对于应用部署来说。\n不过再仔细看控制台输出，想起了刚才使用过 export 设置，感觉这就是和 go env 冲突的地方，也是刚才担心过的问题。\n本来准备研究一下 shell 的 export 和 source 以及 go env 的区别，但是在搜索的过程中发现 goproxy.cn 的官网，看了一下受欢迎程度还行。\n那就先试试用这个工具来搭建国内使用 Go 的环境吧，毕竟对于 Node.js 在国内使用也是要经常考虑把包管理源设置为国内的镜像。\n于是准备按照 goproxy.cn 的使用介绍进行配置，不过依然在进行到设置 GOPROXY 这一步会失败，看输出内容应该就是和 shell 环境里的设置冲突了。不过我记得通过 export 设置的环境变量只在一次 shell 的生命周期有效，也就是只要我重启 shell ，刚才通过 export 设置过的应该就会没了。\n经过验证，果然如此，在重启终端后再次使用 go env 设置 GOPROXY 果然成功了，安装继续。\nGGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest go: downloading golang.org/x/sync v0.4.0 go: downloading golang.org/x/exp v0.0.0-20221031165847-c99f073a8326 go: downloading golang.org/x/text v0.13.0 go: downloading google.golang.org/api v0.138.0 go: downloading golang.org/x/sys v0.13.0 go: downloading golang.org/x/tools v0.14.0 go: downloading google.golang.org/protobuf v1.31.0 go: downloading golang.org/x/image v0.13.0 go: downloading cloud.google.com/go/compute/metadata v0.2.3 go: downloading cloud.google.com/go/compute v1.23.0 go: downloading cloud.google.com/go/iam v1.1.1 go: downloading cloud.google.com/go/storage v1.31.0 go: downloading golang.org/x/oauth2 v0.11.0 go: downloading cloud.google.com/go v0.110.7 go: downloading golang.org/x/net v0.17.0 go: downloading golang.org/x/mod v0.13.0 go: downloading golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 go: downloading google.golang.org/grpc v1.57.0 go: downloading golang.org/x/crypto v0.14.0 go: downloading google.golang.org/genproto/googleapis/api v0.0.0-20230803162519-f966b187b2e5 go: downloading google.golang.org/genproto v0.0.0-20230803162519-f966b187b2e5 go: downloading google.golang.org/genproto/googleapis/rpc v0.0.0-20230807174057-1744710a1577 go: downloading github.com/golang/protobuf v1.5.3 go: downloading github.com/google/s2a-go v0.1.5 go: downloading github.com/googleapis/enterprise-certificate-proxy v0.2.5 go: downloading google.golang.org/appengine v1.6.7 这次果然异常平静得顺利 🙄，看来在国内开发 Go，还是得有一层自己的代理。\n这个代理层应该是在国内服务器架设了模块仓库，然后定期更新国外源的资源并做缓存。所有具备模块化的语言基本都逃不开这种做法，不过说到底这还是网络的问题，但好像这样做也是符合各个国家分布式使用网络资源的最合理方式，有点像网络模块的 CDN 。\n问题不大，赶紧试试 hugo 装成功了吗\nhugo --version zsh: command not found: hugo 竟然还是不行，感觉被模块下载缠了这么久，有点忘记主线的流程，返回看了下 hugo 的文档\n这回好像又发现了自己的问题，可以是因为之前就安装过 Go ，因此对于 GOBIN 这一步的设置忽视了。好像是因为这里没按照 hugo 文档进行设置，因此无法在任意目录使用 hugo 的可执行文件。\n于是按照 hugo 文档的提示去看了看 Go 的文档，大概理解了 GOBIN 的定位，这是存放 Go 可执行模块的地方，类似于 Node.js 中 .bin（包括 Linux 操作系统对于可执行文件的设计也差不多是这样的）\n于是找到 GOPATH 所在的目录，果然找到了 bin 目录，进到 bin 目录后果然看到了可执行文件 hugo 。\n既然 hugo 已经安装成功，那就好办了。\n看到 Go 文档中有介绍可以设置 GOBIN 的目录，但是此时还是不太理解如果不设置用默认的有什么问题。反复看了几遍关于 go mod 的介绍，感觉和 Node.js 对于 node_modules 的管理差不多。\n直到看到 Hugo 社区的一篇帖子才恍然大悟。\n对于 hugo 有社区这一现象感觉还不错，说明用户群体应该挺大的，而且 hugo 貌似也有些年头了。\n关键问题就在于我没有设置 GOBIN，因此对于 Go 下载下来的可执行模块都放在了 GOPATH 下的 bin 目录。\n但在没有做任何事情的情况下，这些可执行文件只能进到这个目录才能执行，而不能任何其他位置执行，这不就是 Linux 系统对于 bin 目录的设计吗\n因此只有我把 GOBIN 设置为系统的用户 bin 目录下，这样操作系统才会对于我在任意目录下输入某个文件时查找其是否存在于可执行文件目录并执行。\n而且这篇帖子的讨论也顺带提了一下关于 source 命令的使用，这里应该意思就是 source 是用来执行 shell 配置文件的，因此当修改完 shell 配置文件后，如果希望立刻对当前 shell 环境生效，那么需要通过 source 来显式地告诉 shell。\n于是我仔细检查了我的 $PATH 和 ~.zshrc 配置\n我的 $PATH 中有 /usr/local/go/bin 一项，同时我的 ~.zshrc 中有关于 $PATH 相关的导出 export PATH=\u0026quot;$BUN_INSTALL/bin:$PATH\u0026quot;\n因此对于 /usr/local/go/bin 目录下的可执行文件我是可以在任意目录执行的，但问题在于我当前的 go env 中并未设置 GOBIN，所以安装在该目录的 hugo 暂时还无法被检索到。\n问题清晰了就离解决不远了\n先总结一下，shell 的配置文件，默认可能是 bash 的配置文件，使用了 on my zsh 的则会是 .zshrc。\n这个文件声明了 shell 启动时的环境配置，里面一般会将 $PATH 变量导出，这也意味着该变量内的路径都成为了某个 shell 内的环境变量，因此在 shell 内执行文件时都会寻着 $PATH 变量设置过的所有路径找一遍。\n因此一般会将可执行文件存放的目录设置在 PATH 中，这一特征对于类 Unix 系统（Linux、MacOS）和 Windows 都差不多\n总结完，我们就知道应该如果做了。\n因为我现在的 .zshrc 是导出了 PATH 的，而 PATH 中也存在 Go 相关的可执行文件目录，只是 Go 下载可执行模块的安装目录由于未设置而被默认为 ~/go/bin。而这个目录并不在 PATH 之列，因此无法在执行文件时被索引到，这可能是之前装 Go 时因为不熟悉而留下的问题吧。\n那么现在可做的方法有两个，一个是把 GOBIN 的默认目录设置在 PATH 中，另一个则是把 PATH 中已有的 Go bin 目录设置为 GOBIN 目录，我选择后者，因为改动最小。\n改动之前可以先到 /usr/local/go/bin 目录看看现在都有什么\ncd /usr/local/go/bin ➜ bin ls go gofmt 啊哈，原来就是 go 本身，那 Go 只是默认不希望所有下载的可执行模块都被注册到这里来吧，因此默认的 GOBIN 留给了用户自己设置\nCGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest github.com/gohugoio/hugo: go install github.com/gohugoio/hugo: copying /var/folders/56/pfj7c2qs30j1n92sqrrq471c0000gn/T/go-build113185545/b001/exe/a.out: open /usr/local/go/bin/hugo: permission denied ➜ bin sudo CGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest Password: ➜ bin ls go gofmt hugo 效果不错，只是很明显这样下载可执行模块时需要通过 sudo 授权，因为貌似 /usr/local/go/bin 是需要授权的目录，而 ~/go/bin 是用户目录则没有这个问题。而且这个问题也只有在下载模块到 go 全局模块目录才会有这个问题，对于一般的 Go 项目都会下载到项目目录（类比下载 npm 包到 node_modules）。\n不过为了不给未来留坑，貌似还是把 GOBIN 默认的 ~/go/bin 设置到 PATH 更合理些，毕竟发现 PATH 中有关于 bun（JavaScript 另一个服务端运行时）的设置就是将用户目录设置在 PATH 的，而且 PATH 中大多设置的都是用户目录，并附加系统的那几个 bin 目录。\n经过一顿关于环境变量的设置，终于如愿以偿地看到了下面的输出\nhugo version hugo v0.120.4+extended darwin/arm64 BuildDate=unknown 真是有点为了砸一个钉子，研究了锤子是怎么做的，不过索性就当复习了一下操作系统基础知识。\n使用 Hugo 新建站点 未完待续\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-11-26-hugo-blog-1/","summary":"本篇介绍将博客站点从 Hexo 迁移为 Hugo 的过程以及途中遇到一些问题的解决记录","title":"使用Hugo搭建博客站点上篇——环境准备"},{"content":"包和库 库是 Rust 编译器一次考虑的最小数量的代码，即使使用 rustc 运行一个源码文件，也称为库。\n库可以包含模块，模块可能定义在其他文件。\n库形态 库有两种形态，可以是一个二进制库或一个源码库。\n二进制库需要有 main 函数定义。\n源码库可以没有 main 函数，不会被编译为可执行文件，只定义用于多个项目使用的函数，比如 rand，一般 rust 使用者提到的库都是源码库。\n包 包是由一个或多个库组成的，有 Cargo.toml 文件描述如果构建其中的库。\nCargo 就是一个包，它包含二进制库用于命令行工具，同时也包含一些源码库用于命令行工具。\n一个包可以有任意多个二进制库，但只能有一个源码库。\n定义模块以控制作用域和私有性 use 关键字用于将一个路径引入作用域，pub 关键字用于将内容公开。\n模块技巧 从源码库根开始：当编译一个库时，编译器首先会寻找根库文件（源码库一般是 src/lib.rs，二进制库一般为 src/main.rs） 声明模块：在根库文件，可以声明新的模块，比如 mod garden; （编译器会从以下地方寻找该模块） 行内 src/garden.rs src/garden/mod.rs 声明子模块：在根库以外的任意文件，可以声明子模块。比如 mod vegetables; （编译器会从以下地方寻找子模块） 行内 src/garden/vegetables.rs src/garden/vegetables/mod.rs 模块内的代码路径：一旦模块成为库的一部分，在同一个库内的任意地方都可以引用那个模块内的代码。比如 crate::garden::vegetables::Asparagus 私有性和公有性：从父模块访问子模块内的代码默认是私有的，要声明公有性需要使用 pub mod 声明模块 use 关键字：在一个作用域内，use 关键字可以代替模块的完整路径。比如 crate::garden::vegetables::Asparagus，可以先 use crate::garden::vegetables::Asparagus，然后就可以在作用域内任意地方直接使用 Asparagus 感想 模块化设计是一门语言很关键的部分，也是其可拓展性的基石。因为语言默认提供的内置库毕竟有限，如果想利用起来整个开发者社区的力量，模块化设计的是否合理、好用则会是决定社区贡献活跃度很重要的因素。\n这里就想到了 JavaScript 的模块化演进之路，由于 JS 最初的语言定位仅仅是网页脚本，因此几乎没有模块化的概念和必要。\n但由于 JS 语法简单、易上手以及运行便捷（在浏览器中就可以运行，完全不需要经过编译）的特性，这门语言的使用者越来越多，由此产生的脚本也越来越多，以及后面诞生的 Node.js，使得服务端也可以运行 JavaScript。\n随着代码量的增长，对代码进行模块化管理变得迫在眉睫，因此 Node.js 自己定义了名为 CommonJS 的模块化管理方案。当然浏览器端运行的 JS 代码量也在不断增加，因此也有了浏览器端模块化管理 JS 的社区方案产生，比如 AMD(Asynchronous Module Definition)\n但这些都不是 JavaScript 语言官方支持的模块化管理方案，直到 2015年，JavaScript 语言标准第六版实现了语言层面的 Module 定义。\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-08-31-rust-05/","summary":"使用包、预置库和模块管理不断增长的项目","title":"Rust语法学习-使用包、预置库和模块管理不断增长的项目"},{"content":"使用 if let 管理简约控制流\nlet config_max = Some(3u8); match config_max { Some(max) =\u0026gt; println!(\u0026#34;The maximum is configured to be {}\u0026#34;, max), _ =\u0026gt; (), } 对于以上这种不想对 None 值做任何处理的情况，可以使用 if let\nlet config_max = Some(3u8); if let Some(max) = config_max { println!(\u0026#34;The maximum is configured to be {}\u0026#34;, max); } if let 可以看作是 match 的语法糖，用于只关心匹配某种情况而不需要处理其他情况的场景\n如果想处理其他场景，也可以使用 else\nlet mut count = 0; match coin { Coin:Quarter(state) =\u0026gt; println!(\u0026#34;State quarter from {:?}\u0026#34;, state), _ =\u0026gt; count += 1, } let mut count = 0; if let Coin:Quarter(state) = coin { println!(\u0026#34;State quarter from {:?}!\u0026#34;, state); } else { count += 1; } ","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-08-31-rust-04/","summary":"\u003cp\u003e使用 if let 管理简约控制流\u003c/p\u003e","title":"Rust语法学习-使用 if let 管理简约控制流"},{"content":"枚举定义 枚举和结构体类似，但它可以定义在多个值可能性下的某一种。\n比如 IP 地址目前只有 ipv4 和 ipv6 两种，当定义一个 IP 地址时它只可能是这两种中的一种。\n因此对于 IP 地址的类型范围就可以一个枚举，表示该类型所有的可能。\nenum IpAddrKind { V4, V6, } let four = IpAddrKind::V4; let six = IpAddrKind::V6; 对于 four 和 six，它们的类型都是 IpAddrKind，但又各自唯一。\nfn route(ip_kind: IpAddrKind) {} 这在作为函数参数类型时能够体现出来。\nroute(IpAddrKind::V4); route(IpAddrKind::V6); 枚举使用 enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind: IpAddrKind::V4, address: String::from(\u0026#34;127.0.0.1\u0026#34;), }; let loopback = IpAddr { kind: IpAddrKind::V6, address: String::from(\u0026#34;::1\u0026#34;), } enum IpAddr { V4(String), V6(String), } let home = IpAddr::V4(String::from(\u0026#34;127.0.0.1\u0026#34;)); let loopback = IpAddr::V6(String::from(\u0026#34;::1\u0026#34;)); 这样简写，无需声明结构体，这里的枚举像是一个函数。\nenum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\u0026#34;::1\u0026#34;)); enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } 这样的枚举声明类似于以下定义四个结构体的方式\nstruct QuitMessage; // unit struct struct MoveMessage { x: i32, y: i32, } struct WriteMessage(String); // tuple struct struct ChangeColorMessage(i32, i32, i32); // tuple struct 枚举对比结构体 impl Message { fn call(\u0026amp;self) { } } let m = Message::Write(String::from(\u0026#34;hello\u0026#34;)); m.call(); 选项枚举 Option 是标准库内定义的类型，可用于表示某个值可能是某个值或者什么都不是。\n比如当你访问一个非空列表的第一项时，你得到的就是列表第一项的值。\n当你访问一个空列表的第一项时，你得到的就是什么都不是。\n这种类型系统术语中的概念意味着编译器发现你处理了所有你应该处理的情况。\n编程语言的设计一般会考虑你需要包含哪些功能，但那些未被包含的功能同样重要。Rust 不像其他编程语言，它没有 null 值。\nnull 值的问题在于你可能把它当做非 null 值使用，这样你会得到意想不到的错误。\nenum Option\u0026lt;T\u0026gt; { None, Some\u0026lt;T\u0026gt;, } 选项枚举的价值在于当某个值的类型是选项枚举时，你需要处理它为 null 的情况，而在非 null 的情况你可以放心的使用。\n模式匹配 模式匹配允许你在值匹配到各个条件时执行基于该值情况的逻辑，模式可以是字面量、变量名或通配符等。匹配的强大之处在于模式的可表达性以及编译器可以确保所有情况都会被处理。\n类似 JS 的 switch 语句\n#[derive(Debug)] enum UsState { Alabama Alaska, } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; { println!(\u0026#34;Lucky penny!\u0026#34;); 1 }, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin: Quarter(state) =\u0026gt; { println!(\u0026#34;State quarter from {:?}!\u0026#34;, state); 25 }, } } fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { None =\u0026gt; None, Some(i) =\u0026gt; Some(i + 1), } } let five = Some(5); let six = plus_one(five); let none = plus_one(None); 匹配需要完备 当匹配条件未声明完备（处理所有情况）时，编译器会报错并提示未处理的情况。\nlet dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), other =\u0026gt; move_player(other), } fn add_fancy_hat() {} fn remove_fancy_hat() {} fn move_player(num_spaces: u8) {} 这里的 other 表示除已经定义的匹配外，剩余的情况都会走到这里，这种情况可以任意定义匹配名称，比如这里使用了 other。\n如果不想显式地声明剩余情况，可以使用“_”表示“其他情况”，然后声明对应的处理函数或者什么都不做\nlet dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), _ =\u0026gt; reroll(), } fn add_fancy_hat() {} fn remove_fancy_hat() {} fn reroll() {} let dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), _ =\u0026gt; (), } fn add_fancy_hat() {} fn remove_fancy_hat() {} ","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-07-11-rust-03/","summary":"关于枚举和模式匹配","title":"Rust语法学习-枚举和模式匹配"},{"content":"使用结构体可以自定义一系列数据结构并打包在一起，然后用其定义多个符合这个结构的值。\n类比 C 语言的结构体以及 TypeScript 的 Interface\n结构体类似面向对象编程中的对象属性声明，使用结构体可以声明并实例化数据对象。\n可被用于定义有关联的函数，这种有关联的函数称为”方法“。\n结构体和枚举被用来创建新类型的代码块，以此充分利用 Rust 在编译时进行的类型检查。\n声明和初始化结构体 结构体类似于元组，都包含多个相关的值，并且支持存放不同类型的值。\n不同于元组的是，结构体需要给每个值进行命名，因此可以知道每个值的含义。\n增加了对于值的命名也意味着结构体比元组更加灵活——无需再依赖值的顺序来访问实例内的值。\n结构体声明 struct User { active: bool, username: String, email: String, sign_in_count: u64, } 类比 C 语言结构体的声明方式\n结构体实例化 实例化结构体时无需按照结构体内的变量顺序，这也意味着结构体类似于数值类型的通用”模板“\nfn main() { let user1 = User { active: true, username: String::from(\u0026#34;someusername123\u0026#34;), email: String::from(\u0026#34;someone@example.com\u0026#34;), sign_in_count: 1, } } 结构体访问和赋值 fn main() { let user1 = User { active: true, username: String::from(\u0026#34;someusername123\u0026#34;), email: String::from(\u0026#34;someone@example.com\u0026#34;), sign_in_count: 1, } user1.email = String::from(\u0026#34;anotheremail@example.com\u0026#34;); } 从已有实例生成新实例 struct User { active: bool, username: String, email: String, sign_in_count: u64, } fn main() { let user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; let user2 = User { active: user1.active, username: user1.username, email: String::from(\u0026#34;another@example.com\u0026#34;), sign_in_count: user1.sign_in_count, } } 对于 user2 和 user1 这种结构相同，只有部分字段更新的情况，可以使用 .. 对相同字段的值进行简写\nfn main() { let user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), ..user1 }; } .. 类似于 JS 中的剩余参数，只能用于最后\n元组结构体 元组结构体使用 struct 关键字声明，可以对结构相同的元组各自进行命名，从而进行区分，用于表示不同的内容\nstruct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); } black 和 origin 的结构相同，却是不同的自定义数据类型。比如一个函数使用 Color 作为参数类型，则不能将 Point 类型的实例作为参数传入。\n类似于 TS 里的类型，即使结构相同，但属于不同的类型\n方法 “方法”类似“函数”，都使用 fn 关键字进行声明，可以有参数和返回值。\n方法与函数的区别在于方法只能在结构体、枚举或者特征对象内部定义，并且第一个参数始终为 self，表示方法被调用时的实例（上下文）。\n类似于 python 和 java 的方法\n声明方法 #[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, rect1.area() ); } 这里使用了 impl 关键字，用于表示与类型的关联的实现。\u0026amp;self 其实是 \u0026amp;self: Self 的简写，Self 表示 impl 所实现的类型。\nself 既可以传递所有权(self)，也可以借用不可变引用 (\u0026amp;self) 或借用可变引用 (\u0026amp;mut self)，和函数的参数用法类似。\n这里我们只希望读取值，而不进行值的写操作，因此使用了借用不可变引用，而非可变引用或传递所有权。\n方法对比函数 之所以使用方法而非函数，是为了在多个地方能够访问 self，而无需重复作为参数传递，这样组织代码更加方便。\n方法名可以和结构体内的字段同名\nimpl Rectangle { fn width(\u0026amp;self) -\u0026gt; bool { self.width \u0026gt; 0 } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; if rect1.width() { println!(\u0026#34;The rectangle has a nonzero width; it is {}\u0026#34;, rect1.width); } } 这里既访问了实例的 width 方法，也访问了实例的 width 属性。当使用括号访问时，表示在访问方法，没有括号时表示在访问属性。\ngetter 某些情况，我们希望当存在方法与属性同名时，访问方法仅仅是返回同名的属性值，这种方法称为“getter”\ngetter 不会被默认实现\ngetter 一般用于将一个结构体的属性不对外暴露（私有化），而只暴露方法（公有化）\n开闭原则——对访问开放，对修改封闭\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-07-10-rust-02/","summary":"\u003cp\u003e使用结构体可以自定义一系列数据结构并打包在一起，然后用其定义多个符合这个结构的值。\u003c/p\u003e","title":"Rust语法学习-结构体"},{"content":"rust 语法融合了多门编程语言的特性，可以看到很多语言的影子，例如 JavaScript、Java、Python、C、Go 等。\n打印 println!()是宏定义，不是普通函数\n类比 C 语言以及 python2 的 print\n代码格式 缩进为 4 个空格，而非tab（因为 tab 不一定对应 4 个空格）\n类比 Python 语言，严格要求缩进作为有效格式\n类型 字符使用单引号，字符串使用双引号\n类比 C 和 Java，JavaScript 中的单引号和双引号没有区别\n函数 声明函数使用fn\n类比 Go 语言中函数的声明\n元组和数组 元组内可以存放不同类型的值，数组只能存放相同类型的值。\n数组在声明时需要制定确定的大小，即数组元素的个数。\n类比 Python 中的元组和列表\n解构 对于元组或数组内的元素，都可以使用解构取出其内部的值。解构就是从一个大的容器内取出对应位置的值的操作。\n类比 JavaScript 中的解构\n栈和堆 栈是连续内存，堆是随机分配的内存，因此申请栈比申请堆要快，所以一般将不确定大小或未来可能变化的变量存在在堆，并将访问该变量的指针（地址）存在栈。这样可以从栈中快速找到变量指针，然后通过指针访问具体的值。\n整型、浮点型和布尔类型的变量创建时都申请固定大小的内存，所以它们都存在栈中。\n字符串占用的内存不确定且可能被改变，因此存放在堆内存。\n类比 JavaScript 和 Java 对于变量声明的内存分配方式，但 JavaScript 的字符串因为是基本类型，所以存在栈而非堆中\n变量不可变 变量默认都是不可变的，如果希望变量可被改变，需要使用mut(意指”mutable“)进行声明。\n所有权 类比其他编程语言中的\u0026quot;按值传参 v.s. 按引用传参\u0026quot;\n所有权转让，对应将值传入函数，所有权会跟着进入函数内部，当函数执行完成，如果没有把所有权返回，值所在内存会被自动回收（drop），类似于”按值传参“。\n将引用传入函数，所有权未被传入函数，当函数内对于变量访问结束后，虽然函数作用域结束了，但是变量的所有权因为未被转移而仍然存在，因此不会被自动回收，类似于”按引用传值“。\n这种使用引用访问值的方式称为\u0026quot;借用\u0026quot;，就像生活中一个物品的所有者，将物品借给你用，当你使用完后会进行归还，从始至终物品的所有权都未曾属于你，你只是在\u0026quot;借用\u0026quot;。\n类比 Java\n可变引用 将变量本身改为可变的 将函数的参数改为可变引用 传入函数时传入可变引用 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 限制 1：只能被借用一次 只能被借用一次（即不能被多个变量访问其可变引用）\n这是为了避免”竞态（race condition）“\n当以下三条满足时，会发生竞态\n两个或以上指针在同一时刻访问同一份数据 至少有一个指针在写数据 没有机制被用来支持同步写数据 限制 2：当被用来作为不可变借用后不能再进行可变借用 一旦变量被作为不可变借用后，不能再作为可变借用，因为可变借用会导致前面的不可变借用被篡改。\n但是多个不可变借用是可以的，因为它们都是在读数据，不会改变数据。\n摇摆指针 将某个作用域内对于内存的引用传递给作用域以外，类似于 js 的闭包\nfn main() { let reference_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s } 类比 JavaScript 中的闭包，将函数内的变量引用暴露给函数外的作用域\n这里在dangle函数内部声明了字符串引用s，并试图将这个引用通过函数返回。但rust不会允许这么做，当函数执行结束，其作用域内的引用会被回收。\n如果想要访问函数内生成的变量，可以使用非引用的值\nfn main() { let s = dangle(); } fn dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); s } 这里s的所有权转移到了函数外，没有引用被回收。\n字符串切片 可以通过..符对字符串进行切片\n类比 Python 中的切片和 JavaScript 中的 slice 方法\n字符串字面量切片 let s = \u0026#34;Hello, world!\u0026#34;; 这里s的类型是\u0026amp;str，它其实是指向二进制指定位置的切片。这也是为什么字符串字面量是不可变的，并且\u0026amp;str是不可变引用。\n这里的\u0026amp;str存储着切片开始的位置，以及切片的长度，从而可以计算出切片部分的值。\n小结 Rust 拥有所有权、借用和切片概念，在编译时保障了内存使用的安全。\nRust 提供了类似于其他编程语言对于管理内存使用的的方式，但数据的拥有者会在其离开作用域时自动清空数据。\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-07-10-rust-01/","summary":"\u003cp\u003erust 语法融合了多门编程语言的特性，可以看到很多语言的影子，例如 JavaScript、Java、Python、C、Go 等。\u003c/p\u003e","title":"Rust语法学习-类比其他编程语言"},{"content":"关于 Figma Config 2023 后半部分“开发模式”演讲的总结\nReady for dev 解决痛点：开发找错设计稿\n以往是如何解决的？在页面名称上标清哪些是草稿，哪些是定稿的，这里的”定稿“也就是所谓的”ready for dev，准备好用于开发“。\n开发模式下页面默认仅展示准备就绪的设计稿，其他未就绪的页面默认收起，这里突现了”保持简洁，仅展示必要的信息“的原则，也是一款优秀软件应该遵守的设计原则。\n变更对比 功能价值 作为开发，最先想到的就是code diff。因为在实际生产中，每个变更都应该是小心翼翼的，因此当你变更一段代码时，理应通过diff工具对改动前后的代码进行逐行确认，确保你的这次变更足够合理。\n相似功能 其实变更对比这件事如今已经被应用到很多场景了，比如 jira 文档更新的版本对比、云文档的变更记录等，能够使用对比工具直观看出一次改动所带来的具体差异，对于操作者来说是能够使其更加坚定进行保存的信心来源。\n功能分析 figma 这次做的是对一个文件进行两个版本的左右对比，形式有点像”找不同“游戏。但对于图片的差异比较，基本也只能做到这个程度。然而真的仅此而已吗？当然不，figma 总能给人惊喜。它还提供将两个版本进行重叠的方式进行差异对比，因为图片是二维内容，左右对比对于一维的文本内容来说可能足够，但对于图片的差异对比如果要依赖人的肉眼去”找不同“，还是有点费力的。\n此次对于版本对比体验的提升，像极了 上篇 中提到的原型同屏预览，同样是对既有功能的体验提升。就版本对比来说，相比原本的历史版本切换，实在进步了不少，因为比起完整查看新的版本或历史版本，人眼对于细微差异往往是难以察觉的，因此原本的历史版本功能显得并不实用。\n此外，figma 更进一步，既然两个版本的差异已经能够呈现在页面上，那么应用本身一定是具有两个版本之间差异的完整信息，那么何不直接把这些信息暴露给用户呢，这个场景的用户即是开发者，开发者最希望看到更多的细节。\n差异信息体现在图层属性的新增、修改和删除，这些变化仿佛就在扮演着以往协作场景中设计师角色，以往设计师可能需要亲自口头告知或通过额外维护一个文档来传达 TA 最新发生的修改具体是什么。\n功能延伸 “寻找差异”这种方式无论放在哪个领域，往往都是更高效的对比方式。\n这里举一些运用”差异“思维的应用实例，比如云计算的基础是在云端存储大量数据，而对于同一份数据，可能每时每刻都在发生变化，如果想全量存储这些数据在不同时间的状态几乎是不可想象的成本。因此早在云计算诞生之初，人们就想出”差量“备份的思路，对于数据不同时间的存储，仅存储其和相邻前一个版本之间的差异，然后在调取历史版本时，通过当前版本以及此前发生过的所有变更来计算出原始的状态。这样虽然牺牲了一点历史版本查看的性能，但却节省了大量的存储空间去存放那些相同的数据。\n那么既然谈到云存储，自然可以想到 MacOS 的时间机器功能，它可以为你保存电脑数据在某一时刻的”快照“，当你想让电脑恢复至某一个历史时刻，你就可以像搭乘”时间机器“一样回到过去的某个时刻。这个功能显然也会利用”差量备份“的方式进行历史版本存储，否则你的时间机器对于电脑的磁盘占用将会是版本数乘以某一个时刻的存储占用那么多。\n还有最经典的 Git 工具，它是用于管理代码历史版本的工具，记录着开发者每一次提交记录的差异，从而可以回看所有的历史提交。这样仅仅通过记录每次的改动差异就能形成一个代码仓库的完整历史，不得不说”差异对比“思想绝对算得上是存储算法中的核心基石。\n那么回到 figma 这款设计工具，其实从这次上线的版本对比功能来看，figma 大概率之前也是对文件历史版本进行”差异“保存的，只是直到现在才把这个原本用于开发实践的思想搬到用户眼前。\n图层检查增强 这个改动对于开发者来说确实更加深入人心，因为前端工程师往往对于一个在浏览器中访问的 web 应用进行调试时，通过工具看到的也会是所有图层在同一层（当然也有例外，比如绝对布局会在垂直轴上产生新的的”层“）。但大多时候，我们调试网页时看到的是如下的效果\n虽然在实际的 HTML 中，元素是一层一层的，但当元素被渲染成页面时，内容仍然是一块一块的。因此当我们调试每块内容的样式属性时，我们并不希望发现它们竟然有层的关系，甚至我们还需要通过双击某一层来进到”下一层“，因为单击某个图层在设计模式下将会是”选中图层“的效果。\n图标导出 这也是之前设计模式下”反效率“的一个点，在线设计工具原始图稿信息丰富虽好，但对于图标导出可能并不友好。如果开发者选中了错误的图标容器，导出的可能会是缺失图层的图标或是包含多余边距的图层。\n这些以往对于开发人员造成困扰的多余信息将在开发模式下消失，从此对于图标图层，在开始模式下仅会有一个可选中对象，那就是图标本身。这样的一个细小变化，对于图标、切图这类标准化的交付场景将会是一个 SOP 级别的提升。\n元素单位选择 这让我想起了微信小程序开发工具，因为小程序应用不同于 web 应用，web 的运行环境是浏览器，而小程序应用的运行环境是 APP。因此 web 应用内使用的单位是交给浏览器理解的，因此常见的单位是 px、百分比、rem/em 和 vw/vh。但小程序运行时实际在使用手机操作系统的渲染器进行元素绘制，但移动端设备的种类太多，因此小程序需要自定义一套元素单位。\n这里 figma 支持了元素大小单位的选择，是拓展了其设计支持能力的边界，因为设计交付的场景既可能是网页，也可能是手机 APP 甚至小程序，能够适应不同应用类别下的单位选择。\n组件 playground 这像是把 storybook 的一部分功能搬进了 figma 的弹窗，从此团队对于组件库的维护不再限于设计师单方面创造和维护。开发人员在开始模式下可以共享设计师对于组件信息的管理，这一能力有望打破原本对于组件库这一资产在设计师和前端开发之间的重复劳动。\n因为 playground 对于组件实现了不同 token 下的视觉预览，而不再是枯燥无味的组件名。这种对于组件的维护方式可以直接提高前端开发人员在 figma 页面的停留时长，因为从此对于团队资产不再需要另外打开一个网站或者文档去看它的具体参数和信息了。\n开发资源 这是一个小功能，但也让团队资产管理更加完整，因为在今天，互联网团队对于资产的管理本就是一半在本地一半在云上。在云上的部分可能是各个 web 服务下的组合，比如设计稿存储在 figma 账号中，而组件库代码则是维护在 gitlab 或 github 上。\n代码片段增强 从前的代码展示在标注模式下，而如今因为有了开发模式，因此代码标注信息将以更加接近开发者的使用方式呈现。比如按照前端开发中的 BEM 原则，布局、样式和修饰符在 CSS 中应该进行清晰的区分，这样才更有利于构建复杂的 UI，而 figma 显然是懂这一点的。\n对于这些细节的改动，每一个单点看起来可能都不起眼，但汇聚在一起，就是对于使用体验的整体升级，让使用者真正感受到工具的“趁手”。\n开发模式插件 D2C是 web 应用发展衍生出的交付形态——design to code，设计图转代码。这在此前被认为是一种理想的交付形态，因为这节省了开发人员还原设计稿的时间，从而可以快速将设计稿直接转换为可部署的网页形态。但随着近几年 web 技术发展的成熟，一些实践使得这项技术成为可能（比如微软之前提出的sketch2code，草图生成代码）。\n而 figma 将插件功能集成到开发模式下的代码标注区域，是一次将设计稿转代码片段的尝试。因为代码不同于样式信息，使用代码描述组件，可以使得其具有更好的拓展性和复用性。因此如果能够根据设计稿信息给出组件的代码片段，那么后续开发模式就可能发展成 Low Code 工具。\n看似又一个平淡无奇的尝试，实则孕育着更多的可能性和产品形态延展。\n补充阅读：Anima 是什么？https://www.animaapp.com/\nVS Code 插件 如果你是一名开发者，你才会明白，开发者在工作时并不想离开 IDE 环境。一切能在 IDE 完成的事情，不应切换窗口去到其他地方。因为在开发环节，程序员需要保持聚焦，否则思路可能会被打断。因此，IDE 市场才会有众多插件满足开发者在 IDE 内满足大多事情。\n详见 VS Code 插件市场：https://marketplace.visualstudio.com/vscode\nFigma 做了相应的 VS Code 插件，可见它是尊重开发者使用习惯的，如果能在 IDE 内访问 Figma 文件，何乐而不为呢？更何况 IDE 不仅是开发工具，也可以是基本的文件编辑器，当使用 VS Code 管理自己的 Figma 文件时，仿佛就像是在本地文件夹管理你的设计文件，并且它还是支持查看设计文件中的标注信息，这是基于 VS Code 支持直接在其内部打开 web 应用的能力，就像使用浏览器一样。\n另外，Figma for VS Code 还支持在代码编辑时提示当前文件页选中的图层样式，从而实现一键代码填充。这样的开发体验非常接近现有的编程辅助工具，比如 tabnine 和 copilot，但这类工具大多依赖 AI 进行代码提示，也就是它们提供的虽然是可用代码，但并不是符合团队共用的“标准代码”。而 Figma 的样式提示能力则大概率是通过 Typescript 的类型推导能力实现的组件样式映射，也就是对于同样的样式属性，所有人提示的代码均是与设计稿严格保持一致的标准代码。\n小结 开发模式的诞生，意味着 figma 将“一人分饰两角”，在同一款软件内实现两种生产角色的同等使用体验。而做到这一点的推动力是因为 figma 的用户画像——设计师与开发者用户量 1:1，这样来看，figma 推出开发模式既艰难又合理，但对于同类软件却是一个值得慎重考虑的事情，因为并不是所有软件都具备同样的痛点。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-07-03-figma-config-2023-02/","summary":"\u003cp\u003e关于 Figma Config 2023 后半部分“开发模式”演讲的总结\u003c/p\u003e","title":"Figma Config 2023 观后感下篇——开发模式"},{"content":"关于 Figma Config 2023 的一些总结和所思所想\n视频源：https://config.figma.com/\n开场动画信息点 颜色 token 有序列表 AI 文本校对 黏性吸顶布局（CSS sticky position） 多样式文本（粗体、斜体同行显示） 区域选择（区别于容器和图层，新增了 section 概念） 用户回馈 社区感谢 教育推广 chrome book 合作 adobe 收购事件 拥抱 AI 服务场景 Stages\nBrainstorm（创意头脑风暴） Design（设计环节） Build（生产构建环节） 变量 Variables rather than Design Tokens\n变量支持四种类型\n数字 字符串 颜色 布尔 作用范围 变量设置中可以定义变量的作用范围（针对哪些属性，比如圆角、宽高、间距、文本）\n变量设置框里有一个“即将上线”的功能——代码高亮\n以上提供的能力已经可被用于建立设计系统，那么接下来我们看看变量可以有哪些应用\n应用场景 场景 1：颜色模式 和变量同级别的设置项还有”颜色模式“，有点像颜色选集，但更像 web 应用中换肤功能所对应底层定义，也就是每套皮肤（主题）所使用的颜色定义组合\n但这不止像演示中所呈现的亮暗色模式下的颜色定义，很明显它支持定义更多套的主题色配置，每套配置都在使用相同的颜色变量，但每个变量在每套主题下使用的颜色是不同的，这有点像 design tokens，但确实更接近于主题色的定义，因此这个配置项区别于变量，单独成为一个配置框完全合理\n一旦定义好不同颜色主题的配置，在容器级别的图层选择 Color modes，即可轻松实现快捷的”一键换肤“效果。\n相比传统设计场景需要针对不同颜色主题需要提供多套设计，这一改变将使得设计师和前端工程师的使用效率都大大提高，想必当前端还原设计稿时也希望直接在同一个容器看到它在不同颜色模式下所对应的标注信息。\n而这一切都是因为变量作为基础，所以产生了更简洁的呈现方式。正如编程语言中，借助变量在不同的场景下具有不同的值，从而使得程序在运行时拥有更多的变化\n场景 2：布局密度 对于列表类的布局，通过对变量定义不同模式下的值，可以直接应用在图层的排布密度属性上。当你定义了多套模式后，在设计稿中可以通过切换不同的模式查看同一个布局在不同密度下的视觉效果，这是不是解决了设计师常常反复调整元素间距以对比哪个效果更好的痛点呢\n场景 3：国际化（多语种） 如果你要做一款国际化的产品，需要考虑设计稿在不同语种下的视觉体验是否一致。同样是借助变量，你可以直接定义多套语言模式，同一个词汇在不同语言模式下使用其对应语言的字符，然后同样在图层的”本地化“属性下进行”一键切换“。\n这里从开发视角补充一点，其实国际化功能在实现环节也是通过类似变量的方式定义同一个词汇在不同语言下的字符定义，因此将变量能力带到设计环节，其实是对设计到实现的整个协作流程效率的提升，因为在设计环节的很多”动态定义“从此可以与开发人员共享了。\n简单来说，就是从前对于多语种的展示，可能只有开发人员在维护，设计人员可能需要到开发的实现环节才能体验不同语种下的展示效果，或者设计师需要创建多套设计稿来展示同样的内容使用不同语言的呈现效果。但因为有了变量，设计师和开发人员完全可以共享同一套”多语言配置“，这难道不是协作效率的飞跃吗\n变量组合应用 如你所见，变量的魅力不止于此，一旦拥有变量，你可以更近一步，对他们进行组合使用。因为有了上面的颜色模式、密度模式和语言模式，从此你可以看到的不止是各个属性下不同模式的效果，而是各个模式的随意组合\n样式能力增强 最小宽度/最大宽度/最小高度/最大高度 这是前端 CSS 中一个很基本的属性，但到今天才被添加到设计工具内，算是补充了设计到开发环节的一个鸿沟。因为这里原本的痛点在于，设计稿往往对响应式设计依赖于做多套设计，而前端对于响应式的实现往往是通过最小/大宽度和最小/大高度属性在不同宽度/高度范围内定义不同的布局属性和元素宽高值，可见这个环节从前在设计环节和开发环节的实现方式是不一致的。\n自动布局功能对于设计与实现环节保持一致曾迈出了重要的一步，而最小/最大宽度和最小/最大高度功能则是补齐了响应式实现在设计到前端的另一块拼图\n换行属性 这是网页技术中实现多列布局响应式的关键属性，因为它决定了元素在限定的布局内当超出一行后应如何展示，也许你说使用网格布局可以做到同样的事情，但如果你想使用自动布局（对应前端的弹性布局），那换行属性必不可少\n原型 使用原型作为产品初始功能演示是很重要的，因为在它还没有被完整实现以前，可以快速地进行意见收集和改进。但对于一个功能复杂的应用，使用原型模拟出所有操作路径会很复杂，使用设计工具以往所提供的能力，原型中的步骤线可能会非常，因为你需要创建同一个页面在不同操作后的不同结果，因此最终原型内的关系会变得非常难以维护。\n原型+变量 如果依托变量能力，原型可以变得怎样呢？\n你可以为原型中使用到的状态定义变量，比如对于电商应用，你可以定义不同商品的名称、数量、价格等等。当定义完这些以后，你就像拥有了一个小型的数据库（数据库这个概念熟悉吗？Notion 的表格正是利用数据库方式存储表格数据，从而做到将同一个数据源以不同视图模式进行展示的效果）\n动作使用变量 交互属性内的动作使用变量\n比如当你点击某个元素时，你可以对变量的值进行更新，更新的值可以是在变量当前值的基础上增加计算逻辑，从而得到新的状态值。比如当你在购物车对某个商品点击加号时，理想的变化应该仅仅是商品展示的数量从 1 变成 2 即可，而使用以往的原型演示，这一效果可能需要拷贝一份容器，然后在新的版本内将数量改为 2。\n怎么样？感受到变量的力量了吗，因为有了变量，这个场景下的原型交互可以直接省去一个重复的容器去展示不同的状态，而仅仅是通过变量的变化来表达状态的变化\n原型预览 这是另一个工作流上的效率提升点，以往的原型预览是在一个新的标签页展示的，如今你可以直接在原型设计页面弹出一个和容器一样大的弹窗，直接看到一个像样机一样的页面呈现在你眼前，然后在此基础上进行调整。\n这一交互其实源自苹果应用的开发，熟悉苹果 App 开发的人应该知道，苹果官方提供了专用的工具用于开发苹果系列的产品，叫做 Xcode。当你在 Xcode 内运行代码后，就会在弹出一个独立窗体用于展示你的 App，然后你可以在不需要切换标签页的情况下直接预览到你应用此刻的效果，从而在此基础上进行调整。\n将这种交互应用在原型功能上，可以说是将原型使用者的体验与开发者更加接近了\n条件语句 这也是源自编程语言的理念，因为有了条件语句，你可以对逻辑增加条件判断，从而使逻辑走向不同条件下的分支。但看似简单的能力，却可以产生丰富的结果。\n用在原型场景，就是你原本对于不同元素的点击，下一步要展示的页面可能需要拷贝多份并做对应的修改才能达成。而使用条件语句，你可以对交互增加条件逻辑声明，当你点击商品列表中的苹果时，在跳转商品详情页时应该展示的是苹果的详情，包括苹果的价格和数量。\n当你在购物车将所有商品的数量减少为 0 时，页面应该展示空态，而这些判断都是通过条件判断所定义的\n未完待续，详见 下篇——开发模式\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-07-02-figma-config-2023-01/","summary":"\u003cp\u003e关于 Figma Config 2023 的一些总结和所思所想\u003c/p\u003e","title":"Figma Config 2023 观后感上篇——变量、原型"},{"content":"vuex@3 对比 pinia@v2\n版本信息 包名 版本号 vuex 3.6.2 pinia 2.1.3 API 解惑 为什么 mutations 内的对象第一个参数是当前模块的 state，第二个是 payload，并且 mutation 内部的 this 可以访问到 store 实例\n因为对于 mutations 的注册实现如下，mutations 是一个数组，每个元素是一个函数，也就是 mutation，当 mutation 被触发时，执行的即是handler.call(store, local.state, payload);\n这里 call 的第一个参数是执行 handler 的上下文，也就是其内部访问的 this。后面的参数会是 handler 执行时的入参，local.state 对应一个 mutation 方法的第一个参数，payload 是第二个参数\nfunction registerMutation(store, type, handler, local) { var entry = store._mutations[type] || (store._mutations[type] = []); entry.push(function wrappedMutationHandler(payload) { handler.call(store, local.state, payload); }); } 为什么 actions 内的对象第一个参数可以解构出 dispatch 方法用于调用其他 actions，可以解构出 commit 用于调用 mutation，可以解构出 getters 和 state 用于访问当前模块的状态，可以解构出 rootGetters 和 rootState 用于访问 store 根模块下的 getters 和 state\n为什么 action 一定返回 Promise\nfunction registerAction(store, type, handler, local) { var entry = store._actions[type] || (store._actions[type] = []); entry.push(function wrappedActionHandler(payload) { var res = handler.call( store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state, }, payload ); if (!isPromise(res)) { res = Promise.resolve(res); } if (store._devtoolHook) { return res.catch(function (err) { store._devtoolHook.emit(\u0026#34;vuex:error\u0026#34;, err); throw err; }); } else { return res; } }); } 如上，actions 一个是数组，而且每个元素是一个方法，方法执行时的上下文是 store 实例，第一个参数是一个对象，里面包括 dispatch、commit、getters、state、rootGetters 和 rootState，可按照需要解构出其中的内容进行调用。如果需要调用其他 action，则使用 dispatch，如果调用 mutation，则使用 commit，如果需要访问当前模块的状态则使用 getters 或 state，如果需要访问根模块的状态则使用 rootGetters 或 rootState\n最终 action 的执行结果如果不是 Promise，也会经过 Promise.resolve 来生成一个 Promise 用作返回，保持返回值是 Promise 的一致性\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-06-28-vuex-vs-pinia/","summary":"\u003cp\u003evuex@3 对比 pinia@v2\u003c/p\u003e","title":"vuex对比pinia"},{"content":"WebAssembly 是什么\n以下均以 wasm 表示 WebAssembly\nwasm 是什么？ wasm 是一种新的二进制形式机器码，专门被设计用于浏览器。\n优势 已有的应用程序当被编译为 wasm 格式后，在浏览器中运行起来可以和原生应用程序一样快\n在 wasm 出现以前 在浏览器不支持 wasm 时，一个 C++应用程序如果想运行在浏览器，需要使用 asm.js\n参考链接 https://blog.mozilla.org/en/mozilla/lots-new-in-firefox-game-changing-webassembly-support/ https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/ https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface ","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-06-21-wasm/","summary":"\u003cp\u003eWebAssembly 是什么\u003c/p\u003e","title":"关于WebAssembly"},{"content":"CSS Selector 30 种常用选择器 选择器分类 两个类选择器中间有无空格的区别 CSS flex flex flex-grow:：伸长以吸收 flex 容器中剩余的可用空间(available space) flex-shrink：收缩以适应 flex 容器 flex-basis：flex 元素在主轴方向上的初始大小（可为元素width属性的任意有效值） flex 值 initial flex-grow: 0 flex-shrink: 1 flex-basis: auto 不伸长去吸收额外空间，会缩短以适应容器\nauto flex-grow: 1 flex-shrink: 1 flex-basis: auto 会伸长去吸收额外空间，会缩短以适应容器\nnone flex-grow: 0 flex-shrink: 0 flex-basis: auto 失去弹性，不伸长也不收缩\nflex-flow 用于同时定义flex-direction(主轴方向)和flex-wrap(元素换行)的简写\nflex-direction row(默认值) row-reverse column column-reverse flex-wrap nowrap(默认值) wrap wrap-reverse align-self 用于定于元素（相对于交叉轴的）对齐方式\nalign-items 用于将元素定义为一个组并一同声明元素对齐方式\nflex-start flex-end center justify-self 用于定义元素（相对于主轴的）两端对齐方式\njustify-content 用于将元素定义为一个组并一同声明组该组元素整体（也就是内容）的两端对齐方式\nspace-between flex-start center flex-end space-around CSS box model | 盒模型 https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model#border-area\nCSS color function hsla hsla(H, S, L[, A])\nH - hue(色彩) red - 0(deg) / 360(deg) green - 120(deg) / 480(deg) blue - 240(deg) / -120(deg) S - saturation(饱和度) 100% - white（completely saturated，完全饱和） 0% - gray（completely unsaturated，完全不饱和） L - lightness(亮度) 100% - white 0% - black 50% - \u0026ldquo;normal\u0026rdquo; A - alpha(透明度) 0% - transparent（完全透明的） 100 - full opacity（完全不透明） ","permalink":"https://barnett617.github.io/wilson-blog/notes/2023-07-11-css-basic/","summary":"一些CSS基础知识学习和整理","title":"CSS基础知识"},{"content":"What\u0026rsquo;s the difference between hasOwnProperty method and \u0026ldquo;in\u0026rdquo; operator Key point For inherited properties, in will return true and hasOwnProperty will return false.\nExample const obj = {}; console.log(\u0026#39;constructor\u0026#39; in obj); // true console.log(obj.hasOwnProperty(\u0026#39;constructor\u0026#39;)); // false Reference https://masteringjs.io/tutorials/fundamentals/hasownproperty What\u0026rsquo;s the difference between Object.assign and just assign Key Point For single property, direct assignment is good. For multiple properties, Object.assign is nicer.\nReference https://stackoverflow.com/questions/35241790/difference-between-object-assign-and-just-assign How does the second parameter of parseInt method works Key point When using parseInt, the second parameter should be explicitly declaring for some reasons parseInt() will use the second parameter as the radix(base) to parse a string to integer The first parameter(default parameter) should be a string, or it will be transformed into a string by toString method The second parameter should be between 2 and 36 as a valid radix, otherwise the method will return NaN if the second parameter is number but out of valid scope([2,36]) or it will be ignored if not a number The method will return NaN if parsing fails Example All examples below will get the answer 15.\nparseInt(\u0026#34;0xF\u0026#34;, 16); // Because the string starts with \u0026#34;0x\u0026#34; and \u0026#34;F\u0026#34; is valid hexadecimal number, so it will be parsed into integer with the radix 16 parseInt(\u0026#34;F\u0026#34;, 16); // Because the second parameter is a valid hexadecimal number and the first parameter is a valid hexadecimal string, it works parseInt(\u0026#34;17\u0026#34;, 8); // \u0026#34;17\u0026#34; is parsed into integer with 8 as radix -\u0026gt; 8 + 7 = 15 parseInt(021, 8); // (This maybe confused) Because the first parameter is a number rather than a string, it will be transformed into a string first using toString method. (021).toString() -\u0026gt; 2 * 8 + 1 = 17 =\u0026gt; \u0026#34;17\u0026#34;, then it is the same to the last example parseInt(\u0026#34;015\u0026#34;, 10); // Because the second parameter is 10, the first character \u0026#34;0\u0026#34; will be ignored parseInt(15.99, 10); // 15.99 will be transformed into valid string \u0026#34;15.99\u0026#34;, then the parsing process will terminate when meeting the first invalid string, the dicimal point(\u0026#34;.\u0026#34;) parseInt(\u0026#34;15,123\u0026#34;, 10); // The parsing process will terminate when meeting the invalid character, the comma parseInt(\u0026#34;FXX123\u0026#34;, 16); // (This maybe confused) Because the second parameter is a valid radix(16), the parsing process will proceed correctly until meeting the first invalid character(\u0026#34;X\u0026#34;) then terminate parseInt(\u0026#34;1111\u0026#34;, 2); // 2^3 + 2^2 + 2^1 + 1 =\u0026gt; 8 + 4 + 2 + 1 =\u0026gt; 15 parseInt(\u0026#34;15 * 3\u0026#34;, 10); // \u0026#34;15\u0026#34; is a string that can be parsed into a valid number and the spaces will be ignored during parsing process but terminates when meeting the invalid character \u0026#34;*\u0026#34; parseInt(\u0026#34;15e2\u0026#34;, 10); // The same as the above example except the first invalid character is \u0026#34;e\u0026#34; parseInt(\u0026#34;15px\u0026#34;, 10); // The first invalid character is \u0026#34;p\u0026#34; parseInt(\u0026#34;12\u0026#34;, 13); // 13 * 1 + 12 =\u0026gt; 15 Reference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt ","permalink":"https://barnett617.github.io/wilson-blog/en/posts/2023-07-11-js-basic/","summary":"Some basic JavaScript things","title":"JavaScript Basic Points"},{"content":" 本文为历史博客迁移\n首先应该先弄清楚闭包是什么，感觉这个词从字面意思上进行切入会越看越浑。\n我只能强行理解为某某某明明已经闭合了，却又包含着什么东西。诶？感觉好像有内味儿了。闭包不正是函数在其返回以后（理论上来说已经闭合）还能访问到函数内部的变量（包含对函数内部作用域的引用）么。\n词法作用域 那么什么是词法作用域呢，就是根据声明变量的位置来确定变量可以发挥作用的域。\n比如一个变量声明在全局，那它在全局作用域就是有作用的，可以被访问也可以被修改的，而操作它的时候，就要找到它的主人，也就是全局对象。\n又比如一个变量声明在一个函数内，那它可以作用的域（范围）就是这个函数内。\n特殊一点的是函数内嵌套函数，由于内部的函数是在外部函数的作用域内的，所以内部函数可以访问到外部函数中的变量，例如：\nfunction outer() { var a = 2; function inner() { console.log(a); } inner(); } outer(); // 2 其实这里面是存在一个过程的，正如js拥有原型链一样，作用域也存在一条链。\n当inner被调用的时候要访问一个叫a的变量，在inner作用域没找到，就会循着其作用域链向上找，它的上一层是outer作用域，然后在outer作用域找到了a，于是打印出来。\n闭包 那么闭包的存在导致了一个什么事呢，它好像打破了作用域的规律。例如：\nfunction outer() { var a = 2; function inner() { console.log(a); } return inner; } var inner = outer(); inner(); // 2 outer先被声明，其内部声明了一个变量a和一个函数inner。\n这两个东西理论上来说只属于 outer 函数内部（也就是仅供内部员工使用），像是私有的。\n但是函数有权利定义自己的返回值，而函数这个东西在js中又被认为是“一等公民”，也就是说它和变量什么的是平起平坐的。\n函数可以返回一个变量，当然也可以返回一个函数，同时函数可以接受变量作为参数，也可以接受函数作为参数。\n所以这里outer就把 inner 函数返回了，重点是 inner 做了什么事呢，它里面在访问不属于自己却属于 outer 作用域的变量 a，这么一来这个 return inner 仿佛就在 outer 内部和其外部之间打了一个秘密通道。\n导致结果有两个：\nouter 作用域内的变量被泄露到作用域外部； outer 作为一个函数，在 return 后理应释放占有的内存，也就是其内部声明的变量回被回收。 但这样一来，由于outer返回的是一个函数inner，而inner还在引用这个a，导致 a 无法被回收。更重要的是，最终在全局作用域调用inner时真的访问到了a，但a明明不存在于全局作用域。\n按照作用域链的规则，当访问一个变量时，如果在当前作用域访问不到，会向上找。但此时已经是全局作用域，如果找不到就应该返回 undefined 了。但这里却得到 2，可见父作用域（全局作用域）访问了子作用域（outer）的变量，即是由于闭包的存在打破了阴阳两界（嵌套作用域之间的关系）。\n代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/3-closure/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-closure/","summary":"关于JavaScript闭包原理的学习","title":"JavaScript闭包学习"},{"content":" 本文为历史博客迁移\n首先我们应该承认，promise的确是一个大话题，因为毕竟是 es6 才出现的东西，融合了很多 js 既有特性，比如【函数作为参数传入另外的函数】、【使用 bind 强制绑定 this】、【使用原型对象 prototype 添加方法】等。\n再到promise的应用层面，需要了解【promise 的实现原理】、【如何实现 A+标准的 promise】以及【promise 与其他异步方式混用】的变态面试题等等，我们能挖到几层算几层\n首先，同js中大多成员一样，promise也是一个对象，是一个函数返回的对象。\n那么promise是怎么得来的呢，是由Promise构造函数生成的。\n为什么要有promise这东西呢，是为了处理异步行为。\n如果你有一个异步操作，可以把它放到Promise构造器里来获得一个promise实例，拿着这个实例你就相当于拿到了一份“承诺”，当异步事务处理结束后，你手中的 promise 实例便有了结果，而且这个结果是确切的、不会变的，要么成功，要么失败，你可以根据拿到的结果做后续操作。\n既然 Promise 本质上是对象，那我们看看它的属性和方法分别有什么。\nPromise 对象的属性和方法 属性 length（永远为 1） prototype 方法 all race reject resolve Promise 的原型 属性 constructor 方法 catch then finally 创建 Promise 创建 Promise 需要给构造函数传一个执行器，执行器中需要包括两个回调函数，一个是当异步操作成功后进行的回调，另一个是失败时接收的回调。\nvar promise = new Promise((resolve, reject) =\u0026gt; { var result; // result = 异步操作 if (result === \u0026#34;success\u0026#34;) { resolve(); } else { reject(); } }); var executor = function (resolve, reject) { var result; // result = 异步操作 if (result === \u0026#34;success\u0026#34;) { resolve(); } else { reject(); } }; var promise2 = new Promise(executor); 实际应用 var promise = new Promise((resolve, reject) =\u0026gt; { try { setTimeout(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); var endTime = new Date(); resolve(endTime); }, 0); } catch (e) { reject(e); } }); promise.then( (data) =\u0026gt; { console.log(\u0026#34;success: \u0026#34; + data); }, (err) =\u0026gt; { console.log(\u0026#34;fail: \u0026#34; + err); } ); // done // success: Sat Apr 25 2020 11:26:10 GMT+0800 (GMT+08:00) var executor = function (resolve, reject) { try { setTimeout(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); var endTime = new Date(); resolve(endTime); }, 0); throw new Error(\u0026#34;oop\u0026#34;); } catch (e) { reject(e); } }; var promise = new Promise(executor); promise.then( (data) =\u0026gt; { console.log(\u0026#34;success: \u0026#34; + data); }, (err) =\u0026gt; { console.log(\u0026#34;fail: \u0026#34; + err); } ); // fail: Error: oop // done 链式调用 // 这就叫链式调用(统一收敛异常捕获) doSomething() .then((data) =\u0026gt; { return doSomethingElse(data); }) .then((data) =\u0026gt; { return doThirdThing(data); }) .then((data) =\u0026gt; { console.log(\u0026#34;All well done: \u0026#34; + data); }) .catch(failureCallback); function doSomething() { return new Promise((callback, error) =\u0026gt; { try { setTimeout(() =\u0026gt; { console.log(\u0026#34;something done\u0026#34;); callback(\u0026#34;a\u0026#34;); }, 0); } catch (e) { error(e); } }); } function doSomethingElse(result) { console.log(result); return new Promise((callback, error) =\u0026gt; { try { setTimeout(() =\u0026gt; { console.log(\u0026#34;something else done\u0026#34;); callback(\u0026#34;b\u0026#34;); }, 0); } catch (e) { error(e); } }); } function doThirdThing(result) { console.log(result); return new Promise((callback, error) =\u0026gt; { try { setTimeout(() =\u0026gt; { console.log(\u0026#34;third thing done\u0026#34;); callback(\u0026#34;c\u0026#34;); }, 0); } catch (e) { error(e); } }); } function failureCallback(e) { console.log(\u0026#34;error: \u0026#34; + e); } // something done // a // something else done // b // third thing done // All well done: c 代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/5-promise/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-promise/","summary":"关于JavaScript Promise原理的学习","title":"JavaScript的Promise学习"},{"content":" 本文为历史博客迁移\n我们先看一下MDN对于this的定义：this 值是当前执行代码的环境对象\n其中有几个关键词需要捕捉：【当前】、【环境】、【对象】\n如果不能彻底搞清js中this的机制，可能js使用者只能用两种方式和它打交道：\n【1】是记住this的四种场景 【2】是使用js所提供的手段来使this指向变得可控\n四种场景 一、全局环境 如果在全局执行环境使用this，那它毋庸置疑是在指向全局对象，至于这个全局对象具体值是什么，要决定于环境。比如在浏览器中的全局对象是window，在nodejs环境中却又叫作global。\n不过现在js有了无视环境的统一调用全局this的方式，即一个叫作globalThis的对象，其在不同的环境下就是不同环境所对应的全局对象。\n二、函数环境 非严格模式全局环境直接调用函数\nvar func = function () { console.log(this); console.log(this === globalThis); // true }; func(); 严格模式全局环境直接调用函数\nvar func = function () { \u0026#34;use strict\u0026#34;; console.log(this); // undefined }; func(); 那么这里要提到另外两个知识点：apply 和 call，它们可以把 this 的值从一个环境传到另一个环境，为什么要有这样的东西呢，或者说怎么理解它们的存在呢。举个例子：\nfunction say() { var intro = \u0026#34;hello world\u0026#34;; console.log(this.intro); } say(); // undefined var tom = { name: \u0026#34;Tom\u0026#34;, intro: \u0026#34;Hello, I am Tom\u0026#34;, }; var jerry = { name: \u0026#34;jerry\u0026#34;, intro: \u0026#34;Hello, I am Jerry\u0026#34;, }; say.call(tom); // Hello, I am Tom 我们来品一品这个例子，现在我们想弄清楚这样几件事情：\nthis 是什么来着？ 为什么要用 this call 是干嘛的 不用 this 怎么办 this 是什么来着？ 首先，this是什么来着？当前执行代码的环境对象，我们可以简记为当前环境（也有其他地方专业称呼其为执行上下文，但那样很明显不利于理解）\n为什么要用 this 接着，我们为什么要用this。当然就是因为它的定位，它是js提供给我们在任意地方获取当前环境的一个对象。听起来它好像是一个动态的对象，在任何时候你想要访问当前环境都能通过它拿到。js不是有着复杂的各种关系链么，什么原型链啊，作用域链啊，各种嵌套关联，会让你觉得乱糟糟的，但是this永远都保持着自己明确的定位，无论你所处怎样复杂的关系链中，它都能给到你当前环境。\n这样看来，我们是不是应该重新认识this，抛开以前的偏见，它其实是js提供给你的一个工具，而不是为了把你弄晕的。\n我们拿这个例子说明，有一个打招呼方法叫say，它输出的是当前环境的自我介绍，这是say方法的声明内容，但这里只是声明了这个函数是做什么的，具体它输出的是什么，还得看函数执行时的当前环境是什么。比如直接执行，那么当前环境是什么，是全局。全局对象没有自我介绍intro，所以输出的就是undefined。\ncall 是干嘛的 那么，call是干嘛的？上面说了，它是用来将this的值从一个环境传到另一个环境的。听起来还是有点晦涩难懂，但感觉上好像做了偷梁换柱的事情，有点闭包里提到的打破阴阳两界的味儿了。\n那么我们结合例子看看能不能探究一下call是做啥的，say.call(tom)输出了tom的自我介绍，诶？首先，我们拿到了say方法的输出，说明say方法被执行了，但是say.call(tom)没有看出say方法的执行，说明在say.call内部执行了say方法。另外，执行结果表示执行say的时候当前环境是tom，因为say的功能是输出当前环境的自我介绍嘛，Hello, I am Tom是 tom 的自我介绍，这不就等同于当前环境 = tom吗。\n于是我们探究出say.call(tom)做了两件事情：\n执行了say方法 执行say方法时的当前环境是tom 这就是call干的事情。\n不用 this 怎么办 那么最后，如果不用this，有没有别的方法达到同样的效果。我们很自然会想到通过给函数增加参数，来获取外部信息，连通函数内外部，在函数内访问函数外的变量。如下：\nfunction say(intro) { console.log(intro); } say(); // undefined var handler = say; handler(); // undefined var tom = { name: \u0026#34;Tom\u0026#34;, intro: \u0026#34;Hello, I am Tom\u0026#34;, }; var jerry = { name: \u0026#34;jerry\u0026#34;, intro: \u0026#34;Hello, I am Jerry\u0026#34;, }; say(tom.intro); // Hello, I am Tom 虽然输出结果和上面一样，但这样好像总是差点味儿。既然存在this这样的东西，那么一定有它的道理，我们看看有没有什么this不可取代的地方。\n首先，函数的功能变掉了，原来的函数是“输出当前环境的自我介绍”，现在是输出“入参的自我介绍”，原来的输出决定于函数调用时的当前环境，现在变成传参就有结果，不传就没结果。\n另外，对比say.call(tom)和say(tom.intro)，之前传给call的是一个对象，函数会自动从对象中取出intro，因为输出的是当前环境的自我介绍，即this.intro，那么传入的对象便是this。但say(tom.intro)传入的则需是自我介绍本身，因为say函数输出的正是参数本身。\n这样看来，使用参数的函数是不是相较于使用this的要有失灵活一些，this虽包含着不确定性，但是却能灵活“动态”地提供当前环境。相比之下，函数传参是更加充满确定性和可控性，函数输出能够一眼看出来龙去脉的。对于二者的使用当然是要“因地制宜，择优录取”。\n最后我们做一个对于call的总结，我们可以巧妙地理解其为以下几点：\ncall 是函数对象才有的方法（因为call是调用的意思，函数才能被调用） call 也是打电话、招呼的意思，所以func.call(obj)可以理解为函数func呼叫obj来应援 func找obj应援，obj自然会成为“座上宾”，所以 func 被执行时的当前环境就是obj 当前环境（this）是一个对象，所以call的参数应该是一个对象，所以这里用obj来表示 三、对象方法被调用 当函数作为对象的方法被调用时，this 即是调用方法的对象。例如：\nvar obj = { name: \u0026#34;obj\u0026#34;, sayHello: function () { console.log(this.name + \u0026#34;\u0026#39;s method says hello\u0026#34;); }, }; function sayHello() { console.log(\u0026#34;funciton declaration says hello\u0026#34;); } var exp = function () { console.log(\u0026#34;function expression says hello\u0026#34;); }; obj.sayHello(); sayHello(); exp(); // obj\u0026#39;s method says hello // funciton declaration says hello // function expression says hello 这里也就区分了函数和方法叫法的区别，函数就是通过函数声明或函数表达式声明的普通函数，而叫作方法是因为函数作为对象的一个属性而存在（函数在 js 被认定为一等公民，可以同变量一样作为属性、参数、函数返回值等）\n四、new 使用new调用函数时，是把函数当作构造函数在调用，此时的this会指向构造出来的新对象（实例）。例如：\nfunction classA() { this.from = \u0026#34;A\u0026#34;; } var instance = new classA(); console.log(instance.from); // A 这里函数内部在操作this并向其添加属性from，然后使用new调用，则执行函数classA时，其内部的this即是instance，于是instance便在诞生之初就有了from属性。\n原生提供的可控方法 bind 既然每次函数执行时的当前环境都可能变化，充满着不确定性，那么有没有什么办法把它捆着不动，那就是bind方法，bind意为“绑定”，其效果也如其名，一旦绑定，不会再被修改。但bind方法很明确自己的任务只是绑定当前环境，至于函数何时执行、怎么执行不归其管，这区别于call和 apply 在指定了当前环境后还把函数执行了。\n我们需要记住bind的特性只有两个：\n一经绑定，不再修改 只作绑定，不会执行 实例如下：\nfunction func() { console.log(this.intro); } var tom = { name: \u0026#34;Tom\u0026#34;, intro: \u0026#34;I am Tom\u0026#34;, }; var jerry = { name: \u0026#34;Jerry\u0026#34;, intro: \u0026#34;I am Jerry\u0026#34;, }; var tomFunc = func.bind(tom); var jerryFunc = tomFunc.bind(jerry); tomFunc(); // I am Tom jerryFunc(); // I am Tom 箭头函数 先看 MDN 中关于箭头函数的“权威解释“：”在箭头函数中，this 与封闭词法环境的 this 保持一致“，虽然言简意赅，但是晦涩难懂且包含专业名词，什么是”封闭词法环境“？？\n我们先来捕捉一些箭头函数的特性，然后从其特性推断出其是一个怎样的东西\n没有自己的 this 指针 不能用作构造器 没有 prototype 属性 不绑定 Arguments 对象 没有自己的 super 其实把”箭头函数的 this 与封闭词法环境的 this 保持一致“转而描述为”箭头函数的 this 总与其被创建时的环境一致“会更好理解一点。举例如下：\nvar globalObject = this; var foo = () =\u0026gt; this; console.log(foo() === globalObject); // true // 接着上面的代码 // 作为对象的一个方法调用 var obj = { foo: foo }; console.log(obj.foo() === globalObject); // true // 尝试使用call来设定this console.log(foo.call(obj) === globalObject); // true // 尝试使用bind来设定this foo = foo.bind(obj); console.log(foo() === globalObject); // true 总结一下箭头函数，谨记一点即可“当创建一个箭头函数的时候，就确定这个箭头函数的 this 和创建时所在作用域的 this 一致了”。\n附录 call 的模拟实现 call 的实现依赖如下：\n通过 this 获取调用 call 方法的对象（即要修改 this 的函数） 通过 arguments 获取调用 call 方法时传递的参数 通过 eval 动态解析字符串以实现修改 this 后的函数执行时访问 call 接收到的不确定参数 var tom = { name: \u0026#34;Tom\u0026#34;, func: function (type, desc) { if (type \u0026amp;\u0026amp; desc) { return this.name + \u0026#34; is a \u0026#34; + desc + \u0026#34; \u0026#34; + type; } else { return \u0026#34;Just \u0026#34; + this.name; } }, }; var jerry = { name: \u0026#34;Jerry\u0026#34;, }; var me = { name: \u0026#34;me\u0026#34;, }; var print = console.log; print(tom.func(\u0026#34;cat\u0026#34;, \u0026#34;big\u0026#34;)); print(tom.func.call(jerry, \u0026#34;mouse\u0026#34;, \u0026#34;small\u0026#34;)); print(tom.func.call(me)); // Tom is a big cat // Jerry is a small mouse // Just me Function.prototype.myCall = function (obj) { // 参数分别判空处理 if (!obj) obj = globalThis; // this是调用本函数的函数 obj.func = this; // 要换用指定的this(这里的obj)去执行要被执行的函数(func) // 并且传入指定参数(args) // 函数执行结果是返回函数的返回值 var result; if (!arguments[1]) { result = obj.func(); } else { var params = []; for (var i = 1; i \u0026lt; arguments.length; i++) { params.push(\u0026#34;arguments[\u0026#34; + i + \u0026#34;]\u0026#34;); } result = eval(\u0026#34;obj.func(\u0026#34; + params + \u0026#34;)\u0026#34;); // eval解析出的结果如：obj.func(arguments[1], arguments[2], ...) } delete obj.func; return result; // 执行结束要去掉新捆绑的属性 }; print(tom.func(\u0026#34;cat\u0026#34;, \u0026#34;big\u0026#34;)); print(tom.func.myCall(jerry, \u0026#34;mouse\u0026#34;, \u0026#34;small\u0026#34;)); print(tom.func.myCall(me)); // Tom is a big cat // Jerry is a small mouse // Just me apply 的模拟实现 apply 实现与 call 类似，但 apply 获取的参数是以一个数组整体的形式存在的，而 call 获取到的是不确定数量的参数。\nvar tom = { name: \u0026#34;Tom\u0026#34;, func: function (type, desc) { if (type \u0026amp;\u0026amp; desc) { return this.name + \u0026#34; is a \u0026#34; + desc + \u0026#34; \u0026#34; + type; } else { return \u0026#34;Just \u0026#34; + this.name; } }, }; var jerry = { name: \u0026#34;Jerry\u0026#34;, }; var me = { name: \u0026#34;me\u0026#34;, }; var print = console.log; print(tom.func(\u0026#34;cat\u0026#34;, \u0026#34;big\u0026#34;)); print(tom.func.apply(jerry, [\u0026#34;mouse\u0026#34;, \u0026#34;small\u0026#34;])); print(tom.func.apply(me)); // Tom is a big cat // Jerry is a small mouse // Just me // 区别于call方法，apply方法的第二个参数是一个数组 Function.prototype.myApply = function (thisObj, args) { if (!thisObj) thisObj = globalThis; thisObj.func = this; var result; if (!args) { result = thisObj.func(); } else { // params用于组装参数字符串，以备eval解析使用 var params = []; for (var i = 0; i \u0026lt; args.length; i++) { params.push(\u0026#34;args[\u0026#34; + i + \u0026#34;]\u0026#34;); } result = eval(\u0026#34;thisObj.func(\u0026#34; + params + \u0026#34;)\u0026#34;); // 解析结果如 thisObj.func(args[0], args[1], ...) } delete thisObj.func; return result; }; print(tom.func(\u0026#34;cat\u0026#34;, \u0026#34;big\u0026#34;)); print(tom.func.myApply(jerry, [\u0026#34;mouse\u0026#34;, \u0026#34;small\u0026#34;])); print(tom.func.myApply(me)); // Tom is a big cat // Jerry is a small mouse // Just me bind 的模拟实现 bind 的实现依赖如下：\n因为最终新函数要使用新绑定的 this 进行执行，所以需要依赖于 call 或 apply 如果内部把参数处理为数组形式，则可仅依赖 apply，如果参数为零散方式则依赖 call 至于绑定时所作的参数处理也可以不依赖于 call 或 apply 操作，通过遍历方式完成 var tom = { name: \u0026#34;Tom\u0026#34;, func: function (type, desc, log) { if (type \u0026amp;\u0026amp; desc) { if (log) { console.log(log); } return this.name + \u0026#34; is a \u0026#34; + desc + \u0026#34; \u0026#34; + type; } else { return \u0026#34;Just \u0026#34; + this.name; } }, }; var jerry = { name: \u0026#34;Jerry\u0026#34;, }; var me = { name: \u0026#34;me\u0026#34;, }; var print = console.log; print(tom.func(\u0026#34;cat\u0026#34;, \u0026#34;big\u0026#34;)); print(tom.func.bind(jerry, \u0026#34;mouse\u0026#34;, \u0026#34;small\u0026#34;)(\u0026#34;Jerry comes at \u0026#34; + new Date())); print(tom.func.bind(me)()); // Tom is a big cat // Jerry comes at Fri Apr 24 2020 18:48:32 GMT+0800 (GMT+08:00) // Jerry is a small mouse // Just me // bind函数接收第一个参数用于作为新绑定的this,后续可选参数作为绑定时传入该函数的参数 // 返回一个绑定后的函数,该函数并不立即调用,并且在以后的调用时仍可传入新的参数 Function.prototype.myBind = function () { // 调用bind的this即是要改变this的函数 var func = this; // 拷贝一份参数,arguments是一个类数组,无法直接调用数组的方法 var args = Array.prototype.slice.call(arguments); // 参数第一个是调用当前函数的this对象 // 这里从arguments中获取调用bind函数的this,也可以直接从函数形参中取 var object = args.shift(); // 首选确定bind函数返回的是一个函数,而不是什么确定的值 // 因为js中函数是一等公民,所以可以想象为同样返回了一个变量,只不过这个变量可以执行 // 这里会产生闭包,当bind函数返回后,bind函数内的变量仍未被回收,并且在外部新函数调用时可以访问到 return function () { // 这里的arguments已经是调用新函数时传入的新参数 // 新的函数被执行时要有使用新this和新参数执行的结果返回 // 因为最终执行时调用了apply，所以没有对新this做判空处理，由apply内部去做 return func.apply( object, args.concat(Array.prototype.slice.call(arguments)) ); }; }; print(tom.func(\u0026#34;cat\u0026#34;, \u0026#34;big\u0026#34;)); print(tom.func.myBind(jerry, \u0026#34;mouse\u0026#34;, \u0026#34;small\u0026#34;)(\u0026#34;Jerry comes at \u0026#34; + new Date())); print(tom.func.myBind(me)()); print(tom.func.myBind()()); // Tom is a big cat // Jerry comes at Fri Apr 24 2020 18:48:32 GMT+0800 (GMT+08:00) // Jerry is a small mouse // Just me // Just undefined 代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/4-this/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-this/","summary":"关于JavaScript的关键字this的原理的学习","title":"JavaScript的this关键字"},{"content":" 本文为历史博客迁移\n防抖和节流 开门见山（直观图解） 本质解读 首先要弄清楚什么是防抖节流，这二者本质上都是性能优化的一种手段。\n防抖字面意思可解读为防止抖动，是要防止什么的抖动呢，一般是事件响应，最常见的就是输入框input事件的监听。如果不加防抖会怎么样，你给一个输入框绑定了input事件监听，则你在输入的整个过程，都在频繁触发input回调。如果回调中存在复杂的dom操作或是网络请求，都会导致很大的资源浪费或造成页面震动，所以才有了防抖这种性能优化策略。\n防抖 具体防抖策略是如何进行性能优化的，分两种：\n当发生被判定为抖动的操作后，只响应抖动结束前的最后一次操作。 立即处理某种操作，但如果在某个时间区间内再次出现相同操作被判定为抖动而不进行响应。 分别举例：\n在谷歌输入框输入内容，在输入的同时对已输入的内容做联想回显，试想这样一个事情，用户要输入一个词语或句子进行搜索，用户的输入动作理应是连续的，如果中间有停顿，说明用户在思考要怎么描述要搜索的内容，所以这个时候才是联想提示的最佳时机。那么怎么样我们认为是可以进行联想的时机呢，也就是输入停顿有个时间判定，这里我们为了效果明显以 2s 内没有继续输入判定为停顿。 我们先看一下不加防抖的效果：\n代码如下\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input id=\u0026#34;input\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;span id=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;1-normal.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; function inputListener() { var inputDom = document.getElementById(\u0026#34;input\u0026#34;); inputDom.addEventListener(\u0026#34;input\u0026#34;, handleInput); } function handleInput(e) { var spanDom = document.getElementById(\u0026#34;content\u0026#34;); spanDom.innerHTML = e.target.value; autoTip(e.target.value); } function autoTip(content) { // 这里可能有网络请求/接口请求/DOM操作等操作 console.log(\u0026#34;自动联想\u0026#34;); } inputListener(); 每下输入都做响应是很糟糕的，所以我们需要防抖，策略如下：\n持续监听键盘输入事件，也就是每次输入都会触发input事件，判定2s内发生了 1 次以上的事件响应暂不做处理，直到2s都没再有input事件被触发，则进行联想。代码如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input id=\u0026#34;input\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;span id=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;2-debounce.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; function inputListener() { var inputDom = document.getElementById(\u0026#34;input\u0026#34;); inputDom.addEventListener(\u0026#34;input\u0026#34;, handleInput); } function handleInput(e) { var spanDom = document.getElementById(\u0026#34;content\u0026#34;); spanDom.innerHTML = e.target.value; debounced(e.target.value); } function autoTip(content) { // 这里可能有网络请求/接口请求/DOM操作等操作 console.log(\u0026#34;对\u0026#34; + content + \u0026#34;进行自动联想\u0026#34;); } // 对复杂函数做防抖策略（可以理解为装饰） var debounced = debounce(autoTip, 2000); function debounce(fn, interval) { var timer; // 返回添加防抖后的函数 return function (args) { // 每次触发都会清除掉现有的函数执行定时器，直到没有再次触发，等待定时器到时间后执行函数 clearTimeout(timer); timer = setTimeout(() =\u0026gt; { fn(args); }, interval); }; } inputListener(); 效果展示：\n节流 节流字面意思可理解为节制流量，目的在于控制资源地索取，比如用户一秒十按你的提交按钮，但目的只在于提交表单，那么有没有必要真的一秒内去做十次请求呢，实际上是没必要的。当然如果是这种场景，我们一般的处理可能是，当用户第一次点击提交按钮后，发起请求的同时置灰按钮不可点并按钮显示处理中的动态状，那么后面的点击都会被阻拦，而不进行真正的请求，当上一次请求得到明确的结果后再放开按钮的可点击性。那我们要节流干嘛呢，先看不加节流的效果：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;你点击了\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;7-throttle-normal.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; var count = 0; var btn = document.getElementById(\u0026#34;btn\u0026#34;); document.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; btn.addEventListener(\u0026#34;click\u0026#34;, handleClick); function handleClick() { // 这里可能进行网络请求或DOM操作 count++; console.log(\u0026#34;点击按钮\u0026#34;); document.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; } 为什么要节流呢，比如页面上放着一个按钮，这个按钮的功能是请求后台的接口，操作十分复杂，如果前端不加以限制，用户的点击是不可控的，可以疯狂点击，那么后台堆积的请求将会短时骤增，这样的情况是应进行控制的，而优化的手段就是进行节流。别管你的操作有多快，我要节制访问流量，那我就可以限制对你的操作响应为时间周期性地反馈，比如不管你 1 秒内能点击多少下，我都只会处理一次，这就达到了节流的定义。效果如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;你点击了\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;8-throttle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; var count = 0; document.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; var btn = document.getElementById(\u0026#34;btn\u0026#34;); var throttled = throttle(handleClick, 2000); btn.addEventListener(\u0026#34;click\u0026#34;, throttled); function handleClick() { // 这里可能进行网络请求或DOM操作 count++; console.log( new Date().getMinutes() + \u0026#34;分\u0026#34; + new Date().getSeconds() + \u0026#34;秒执行点击处理\u0026#34; ); document.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; } // 1s内点击3次，应该对第一次点击进行响应 function throttle(fn, interval) { var timer; var last; var lock = false; return function () { console.log( new Date().getMinutes() + \u0026#34;分\u0026#34; + new Date().getSeconds() + \u0026#34;秒发生点击\u0026#34; ); if (lock) return; lock = true; setTimeout(() =\u0026gt; { fn(); lock = false; }, interval); }; } 但如果是用户对操作实时性要求高的，不能对节流周期中的最后一次操作响应，而应是第一次操作就响应，因为分秒必争。所以改进为锁的开放放到定时器内，但响应函数要移出，如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;你点击了\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;9-throttle-optimize.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; var count = 0; document.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; var btn = document.getElementById(\u0026#34;btn\u0026#34;); var throttled = throttle(handleClick, 2000); btn.addEventListener(\u0026#34;click\u0026#34;, throttled); function handleClick() { // 这里可能进行网络请求或DOM操作 count++; console.log( new Date().getMinutes() + \u0026#34;分\u0026#34; + new Date().getSeconds() + \u0026#34;秒执行点击处理\u0026#34; ); document.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; } // 1s内点击3次，应该对第一次点击进行响应 function throttle(fn, interval) { var timer; var last; var lock = false; return function () { console.log( new Date().getMinutes() + \u0026#34;分\u0026#34; + new Date().getSeconds() + \u0026#34;秒发生点击\u0026#34; ); if (lock) return; lock = true; fn(); // 在限制时间延迟后释放锁，允许再次响应 setTimeout(() =\u0026gt; { lock = false; }, interval); }; } 代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/7-debouce-throttle/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-debounce-and-throttle/","summary":"关于JavaScript防抖节流的学习","title":"JavaScript的防抖和节流"},{"content":" 本文为历史博客迁移\n常见排序 冒泡 插入 选择 快排 冒泡排序 原理解析 首先解释一下为什么叫冒泡排序，因为排序过程是将相邻元素依次比较，按照某个规则（取大或者取小）把符合条件的元素筛选出来。\n比如排序结果要从小到大，那么每次相邻元素比较，更大的那个元素就会被放到两个元素中后一个元素的位置，用作下一次比较。这样每次遍历结束，本次遍历中的最大元素就会像水中的泡泡一样冒出来放到数组尾部，当依次将剩余元素遍历结束，则得到从小到大的有序数组。\n代码实现 function bubble(arr) { for (var i = 0; i \u0026lt; arr.length - 1; i++) { for (var j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } 代码解读 关键部分为j \u0026lt; arr.length - 1 - i，核心比较发生在内层循环，由于核心操作是比较相邻元素，所以内层循环每次都是从数组头部开始依次比较相邻元素。\n但是外层循环每进 1，就意味着数组尾部冒出一个泡泡（最大值或最小值），所以内层循环的比较可以排除已经冒出的泡泡元素，所以用数组元素数减去外层循环进行到的索引数。\n另外，内层循环是拿当前元素和其相邻的下一个元素进行比较，所以遍历元素止于整个数组的倒数第二个元素即可，因为每轮的最后一次比较都会取到最后一个元素。\n总结 第一轮遍历会得到整个数组的最值放到数组尾部，第二轮会得到次最值放到数组倒数第二位，以此类推。\n选择排序 算法解读 选择排序很容易和冒泡排序弄混，冒泡是永远在比较相邻元素，而选择排序重在选择，意在选择一个元素作为标杆，在本轮遍历中依次将其他元素和它比较，这样一轮比较结束后，就可以得出一个极值（最大或最小）\n代码分析 如下代码，第一轮遍历，就是拿数组的第一个元素，依次和后面的所有元素依次比较。\n如果比较下来，第一个元素都是更小的那个，那第一个元素就是整个数组的最小元素；如果第一个元素在比较过程中发现有比它小的，则会发生位置交换，然后再继续比较后面的元素。\n这样每一轮的结果是都会把这一轮的极值放到该轮遍历开始的位置，也就是选择该轮遍历开始的位置作为标杆，故名选择排序。\n总结 外层循环是在依次选择当前元素作为标杆，内层循环是在拿标杆和其余元素依次比较，每当内层循环结束触发外层循环进 1 时，都会拿到一个当前极值。\n具体来说，第一次内层循环结束时，数组第一个元素一定是最小（或最大）值，第二次内层循环结束时，数组第二个元素一定是第二小（或大）值，以此类推。\n优化 如果每次比较当前元素和标杆发现当前元素比标杆更小（或大）时就进行位置交换，性能会比较差，在得到当前轮极值前的交换都是没必要进行的。所以可以暂存每次比较的极值，把一轮的所有比较完成后再发生位置交换。\n比如拿到一个[9,7,8,6,4,5,3,1,2]这样的数组，第一轮以 9 为标杆，当比较 9 和 7 后就交换位置，得到的 7 并不是最小值，后面 7 和 6 比较时又需要交换位置。其实完全可以先假定一个最小值，初始化为元素第一个值，然后依次比较其他元素，将最后得到的最小值和第一个元素交换一次位置即可。（即内层循环只做比较和重新给标杆赋值，不发生元素交换）\n优化后代码：\nfunction select(arr) { for (var i = 0; i \u0026lt; arr.length - 1; i++) { var flag = i; for (var j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; arr[flag]) { flag = j; } } [arr[i], arr[flag]] = [arr[flag], arr[i]]; } } 插入排序 关键词：扑克整牌\n解析 想象打扑克抓牌的场景，当抓完所有牌后，开始从小到大（或从大到小）整理排面。\n从第二张牌开始，如果第二张牌比第一张牌小，则插入到第一张牌前，否则不动，此轮结束后第一张牌是目前看来最小的牌。\n然后拿第三张牌，依次和它前面的牌比较（先第二张，再第一张），如果小于第二张则继续和第一张比较，当发现第三张牌介于两张牌的大小中间，则进行插入。\n如果比前面的牌都大则不动，如果比前面的牌都小则插入到牌头部。\n代码实现 function insert(arr) { var temp; var pre; for (var i = 1; i \u0026lt; arr.length; i++) { pre = i - 1; // 拿出的元素 temp = arr[i]; // 当未比较到第一个元素并且拿出的元素小于前面的某个元素 while (pre \u0026gt;= 0 \u0026amp;\u0026amp; temp \u0026lt; arr[pre]) { // 如果拿出的元素比前一个元素小，则前一个元素后移 arr[pre + 1] = arr[pre]; pre--; } // 比到某一个位置，拿出的元素介于两元素大小之间，则插入 arr[pre + 1] = temp; } } 代码分析 拿出的元素发生插入的时机一共有三种：\n比前面的元素都大，则放回到原位 比前面的元素都小，则插入到头部 大小位于前面某两个元素中间，则插入两元素中间 由于拿出每次要进行比较的元素最终要插入到一个新的位置，在插入前，会有前面的元素占据这个元素的位置，所以需要先暂存当前元素，最终插入到腾出的空位。\n具体的插入其实体现在当目标元素前面存在比目标元素大的元素，则会向后移动，占据目标元素原本的位置，所以此时目标元素拿出后需要暂存在一个临时地方。\n特点 当发生插入操作时，意味着不仅仅是位置交换，而是被插入位置后面的元素依次都后移了。\n快排 核心思想 快排之所以复杂是因为用到了分治+递归，但这也是其效率高的原因。\n首先在全局寻找一个元素作为基准，将小于基准的元素都放到左边，大于基准的元素都放到右边，以此粗略将所有元素分为两派；再分别在两个派别中重复此操作。\n代码实现 function quick(arr) { if (arr.length \u0026lt;= 1) return arr; var flag = Math.floor(arr.length / 2); var element = arr.splice(flag, 1)[0]; var l = []; var r = []; for (var i = 0; i \u0026lt; arr.length; i++) { arr[i] \u0026lt; element ? l.push(arr[i]) : r.push(arr[i]); } return quick(l).concat([element], quick(r)); } 代码分析 递归返回的条件是数组不存在元素或数组只有一个元素，这样返回的数组可直接作为元素用于数组拼接。\n每次选当前数组的中间值作为基准，其实可以为任意值。然后将中间值取出，将剩余值按照大于或小于基准值进行分开。\n代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/6-sort-algorithm/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-sort/","summary":"关于JavaScript基础排序算法的整理","title":"JavaScript的基础排序实现"},{"content":" 本文为历史博客迁移\n首先应该阐明的一点是js中是没有真正的继承的，只是通过原型这个东西模拟了继承的效果。\n原型和原型链 js的继承核心在于对象。\n每个实例对象都有一个私有属性（[[prototype]]，部分浏览器可通过proto访问）指向其构造函数的原型对象（prototype）。所以当访问实例对象自身没有的东西时就会沿着其构造函数的原型对象去找，然后原型对象自身也有[[prototype]]（即proto）指向上一层，直到原型对象为 null，这一条长链即是原型链。\n构造函数 上面提到了构造函数，构造函数是面向对象中的概念，是指一个类在实例化时被调用以初始化实例的函数，例如：\nvar Person = function (name, age) { this.name = name; this.age = age; }; Person.prototype.talk = function () { console.log(\u0026#34;hello\u0026#34;); }; var tom = new Person(\u0026#34;tom\u0026#34;, 23); Person就叫作构造方法，用于每次在new Person的时候，给返回的实例做一些准备工作。这些准备工作就是Person类希望其每一个实例都拥有的初始状态。可以在实例化时由传入的参数决定，也可以没有参数，其在内部自己决定初始行为。例如：\nfunction Shape() { this.x = 0; this.y = 0; } var square = new Shape(); 我们很容易就发现，构造函数和类同名。\n没错，因为存在Person.prototype.constructor === Person这样的关系（曾经看到这个关系觉得太神奇了，但这其实就是 js 原型模型中的一个固有设计），也就是Person本身是没有构造函数的，其构造函数只是其原型上的一个constructor 属性，而constructor 这个属性的作用是用来初始化new Person时的行为的，所以需要有一个函数来做具体实现，那么这个函数叫什么合适呢，叫什么都不合适，所以只能叫自己的名字，也就是 Person()\nprototype 原型是什么，原型是对象上的一个名叫prototype的属性，可以按照字面意思理解为一个对象的“模子”。因为可以理解js一切皆对象，所以prototype是很重要的概念。js 中都是对象，而原型又是用于描述对象的基础模子，所以原型有一个重要的也是唯一的标准属性叫作constructor，一般这个属性会指向一个函数，称作构造函数。\n理论上来说，js 任意一个元素，如果其本质上是对象的话，就会拥有原型（prototype）。\n__proto__ ES6 中增加了访问实例对象原型的方法Object.getPrototypeOf()（相当于访问proto）。虽然方法的名字好像是在获取 prototype 属性，但实际上获取的只是原本的proto，其仍然只是指向了构造函数的 prototype 属性。只是官方因为先前不是所有浏览器都统一存在访问实例对象私有属性[[prototype]]（即proto）的途径而新增的访问方式。\n继承方法 严格意义上说js是没有继承方法的，因为所有的方法都是以函数的形式存在于对象上的属性而已。在继承过程中可能会被任意覆盖，例如：\nfunction Tool() { this.name = \u0026#34;tool\u0026#34;; this.created = function () { console.log(new Date()); }; } Tool.prototype.func = function () { console.log(\u0026#34;Tool: I can be used\u0026#34;); }; var tool = new Tool(); console.log(\u0026#34;tool\u0026#39;s name: \u0026#34; + tool.name); // tool\u0026#39;s name: tool tool.func(); // Tool: I can be use function IronTool() {} IronTool.prototype = Object.create(Tool.prototype); var hammer = new IronTool(); hammer.func(); // Tool: I can be used var shaped = function () { console.log(\u0026#34;shaped: I can be shaped\u0026#34;); }; // 这里就相当于面向对象语言中继承过程中的方法重写了 // 但在js里只相当于修改了 IronTool.prototype 的 func 属性 IronTool.prototype.func = shaped; IronTool.prototype.func(); // shaped: I can be shaped 例子中用到了Object.create()，为什么可以如面向对象中的 extends 连接两个类的关系一样建立两个函数的关联呢。\n看一下 MDN 中对于 Ojbect.create()实现 js 类式单继承例子\n// 父类 function Shape() { this.x = 0; this.y = 0; } // 父类方法 Shape.prototype.move = function (x, y) { this.x += x; this.y += y; console.info(\u0026#34;shape moved\u0026#34;); }; // 子类 function Rectangle() { // 关键步骤[1]:调用父类的构造方法,相当于super() Shape.call(this); } // 关键步骤[2]:使用现有的对象 (Shape.prototype) 提供新创建的对象 (Rectangle.prototype) 的 __proto__ // 效果即子类(函数)原型对象的 __proto__ 指向父类(函数)原型对象 (Rectangle.prototype.__proto === Shape.prototype) // 但是 Object.create() 生成的新对象只有 __proto__，没有 constructor，导致无法被 new 调用 // 即：在没有给 Rectangle 重置 prototype 前，其只是一个普通的函数，没有和 Shape 形成原型链,其 prototype 指向 Object.prototype,结构如下: // { // constructor:function Rectangle() { … } // __proto__:Object {constructor: , __defineGetter__: , __defineSetter__: , …} // } // 当重置了 Rectangle 的 prototype 属性后,其 prototype 指向 Shape.prototype,结构如下 // { // __proto__:Object {move: , constructor: } // } // 也就是原本每个函数是默认有自己同名的构造函数在 prototype 上的，但是 Object.create()生成的原型是没有构造函数的，需要自己指定 Rectangle.prototype = Object.create(Shape.prototype); // 关键步骤[3]:给子类指定构造函数（建立构造函数和自身的绑定关系） // 在 new Rectangle 时,调用的其实是 Rectangle.prototype 上的 constructor 方法 // 所以如果没有这一步, Rectangle.prototype 是不具备 constructor 属性的 Rectangle.prototype.constructor = Rectangle; var shape = new Shape(); console.log(\u0026#34;shape instanceof Shape: \u0026#34;, shape instanceof Shape); shape.move(4, 5); var rectangle = new Rectangle(); console.log(\u0026#34;rectangle instanceof Rectangle: \u0026#34;, rectangle instanceof Rectangle); console.log(\u0026#34;rectangle instanceof Shape: \u0026#34;, rectangle instanceof Shape); rectangle.move(2, 3); // shape instanceof Shape: true // shape moved // rectangle instanceof Rectangle: true // rectangle instanceof Shape: true // shape moved 代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/2-inheritance/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-inherit/","summary":"关于JavaScript继承原理的学习","title":"JavaScript的原型和继承"},{"content":" 本文为历史博客迁移\njs 中最常用的数据结构，可以当栈用，也可以当队列用。\n而且 js 数组内置的方法也很多，并且随着 ES 版本的更新，数组的方法越来越强大。我们先来整体看一下都有哪些方法：\n遍历 foreach map 过滤 some every filter 合并 concat 复制 slice 修改 splice 其他 reduce 其中包含面试中可以考察面试者基础牢固程度和 js 掌握精度的很多知识点。比如问初级前端的“写出你常用的 5 个数组方法”足以看出其 js 基础的水平，到问中高级前端 filter、map、reduce、some、every 的灵活运用。\n那么怎么系统规律地记数组的 API 呢，我们参考 MDN 文档整理脑图如下：\n怎么记呢\n修改、访问、迭代 修改 两进两出一反转，自带排序加修改（push/unshift/pop/shift/reverse/sort/splice）\n访问 三种查找加合并，转字符串浅拷贝（includes/indexOf/lastIndexOf/concat/join/slice）\n迭代 三大遍历和高级，reduce 可倒着数（foreach/every/some/filter/map/reduce/reduceRight）\n代码仓库见: https://github.com/barnett617/codehub/blob/main/front-end/src/1-array/index.md\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-array/","summary":"关于JavaScript数组的学习","title":"JavaScript数组学习"},{"content":" 本文为历史博客迁移\n本文为学习《JavaScript 编程精解》 第一章的总结\n数值类型 数字 字符串 布尔值 未定义的值 运算符 二元运算符 + - * / % in 判断属性是否存在于对象中 字符串连接符 + 比较运算符 == != === !== \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 逻辑运算符 \u0026amp;\u0026amp; || 一元运算符 - 取反 ! 逻辑取反 typeof 获取值类型（注意！typeof 是运算符） delete 删除对象的属性 三元运算符 ? : 根据第一个值选择后两个值中的一个 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2023-06-11-js-operator/","summary":"关于JavaScript运算符的学习","title":"JavaScript运算符"},{"content":"关于 2022 年的项目总结\n整体总结 hybrid 应用经验，擅长调试 bridge 问题，通过 jsbridge 调用现象反推原生 bridge 侧的实现 bridge 打开 H5 链接具备白名单权限 bridge 方法响应超时 location.href 打开 scheme 失败，改为使用新的 webview 承载 scheme 擅长通过文档梳理现有系统技术架构及业务逻辑，并辅助项目维护性体验 带领组员进行技术评审、Code Review、技术学习（rxjs）、团队规划 内部工具对接 输出：UT、赤兔、webx\n隐私功能页开发 输出：组件抽象、设计\n全量项目参数过滤 输出：sdk 新增 ajax 请求统一过滤方法、汇总 50 多个项目的改动范围并分配改动任务\n线上问题跟踪 总结：通过调试发现多个 bridge 方法调用会导致前面方法的返回超时\n内部文档——新人手册 输出：基于 vuepress 搭建新人站点，帮助新成员快速熟悉组内技术栈及开发环境\n内部营销工具接入——招募页接入赤兔平台 输出：完整接入流程文档、测试环境部署脚本、共建 xpub 新特性（组件条件展示）\n外部投放页体验优化——招募落地页 问题：图片文件大、图片资源频繁替换\n解决：针对固定图片增加资源预加载、引入头图配置化方案\n内部基建文档共建——《工程化演进》 输出：脚手架插件、架构分析整理\n跨端项目重构——基于 MPX 实现多项目融合 输出：整合业务重合部分，解决不同端实现的兼容问题（滑动组件）\n营销互通——小桔加油投放司机招募 输出：小程序调起小程序的接入方案、H5 上线系统打包自动化脚本（基于 Node.js 的解析、重写、打包）\n营销活动小程序化——小程序内使用司推司 H5 遇到问题：判断环境、接入登录、线上问题排查（sdk 版本升级导致参数解析失败——大小写问题）\n小程序优化 输出：开发效率优化、打包部署自动化、包加载响应（图片、组件、dead code）\n跳端调研 输出：scheme、unilink、location.href、公众号、小程序\n活动页开发 输出：转盘动画\n活动页开发 输出：车费保障卡、多页面、组件设计\n线上问题排查 输出：埋点链路\n车速检测 demo 输出：定时获取经纬度、去重、防抖\n组件库共建 输出：单测规范、部分组件单测用例\n线上问题排查 输出：SDK 后页面白屏分析（js 报错，数据结构缺失导致的页面渲染受阻）\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2022-09-21-2022-projects/","summary":"\u003cp\u003e关于 2022 年的项目总结\u003c/p\u003e","title":"2022年项目总结"},{"content":"STAR Template S: Situation T: Task A: Action R: Result Explanation S describe a specific situation and establish context don\u0026rsquo;t generalize or offer a litany of your accomplishments speak directly to the question as posed be detailed enough T go to the specific task you had to do be clear what the task was related to the question and whatever ability the interviewer is looking to evaluate clarity and relevancy A stay on topic focus on what you did in the situation to resolve the task and keep that focus on you first person singular, not we or out team only talk about what you did R explain the outcome of the task due to your actions take credit for what you did it\u0026rsquo;s not the time for modesty explain what happened, how did the situation or task resolve itself, what did you accomplish, did you learn anything keep it positive even if the situation or task didn\u0026rsquo;t end that way Projects Description Operating activity for drivers during the Spring Festival S the project\u0026rsquo;s deadline is tight for the whole tech team we have two front-end developers, a backend developer, three UI designers and a project manager we totally have a week to develop a brand new html5 single page application which can run on both native app and weixin miniapplication platform, and it has a lot of UI animations and sharing logic T I am this project\u0026rsquo;s frontend development owner and had to ensure this project will be deployed online and runs great in the end I need to keep us on our production schedule and develop my part of work A I dive into develop the basic logic without UI first I call another experienced developer to help us build a jssdk for this project which includes login, tracking, ajax modules R I finished my work as expected and did some refactoring to make my codes more strong I read the code that experenced developer wrote and learnt more about how to use webpack or vue-cli-plugin to supply different packages by different environments I got to know how developers to face projects with limit time and how to ensure the project to be done in time, such as meetings to synchronize progress between others and talk about diffculties in time, and try to call others to help LiveShow on WeChat MiniProgram platform S the marketing team announced to build an app to attractive more drivers to know our another feature which can gain more income(which called benefit center) using liveshow format T I need to know how to use liveshow ability in wechat miniprogram platform and know its conditions I need to develop a tiny function which use wechat pay to make our miniprogram can apply liveshow right I need to build a standalone h5 to deployed in our main native app and support to jump into out wechat miniprogram directly Finally, I had to develop the goods detail of buying webpages to support the ability which liveshow need A First, I got to read the documentation of wechat development about paying, liveshow, jump from native app Then I started to develop a simple function which used wechat pay sdk and deployed it online for liveshow applying Then I started to set up a single h5 to develop the function jump from our native app to the specific wechat miniprogram, for this function need our native app to integrate the wechat sdk for jumping, I carefully researched the action flow and read the demo from wechat official, then I talked to our native developing team to help me Finally, I develop the core function of buying things from liveshow and coroperate with our backend developer R Finally, I finished a h5 which supplied to jump to miniprogram, a function in miniprogram which supports to watch liveshow and buy things. For this project, we received a lot of driver users\u0026rsquo; appreciation and gained more notabilities. I got more familar with wechat platform ablities and apis such as jump from native, set up a liveshow, and buy things use wechat pay. I had gained more experience of developing a big operating activity project personal and find the right way of achieving it, such as by reading the right official document and find the right other team to support you. Upgrade the function of drivers\u0026rsquo; interviews S we have a lot of new driver users who need to be interviewed and then be our legal backend users, the old way to interview drivers need a lot of interviewers offline and has to order drivers to go to our specific place to accomplish the interview T I need to build some webapps that support drivers to finish the interview online and our checkers can check the drivers\u0026rsquo; interview process asynchronizely, and the core webapp need some native app abilities such as recording voices, make video of interview process, capture face and body part and so on. A I build a standalone webapp and work with our native app developer that supply me the native ablitity and backend developer who supply me the interview content and judge the drivers\u0026rsquo; answer that submitted. I frequently communicate with the native app develops that is an iOS developer and an Android developer, because I was getting familar with the team\u0026rsquo;s jssdk and jsbridge during the project. We talked and designed new bridge functions which can suit this project together, then I wrote documents for the new bridges and communicate with native developers in time to ensure the bridges' changes R Finally, I deployed the webapp online and updated our jsbridge by publishing our npm package to support the new functions, the function online served both driver uses and our audits by increasing more drivers\u0026rsquo; interview commits and make audits\u0026rsquo; work more flexible. It indirectly save our cost on clarifying new driver users and be a continuous function for our main app for drivers. ","permalink":"https://barnett617.github.io/wilson-blog/en/posts/2022-09-21-projects-star-2022/","summary":"STAR Template S: Situation T: Task A: Action R: Result Explanation S describe a specific situation and establish context don\u0026rsquo;t generalize or offer a litany of your accomplishments speak directly to the question as posed be detailed enough T go to the specific task you had to do be clear what the task was related to the question and whatever ability the interviewer is looking to evaluate clarity and relevancy A stay on topic focus on what you did in the situation to resolve the task and keep that focus on you first person singular, not we or out team only talk about what you did R explain the outcome of the task due to your actions take credit for what you did it\u0026rsquo;s not the time for modesty explain what happened, how did the situation or task resolve itself, what did you accomplish, did you learn anything keep it positive even if the situation or task didn\u0026rsquo;t end that way Projects Description Operating activity for drivers during the Spring Festival S the project\u0026rsquo;s deadline is tight for the whole tech team we have two front-end developers, a backend developer, three UI designers and a project manager we totally have a week to develop a brand new html5 single page application which can run on both native app and weixin miniapplication platform, and it has a lot of UI animations and sharing logic T I am this project\u0026rsquo;s frontend development owner and had to ensure this project will be deployed online and runs great in the end I need to keep us on our production schedule and develop my part of work A I dive into develop the basic logic without UI first I call another experienced developer to help us build a jssdk for this project which includes login, tracking, ajax modules R I finished my work as expected and did some refactoring to make my codes more strong I read the code that experenced developer wrote and learnt more about how to use webpack or vue-cli-plugin to supply different packages by different environments I got to know how developers to face projects with limit time and how to ensure the project to be done in time, such as meetings to synchronize progress between others and talk about diffculties in time, and try to call others to help LiveShow on WeChat MiniProgram platform S the marketing team announced to build an app to attractive more drivers to know our another feature which can gain more income(which called benefit center) using liveshow format T I need to know how to use liveshow ability in wechat miniprogram platform and know its conditions I need to develop a tiny function which use wechat pay to make our miniprogram can apply liveshow right I need to build a standalone h5 to deployed in our main native app and support to jump into out wechat miniprogram directly Finally, I had to develop the goods detail of buying webpages to support the ability which liveshow need A First, I got to read the documentation of wechat development about paying, liveshow, jump from native app Then I started to develop a simple function which used wechat pay sdk and deployed it online for liveshow applying Then I started to set up a single h5 to develop the function jump from our native app to the specific wechat miniprogram, for this function need our native app to integrate the wechat sdk for jumping, I carefully researched the action flow and read the demo from wechat official, then I talked to our native developing team to help me Finally, I develop the core function of buying things from liveshow and coroperate with our backend developer R Finally, I finished a h5 which supplied to jump to miniprogram, a function in miniprogram which supports to watch liveshow and buy things.","title":"Personal Projects Description Using STAR Principle"},{"content":"使用 vscode 远程开发一个全栈 Web 项目\n技术栈\u0026amp;工具 前端 Vue.js 后端 Express PM2 工具 Nodejs VScode 百度地图 jssdk 开发准备 一台 Linux 系统的服务器(centos) 搭建基于nodejs的服务端环境 使用nvm管理nodejs环境(curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash) 安装pm2用于nodejs程序的进程管理(npm i -g pm2) 搭建基于Vue的前端环境 使用@vue/cli进行前端项目初始化(npm install -g @vue/cli) [可选]使用travis+github action进行项目 CI 管理 功能 获取精确到城市级别的位置信息 位置信息地图可视化展示 源码解析 后端核心逻辑 根据express获取到的请求获取来源 IP，通过调用第三方API 获取位置信息\napp.get(\u0026#34;/api/loc\u0026#34;, (req, res) =\u0026gt; { let ip = req.ip || req.ips[0]; if (ip.indexOf(\u0026#34;:\u0026#34;) \u0026gt; -1) { ip = ip.split(\u0026#34;:\u0026#34;)[3]; } if (ip) { const url = `http://api.ipapi.com/${ip}?access_key=xxx`; http.get(url, (httpRes) =\u0026gt; { let chunkData = \u0026#34;\u0026#34;; httpRes.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { chunkData += chunk; }); httpRes.on(\u0026#34;end\u0026#34;, () =\u0026gt; { const jsonObj = JSON.parse(chunkData); res.status(200); res.json({ errno: 0, data: jsonObj, }); }); }); } else { res.status(400); res.json({ errno: 400, errmsg: \u0026#34;没有获取到IP\u0026#34;, }); } }); 前端核心逻辑 接口请求及数据处理 getLoc() { let url = `//${account.api}/api/loc`; axios .get(url) .then(res =\u0026gt; res.data) .then(res =\u0026gt; { if (+res.errno === 0) { const obj = res.data; if (obj.latitude) { this.lat = obj.latitude * 1 this.lng = obj.longitude * 1 } this.rows = Object.keys(obj) .filter(key =\u0026gt; Object.keys(this.dataMap).includes(key)) .map(key =\u0026gt; { return key === \u0026#39;location\u0026#39; ? { label: \u0026#39;国旗\u0026#39;, value: obj[key][\u0026#39;country_flag_emoji\u0026#39;] } : { label: this.dataMap[key], value: obj[key] }; }); } }); }, 地图 SDK 加载 function baiduMap(ak) { return new Promise((resolve, reject) =\u0026gt; { window.baiduMap = function () { resolve(); }; let script = document.createElement(\u0026#34;script\u0026#34;); script.type = \u0026#34;text/javascript\u0026#34;; script.src = `http://api.map.baidu.com/api?type=webgl\u0026amp;v=3.0\u0026amp;ak=${ak}\u0026amp;callback=baiduMap`; script.onerror = reject; document.head.appendChild(script); }); } 地图组件 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;map-wrap\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { baiduMap } from \u0026#34;../../common/js/utils\u0026#34;; import { account } from \u0026#34;../../../account\u0026#34;; export default { props: { lat: Number, lng: Number, }, data() { return { ak: account.ak, zoomSize: 16, map: null, clickedAddr: \u0026#34;\u0026#34;, }; }, watch: { lat() { this.renderMap(); }, }, mounted() { if (this.lat \u0026amp;\u0026amp; window.BMapGL) { this.initMap(); } }, methods: { renderMap() { const that = this; this.$nextTick(() =\u0026gt; { baiduMap(this.ak).then(() =\u0026gt; { that.initMap(); }); }); }, initMap() { const map = new BMapGL.Map(\u0026#34;container\u0026#34;); this.locationByLatLng(map); this.commonSet(map); this.showLoactionControl(map); this.observeMapClick(map); this.getAddress(); this.locationByBrowser(map); this.locateByOriginBrowser(); }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34; scoped\u0026gt; .map-wrap { margin: 20px; position: relative; } #container { height: 300px; } \u0026lt;/style\u0026gt; 工程化基建 vConsole 隐式加载 vConsole，通过热键唤起 vConsole 面板\nclickTitle() { this.clickCount = this.clickCount + 1 if (this.clickCount === 5) { if (!this.consoleShow) { this.consoleShow = true this.showVConsole() } } setTimeout(() =\u0026gt; { this.clickCount = 0 }, 2000) } PM2 启动后端服务时添加--time参数，为日志添加时间\n使用pm2 logs查看后端服务日志\n项目部署 后端服务 pm2 start api.js --name me 前端服务 npm run build 将dist拖拽到vscode remote访问到的服务机\n架构 服务机固定单端口同时部署前端服务和后端服务于不同的路由\n前端服务 app.use(express.static(path.join(__dirname, \u0026#34;../dist\u0026#34;))); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.sendFile(path.join(__dirname, \u0026#34;../dist/\u0026#34;, \u0026#34;index.html\u0026#34;)); }); 后端服务 app.get(\u0026#39;/api/loc\u0026#39;, (req, res) =\u0026gt; { res.status(400) res.json({ errno: 200, data: {} }) } 关于 CI Vue CLI 官方文档中提供了两种基于 Github Pages 的 CI 方式，其中第一个坑就是不要看中文文档，因为中文文档“年久失修”，很多错误的地方也没人勘误，建议以英文文档为准。\n接着就是关于两种 CI 方式，其中第一种手动方式没什么问题，本地写一个 Shell 脚本，需要发布项目的时候手动执行，核心逻辑如下\nbuild 生成 dist 进到 dist 目录，将 dist 目录初始化为一个 git 项目并提交，强制推送到当前项目远程的 gh-pages 分支 退出 dist 目录 另外就是通过集成 travis 的自动化方式，核心步骤如下\n在本地安装 travis 客户端(gem install travis) 使用 github 登录 travis(travis login \u0026ndash;com \u0026ndash;github-token xxx) 设置 travis 变量（用于 travis 调用 github API 来拉取你的 github 项目）(travis env set GITHUB_TOKEN xxx) 项目中增加 travis 配置文件 在 travis 网站观察 CI 结果 这里面坑很多，首先第一个就是Vue CLI官方文档中提供的travis登录方式已经过时，即直接进行travis --login输入 github 用户名和密码后会报NOT FOUND错误，这里是由于这个原因，所以需要使用 github_token 的方式进行登录。\n第二个坑就是按照 CI 逻辑，推送了本地分支，却没有发生 gh-pages 分支的更新，即自动化根本没有执行。这里可以通过 travis 网站的控制台查看 requests 中所有的 CI 请求都是失败的，提示的报错大多是Could not authorize build request for xxx。\n而这里的错误根本不是字面意思这样，而是需要手动在 travis 的 plan 中选择一个套餐，即使是免费套餐也得选择。原因发现自这里\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2021-07-24-webapp-based-on-bs-arch/","summary":"\u003cp\u003e使用 vscode 远程开发一个全栈 Web 项目\u003c/p\u003e","title":"基于B/S架构的webapp开发"},{"content":"Business projects smart-interview\ndouble-lift\ncarface\nbackflow\nvideo-interview\nblack-list-interview\nnew-comer-mission\npre-education\nspecial-cheap\nbenefit-center\nmp-pay\u0026amp;live\ncross-platform-recruitment\ncarfee-ensurance\ntrack-monitor\nspring-festval-active\nearlybird\nProject details Smart Interview self development get used to team\u0026rsquo;s workflow jsbridge jssdk Car Face Recognition rxjs New Users Missions vuex Users Back Flow scheme protocol Live Show wxAPI pay Spring Festival Operating Activity cross platform development vue-cli-plugin Tech stack vue composition api vuex vue-router vue-cli vue-cli-plugin vue-rx webpack loader plugin js jsSDK jsBridge ","permalink":"https://barnett617.github.io/wilson-blog/en/posts/2021-03-01-projects-2020/","summary":"Business projects smart-interview\ndouble-lift\ncarface\nbackflow\nvideo-interview\nblack-list-interview\nnew-comer-mission\npre-education\nspecial-cheap\nbenefit-center\nmp-pay\u0026amp;live\ncross-platform-recruitment\ncarfee-ensurance\ntrack-monitor\nspring-festval-active\nearlybird\nProject details Smart Interview self development get used to team\u0026rsquo;s workflow jsbridge jssdk Car Face Recognition rxjs New Users Missions vuex Users Back Flow scheme protocol Live Show wxAPI pay Spring Festival Operating Activity cross platform development vue-cli-plugin Tech stack vue composition api vuex vue-router vue-cli vue-cli-plugin vue-rx webpack loader plugin js jsSDK jsBridge ","title":"Projects Review of 2020"},{"content":"Career join didiglobal and work for didi driver hybrid app become the owner of Flower Piggy (a ride-hailing service of Didi targeting younger customers) driver-side services finish two impressive projects alone(smart interview SPA html5 project and make a live in wechat miniprogram) Work staff build hybrid web app pages(no pc websites) learn to use group-related develop tools such as vue-cli-plugin, UI component library, jssdk, and jsbridge etc. keyboard component page track cubeui UI library and biz library jsbridge develop standalone projects using HTML5/Vue2 develop new features as requirement or bugfix code review refactor and improve performance online problems locating(server side problem/frontend logic errors/data tracking exception) locate problems and communicate with other group and push them to realize requirements miniprogram UI component unit testing and document(refer to weui/j-component/miniprogram-simulate) integrate third party SDKs(paying SDK etc.) Tech stack vue lifecycle method created mounted mixins emit/on props vuex store mutation mapGetter mapState mapMutation vue-router vue-cli-service vue.config.js webpack vue-cli-plugin babel stylus es6 promise/async includes const/let deconstruct ESM/amd/umd/commonJS jscore function/callback setTimeout/setInterval closure git \u0026amp; gitlab node \u0026amp; npm dependence/devDependence/peerDependence link/publish/version(semver) macro/micro tasks Coding skills css animations transform translate keyframe animation 1px compatity js array methods findIndex and indexOf some/every/each filter/map/reduce sort network basic ajax post/get/options content-type application/json、application/www-form-urlencoded CORS web browser url/schema window/location/document encode/decode/encodeComponent/decodeComponent cache cookie/sessionStorage/localStorage libraries/frameworks learning vue3 vue-rx backend skills nginx linux useful instructions curl hybrid webview camera/record/geolocation Problem solving Learn how to add new feature for jsbridge and debug new feature with native app developers and deploy new jsbridge npm package Get used to debug new features with backend developer\u0026rsquo;s APIs and make requirements work correctly Reading Rich Dad Poor Dad(personal finance) Danshari(about lifestyle) Bad kid(a Chinese novel book talk about humanity) Animal Farm(because the movie——Hunting) You don\u0026rsquo;t know JavaScript(coding skills) Travel Changsha(train) Saihanba(driving) Planing coding skills GraphQL Planing life learning reading more Englist articles(technique) reading more books coding more build personal website or blog(replace the using blog template) ","permalink":"https://barnett617.github.io/wilson-blog/en/posts/2021-03-01-review-2020/","summary":"Career join didiglobal and work for didi driver hybrid app become the owner of Flower Piggy (a ride-hailing service of Didi targeting younger customers) driver-side services finish two impressive projects alone(smart interview SPA html5 project and make a live in wechat miniprogram) Work staff build hybrid web app pages(no pc websites) learn to use group-related develop tools such as vue-cli-plugin, UI component library, jssdk, and jsbridge etc. keyboard component page track cubeui UI library and biz library jsbridge develop standalone projects using HTML5/Vue2 develop new features as requirement or bugfix code review refactor and improve performance online problems locating(server side problem/frontend logic errors/data tracking exception) locate problems and communicate with other group and push them to realize requirements miniprogram UI component unit testing and document(refer to weui/j-component/miniprogram-simulate) integrate third party SDKs(paying SDK etc.","title":"Personal Tech Review of 2020"},{"content":"利用 github 的 actions 为你的前端项目加上 CI(Continuous Integration，持续集成)\n一、创建前端项目 这里以 angular 项目为例，其他框架同理\n前端的三大框架（Angular、React 和 Vue）目前均有自己比较成熟的脚手架（cli）可用于项目从创建、开发到构建、部署一系列的工作，从而使得前端部分的工作从开发到交付保持比较高的效率。\n但仅仅如此还不够，因为在部署环节，其实不同开发者有这不同的“套路”，有使用 jenkins 的，也有在本地编译再通过 scp 传输到服务器的。但这些在 CI 面前都显得不够“自动化”。\n我们稍微总结一下：\n前端有三大框架\nAngular React Vue 分别对应有自己的脚手架工具\n@angular/cli create-react-app @vue/cli 前端项目从 0 到 1 到上线主要环节有\n创建 开发 构建 部署 主流部署方式有\njenkins scp 接下来进入今天的主要环节，如何利用 github 的 actions 功能实现项目 CI\n二、github actions 按照 github actions 的指示操作后，会创建一个.github/workflows/blank.yml 文件\n这个文件承载着整个 github actions 的配置，也就意味着当你在 github 某个仓库中包含.github/workflow/xxx.yml 文件后，你在操作这个仓库时就会触发对应的 action。比如我们如下配置可使得每次在对 smartshop 这个项目的 master 分支上进行 push 时触发如下动作：\n在 github 所提供的某台云服务器 A 上安装 node 和 npm 在服务器 A 上安装@angular/cli 利用安装好的@angular/cli 对 smartshop 项目进行编译 将编译生成的目录通过 scp 发送到指定的服务器 B # This is a basic workflow to help you get started with Actions name: CI # Controls when the action will run. Triggers the workflow on push or pull request # events but only for the master branch on: push: branches: [master] # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \u0026#34;build\u0026#34; build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 # this installs node and npm for us - uses: actions/setup-node@v1 with: node-version: \u0026#34;10.x\u0026#34; # this allows for re-using node_modules caching, making build a bit faster - uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles(\u0026#39;**/package-lock.json\u0026#39;) }} restore-keys: | ${{ runner.os }}-node- # Runs a single command using the runners shell - name: npm install run: npm install - name: install ng-cli run: npm install -g @angular/cli \u0026gt; /dev/null - name: build run: npm run build # run: ng build --prod - name: copy file via scp uses: appleboy/scp-action@master with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} port: ${{ secrets.PORT }} password: ${{ secrets.PASSWORD }} source: \u0026#34;./dist/znsc-ng\u0026#34; target: \u0026#34;/home/webapp/\u0026#34; 其中比较关键的也是开发者比较关心的是自己要部署的服务器信息，这部分内容当然是不会直接明文写在配置文件中的，所以在这里 github actions 利用了变量进行处理。而这个变量值的设置则是通过另一个地方进行保存\n插曲一 初始化的阿里云 ECS 由于控制台配置，默认的 80 端口可能不是 nginx 服务器，也有可能被其他程序占用，可通过以下命令查看\nnetstat -anop | grep 0.0.0.0:80 tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 1905/java off (0.00/0/0) tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 24066/httpd off (0.00/0/0) tcp 0 0 0.0.0.0:8009 0.0.0.0:* LISTEN 1905/java off (0.00/0/0) 可发现 80 端口被 apache 服务器的 httpd 进程所占用，如果使用 apache 服务器，可通过配置 apache 所占 80 端口默认访问的静态文件入口，操作如下：\nwhereis httpd httpd: /etc/httpd /usr/local/apache/bin/httpd cd /etc/httpd vi httpd.conf /80 /DocumentRoot 如果使用 nginx 服务器，可通过以下命令查找 nginx 服务器当前使用的配置文件\nwhereis nginx nginx: /usr/local/nginx cd /usr/local/nginx cd sbin ./nginx -t nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 插曲二 angular 项目中可能会使用到样式预处理器，当依赖 node-sass 包后可能会下载失败。此时可使用 node-sass 官网所提供的另一个包提供可供下载该包的源配置，如下\nnpm install -g mirror-config-china --registry=https://registry.npm.taobao.org 参考\n结论 这样我们就可以愉快地在功能分支进行开发和提交，在 master 分支进行 push 到远程仓库，并自动触发部署动作，完成更新上线了。这样既省去了每次手动部署的操作，也无需对服务器私密信息进行本地保存，实属 github actions 为我们提供的一种 CI 最佳实践\n参考资料 Deploy Angular to Production with Github Actions Managing deploy keys httpd 配置文件 httpd.conf 规则说明和一些基本指令 Generating a new SSH key and adding it to the ssh-agent ","permalink":"https://barnett617.github.io/wilson-blog/posts/2020-08-19-ci-with-github/","summary":"\u003cp\u003e利用 github 的 actions 为你的前端项目加上 CI(Continuous Integration，持续集成)\u003c/p\u003e","title":"如何使用github进行持续集成"},{"content":"重新把很早以前写的“博客”看了一下，发现有新的感悟\n本想像归档历史一样把之前散落在 CSDN 上写过的“文章”直接粘过来和“大本营”汇合，但发现之前写的东西真的没法看（笑哭）。\n首先那些应该算不上是博客，因为很少有从自己大脑中输出的文字内容，大学时期写的多是把课本上的概念汇总梳理了一下，顶多算得上是读书笔记。但那时的归纳能力的确弱的可怜，基本划完重点以后发现都是重点。\n这就不由想想为什么会这样呢，发现其实本科阶段真的只是在学了一个”目录“，只是让我们知道了自己的专业里有哪些专业名词，免得以后从事自己专业所做的事时一无所知。\n大学的内容现在看来真的太过密集、信息量之大，再加上如果没有负责的老师把其中的精华拿出来引导学生去掌握的话，最终可能很多大学生的结果是仅仅停留在”学过“的程度。\n就比如我在 CSDN 中前两篇关于 计算机网络 和 数据结构 的总结。\n这些东西拿出来就足够一个工作多年的人去重新学习数月之久，但对于本科生，学习它们的时间可能就仅限于考试前的一个礼拜。最终虽然考试过了，但也只是背下了这些文字，而根本很少理解这其中的大多原理，但这些知识又恰恰是从计算机诞生之初到今天被不断打磨而形成的核心原理。\n互联网之所以能有今天的繁荣就是从这些原理中所创造出来的，就好比”一生二，二生三，三生万物“，这些知识点就是那个重要的”一“。\n所以借这个场景我们可以理直气壮地重申那个广为人谈的观点——”学习是终身的。“\n就拿计算机专业来说，能把书本中这些东西都熟记脑中的可能有这么几类人：\n大学专业课教师 考过软考相关考试并获得证书的人 民间自学高手 混迹公司多年并苦心研究技术的扫地僧 除此之外的技术从业者，都应该抱着一颗怀有敬畏感的心，永远不应该停止学习，不管是新的技术，还是老的基础，只因为学海无涯。并且这些人也都曾心中默念”学无止境“才成为自己领域的佼佼者，甚至他们至今还保持着一如既往的学习态度。\n既然前面都有那么多厉害的前辈，我等晚辈又岂能偷闲呢，不禁感叹”真正的大师永远都怀着一颗学徒的心“。\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-05-04-thinking-about-blog/","summary":"\u003cp\u003e重新把很早以前写的“博客”看了一下，发现有新的感悟\u003c/p\u003e","title":"整理博客过程中的一些思考"},{"content":"时隔许久，决定重新打开尘封许久的博客。\n很久没再更新，一方面是因为曾一度觉得在某些问题的解决上，网上其他人写的更有价值，也就不想再生产“网络垃圾”。另一方面是项目多起来真的很难有时间拿来写博客，往往一个项目结束，正想着复盘整理一下项目中的收获和疑点时，下一个项目就又开始了。\n这次借着疫情期间闲下来，决定重新捡起这个东西。\n换个博客主题 第一步想到的是要换个博客主题，博客本身是基于 Hexo 引擎的，其 主题列表 也是百花齐放，质量层次不齐，并且数量还在不断增加中，很难从中选到一个中意的。\n再三对比下我选择了既简洁又不失美观的 fluid，应该是截至目前我最满意的主题了，它是基于 material 设计风格的，和它类似的另一款主题是 matery ，也是我之前用的主题。\n现在再看感觉过于花哨，功能虽多，但看上去过于炫技，反而丧失了博客的本质——文字记录。相比之下，fluid 的首页排版会让我觉得更加聚焦于博客列表的展示，其实这我都觉得有点花哨，因为主题出于美观的目的导致布局中的间距有点大，首页能够展示的博客数不够多。\n起初我是想这次做成 jjc 和 颜海镜 两位大神那样的风格，就简简单单首页陈列所有的博客标题，没有多余的东西。但后来想想还是算了，毕竟自己还没到那么成熟的段位，可能驾驭不了那么成熟稳重的风格，自己的博客中还是需要一些活力的元素，于是便选择了这个介于浮夸和稳重之间的主题风格。\n为什么重新解封博客 这次重新捡起博客的另一个重要原因是想整合之前写过的所有文字记录，因为感觉平时自己也写过一些自认为比较有意义的东西，有些是学习工作过程中对于问题解决的记录，有的是学习到不同阶段所产生的感悟，有些纯粹是为了记录某些东西便于后续查找的。\n总之，有很多东西需要被汇总到一起。\n因为平时有的东西可能随手一写就放在电脑本地了，有的在笔记本里的，有的在台式机里，还有一些是在没有独立博客前散落在各种公共博客空间写的。\n我觉得出于对自己所生产内容负责的态度，这些产出应该被比较完整地去维护。比如之前本地随笔写的东西可能很多因为没有发出来就烂尾了，而如果有这样一个长期维护的博客，可能会起到一个督促自己的作用。所以这次想借着重新开启博客的机会，把之前这些有想法但没落实的事做一做，也算给自己一个阶段性的交代。\n这次做了什么 首先，回顾了一下自己博客的部署方式，我是在 coding 存储博客的源项目，然后博客编译出的静态文件部署在 coding 的另一个仓库。还有之前用的主题 matery 作为一个 git 子模块放在项目内，同时它也单独存放在一个 coding 仓库内，所以一共三个仓库。这样我在任何一台电脑都可以下载源文件进行博客发布，这是之前研究 博客备份 留下来的方案，因为之前有过因为没有对源文件进行 git 管理而导致换电脑后无法继续发博客的惨案。\n其次我在选择博客主题的时候发现 hexo 有很多比较好的周边项目，比如它有自己的 cli 于是就先去看了一下 hexo 的源码，发现有一个比较活跃的团队在维护着 hexo 这一系列项目，比如用新的 ES 特性更新了框架内部的很多实现。\n而且其主题列表也有很多自由开发者在不断贡献自己的作品，以供更多人选择，总体算是一个比较完善的博客引擎。和它类似的博客引擎应该就是 jeklly 了，也就是 jjc 和 颜海镜 两位大神的选择。\n这应该是比较早的博客引擎，基于 bootstrap 的。Bootstrap 大家应该都知道，很早的 UI 框架了，所以 jeklly 也算是上一批的博客引擎。甚至我感觉 hexo 就是国人参考 jeklly 用 node 重写出来的。jeklly 是基于 perl 的，所以相比而言对于 “新前端人” 没有 node 那么熟悉，可能这也成为 hexo 更流行的原因吧。\n列举一些我觉得比较好的主题：\n经典主题 next 应该是很多 hexo 用户去掉默认主题后用的第一个主题 左右排版的 yilia 应该也算比较经久耐用的老主题了 很有冲击力的 butterfly 是很多人的选择，我也挺喜欢的，但是图片元素太多，会压过文字内容的风头 matery ，我的前主题，功能大而全，最大的缺点就是功能太多了，适合尝试，不适合久用 好了，记录好这些可以留作备用的主题，我项目中的这些主题文件也就可以删掉了。\n最终让我决定使用 fluid 是因为 Fluid 发布 1.8.0 版本，优雅与简约共存的主题 这个帖子。这个主题维护的比较好，而且审美兼具美观与大气，是让我觉得比较中意的。\n写在最后 对于博客内容这个东西，不管好的坏的，都是自己曾经写的。历史不应该被遗忘，也不应该被篡改。\n可能每过一个阶段再去看曾经的自己会觉得幼稚不堪，但没有那时的自己，怎么会有今天的自己，反而有这样一份“日记”当作写照不也正是在正视自己成长过程中的每一个阶段么。\n每一个大神也都曾是萌新。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2020-05-02-refresh-blog/","summary":"\u003cp\u003e时隔许久，决定重新打开尘封许久的博客。\u003c/p\u003e","title":"博客重新更新了"},{"content":"前序遍历 /** * @param {TreeNode} root * @return {number[]} */ var preorderTraversal = function (root) { // 迭代法 var stack = []; var ans = []; if (root \u0026amp;\u0026amp; root.val) { stack.push(root); // 利用栈临时存取元素 while (stack.length \u0026gt; 0) { // 从栈顶取出当前元素 var cur = stack.pop(); if (cur !== null) { ans.push(cur.val); // 栈先进后出，所以先放右子树 if (cur.right) stack.push(cur.right); if (cur.left) stack.push(cur.left); } } } return ans; }; 中序遍历 /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function (root) { // 迭代 var ans = []; var stack = []; var cur = root; // cur条件是为了启动循环，因为初始时栈为空 while (cur || stack.length) { // 所有左子树依次入栈（根-\u0026gt;左-\u0026gt;根-\u0026gt;左……直到没有左子树了，根就可以出栈了） while (cur) { // 只有这里有入栈操作，就是判断当前子树是否有左子树 stack.push(cur); cur = cur.left; } // 出栈的是无左子树的节点,因为没有左子树入栈才会走到这里 cur = stack.pop(); ans.push(cur.val); // 没有左子树，并且根被记录后右子树入栈（整棵树的右子树——整体左根右） cur = cur.right; } return ans; // 内层循环在判断左子树的存在 // 外层循环在判断右子树的存在 // 根是否出栈取决于节点是否还有左子树，因为顺序为左根右 // 当节点没有左子树时可以出栈根 // 当无右子树,但栈未空时,是当前节点处理完毕,向父节点前进 }; 后序遍历 /** * @param {TreeNode} root * @return {number[]} */ var postorderTraversal = function (root) { // 迭代 var stack = [], ans = [], cur = root; while (cur || stack.length) { // 整体顺序是依次将所有左子树入栈、所有右子树入栈 // 右子树入栈取决于栈顶元素是否有右子树 // 因为只有当cur有值时才会发生入栈操作 // 而当栈顶元素存在右子树时会将右子树赋予cur促使右子树的入栈 while (cur) { stack.push(cur); // 无论是否当前节点有左子树,都要将当前节点左子树赋值给游标 // 这样才能造成cur为null,以跳出左子树遍历循环 cur = cur.left; } if (stack[stack.length - 1].right) { // 因为外层循环条件是当前游标有值或栈不空 // 所以可以将栈顶元素右子树赋予当前游标,然后将栈顶元素右子树致为null // 这里取了栈顶元素右子树,但没发生出栈行为 cur = stack[stack.length - 1].right; // 因为一旦给 cur 手动赋值栈顶右子树后，下一次再走到这里的if判断时需要绕开(否则会进入这里) // 所以这里给if的判断条件致为null stack[stack.length - 1].right = null; // 这里相当于把树拆分开了,把右子树拆了出来 } else { // 走到这里说明当前节点既没左子树 // (上面的内层循环把所有左子树入栈,当没有左子树可入栈时才继续往下走) // 也没右子树 // 这里是以\u0026#34;左右根\u0026#34;的根身份进入结果集的 ans.push(stack.pop().val); } } return ans; }; ","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-04-16-binary-tree-iteration-methods/","summary":"二叉树的三种遍历（递归+迭代）","title":"二叉树的三种遍历（递归+迭代）"},{"content":"程序员都说自己平时日常的工作就是搬砖，后端说自己就是写写 CRUD，前端说自己就是对着设计稿调调 CSS 参数。但这样永远都无法向高级工程师岗位迈进，也就是业界所说的三年一大坎。如果你工作了三年，还依旧被迫或迷恋于做这些事情，那你的工资仍然没有长进也是没有理由抱怨的。\n那么如何区分一个程序员的水平在一个什么级别上呢，关键的一个指标就是对算法的掌握程度，这就涉及到标题中所说的计算机基础知识。如果你是一个计算机相关专业毕业的本科生，你应该听过或学过《高等数学》和《线性代数》这两门课。当学生的时候你可能会觉得学习这东西对我以后工作有啥用呢，下面我们就来举个例子证明这些理论知识对编程具体有什么用。\n假如给你一个非空数组（注意哦是非空，不需要考虑判空），然后里面是 N 个无序的整数，其中只有一个数只出现了一次，其他的都出现了两次，现在让你找出这个只出现过一次的数。\n那么现在你可能打开 IDE 就开始敲，这问题很常见啊，我遍历一下数组，依次把元素放到另一个空数组中，遇到不存在于新数组的元素，我就扔进去，遇到已经存在于新数组的，那我就不往新数组扔了，而且我还要把新数组里这个数丢出来，因为它不是我要找的只出现过一次的数，等遍历结束，自然最后新数组就只剩下那个只出现过一次的数了。好，那么用代码写出来：\nvar singleNumber = function (nums) { var list = []; for (var i = 0; i \u0026lt; nums.length; i++) { if (list.indexOf(nums[i]) \u0026lt; 0) { list.push(nums[i]); } else { list.splice(list.indexOf(nums[i]), 1); } } return list[0]; }; 实现了，但是有什么问题呢？这时候就是第一个区分程序员水平的分水岭\n普通程序员会觉得这方法很好，代码简洁、易懂、好维护，然后就提交代码了，剩下的交给测试，提了 bug 再解决就好了\n那么这样的程序员如果不是到某一天突然觉悟，如此下去，就会变成业界所说的那种“工作三年但只有一年经验”的人。想要自我救赎，不沦为咸鱼应该怎么办呢？写完这段代码，你盯着它再看看，用批判性的眼光挑挑毛病。或许你就会发现，如果我们要找的数在数组的最后一个，那你前面的数组遍历、数组插入、数组移出的操作就都是在浪费计算机的时间和资源。如果这个待处理的数组有几百万几千万的长度呢，那你要拿到结果可能就会感觉你的电脑卡住了一样，其实它在疯狂地运行你写的代码，去找到结果，只不过在找到结果之前它在疯狂地写操作、读操作，么得办法。\n这就是你导致的啊，你写的表面看上去岁月静好的程序放到实际应用中去跑，有可能就被用户吐槽是辣鸡的 APP。那么想要对得起起公司产品的质量，又想提高自己作为程序员的编程能力，我们再来品这段代码，细细地品。\nif (list.indexOf(nums[i]) \u0026lt; 0) 这里虽然是用语言内置方法，看似没有遍历数组，但实际上是不是又得从头到尾遍历一遍数组才能给出这个判断结果，于是你在for (var i = 0; i \u0026lt; nums.length; i++)的每一次里面又循环了一编数组，这就是所谓的时间复杂度为 O(n 的平方)，想一下，是不是这样，假如要找的数在数组的最后一个，你就要遍历数组 N 次，每一次遍历过程中还要再遍历 N 次，外层套内层，结果就是遍历操作执行了 N * N 次。那么有没有什么办法可以优化循环内部的这个查找操作呢。\n编程语言中是不是不只有数组这种存储结构，不要需求告诉我们要处理数组，我们就用数组去思考，编程语言本身提供了很多强有力的基础工具，数组只是最普通的数据结构，那还有一种可以快速查找的数据结构是什么呢？\n就是字典，意如其名，我们如果使用一个字典找某个字，是不是通过索引目录就可以快速翻到某页找到要找的字，而不是像字谱一样从头到尾找一遍。\n那么我们试着把if (list.indexOf(nums[i]) \u0026lt; 0)这部分用字典替换掉\nvar map = {}; for (var i = 0; i \u0026lt; nums.length; i++) { if (map[nums[i]]) { delete map[nums[i]]; } else { map[nums[i]] = 1; } } return Object.keys(map)[0]; 程序的运行变得稍微快了一点，并且没有影响程序的可读性，只是巧用了不同的数据结构，这是一名中级程序员应该做到的。\n那么有没有更厉害的办法呢，这时就是所谓大牛的思路了（是时候展现真正的技术了！）大牛都是学过高数的，而且能把高数中的知识实实在在用到编程中的（不然怎么说学数学的如果转行做程序员，起步就很高，很多时候大家都是知道一些事实，但是不知道为什么，当你知道足够多的场景后你就会知道为什么）\n看一下这个数学公式2 * （a + b + c） - （a + a + b + b + c） = c 是不是很简单，但是这公式里就藏着我们这道题的答案。不捉迷藏，解释一下，我们换个好理解的场景，给你 N 个物品，然后这里面只有一种类型数量为 1，其他类型的数量都为 2，那么你把所有类型加起来再乘 2 是不是就会比所有物品加起来多出那个只有一个的物品。（原谅我已经尽力了，这个例子也能解释为什么教别人和自己理解东西的难度不能相提并论，因为你理解一个东西，也许某个点你就顿悟了，但你要把你理解的东西清晰传达给别人，你需要想出足够简洁又有说服力的例子来让别人也能通过看你举得例子就能明白你想讲的东西，而且不同听者在听同样的东西时，达到理解的时机也不同。教授不是件容易的事，不然就不会有老师的水平参差不齐了，有时候你学不懂一个东西，也许不是你理解能力的问题，而是你的老师讲解能力的问题）\n那么我们根据这个数学公式编写出如下的代码\nvar sumOfNums = 0, sumOfSet = 0; var set = new Set(); for (var i = 0; i \u0026lt; nums[i]; i++) { if (set.has(nums[i])) { sumOfSet += nums[i]; } else { set.add(nums[i]); sumOfNums += nums[i]; } } 这就是单纯利用数学公式得出的结果，感受到数学的力量了吗。\n但这也没多厉害，因为数学的本质是通过挖掘规律总结出一系列的公式，从而使得计算变得更快，但数学没有数据结构的概念，也就是数学的公式是不提供存储功能，只是一个公式，你给它输入，它给你结果。\n这就要提到计算机为什么会成为第三次工业革命的标志物了，因为计算机不仅可以把人类交给它的公式用电来计算出来，它还可以提供存储。\n存储这个词对于学过计算机的人太熟悉了，从操作系统中学过计算机基本组成中就包括存储，其中包含硬盘用于固定存储随机的数据，即 RAM，内存条用于存储计算机运行时的过程数据，即 ROM，这是物理层面上的存储。\n还有宏观上的存储，比如数据库，用于存储计算机运行产生的数据，对于软件，也就是保存我们使用计算机所产生的一切内容，包括我此时写的这些文字，以及我是谁，我是在什么时间写的这篇文章，还有我的修改时间，修改过几次，这些都存储在数据库中。最初在没有计算机的时候，我们所使用的计算器，也曾提供过存储功能（我指的是 30 块钱以上的那种按键很多的计算器），可能有人没用过，但我当时发现它可以把 135 + 324 的结果先存储到一个存储器中，然后我再读取存储器中的内容继续去乘 3256，因为计算器是顺序输入的，所以如果你直接输入 135 + 324 x 3256，会按照输入顺序计算，也就是会先计算加法，但我们知道这是不对的，当然你也可以使用括号，或者把中间过程记在纸上，我只是举个例子解释当时的计算器就已经有了设计存储这个概念，但其只能说是帮助人类生活加速的一个尝试。\n到后来计算机普及，才真正加速了人们的生活，它把前面铺好的路都整合了起来，成为一个功能巨大的机器。此时应该插播一句每个计算机专业学生都听过的话“编程=算法+数据结构”，到这里你应该知道为什么不是只有算法或只有数据结构。因为只有算法，你无法存储过程数据，而只有数据结构，你无法利用更优秀的数学公式，所以二者结合才是利用计算机为你做事的最佳实践。其产物也就是程序，通过编程所产生，有了程序，人们通过计算机才诞生今天的千姿百态的玩法。\n好了，继续说这个例子，第三种解法利用数学公式，虽然更巧妙，但实际对于计算机运行来说，并没有变得更快，也没有节省内存。\n那么我们想想还有没有其他解法，这就要利用文首提到的另一门计算机课程《线性代数》了，这门课是只针对于计算机专业的，虽然名字里有代数，听着像数学相关的课程，但其讲的内容都是计算机里的数学，说白了就是计算机的核心基本——二进制运算。\n可能稍微了解过的人都知道，电脑虽然功能这么多，但它还是靠电运行的，也就是第三次工业革命是在第二次工业革命的基础上发展而出的，如果没有电，第三次工业革命的一切产物都是空谈，无法运作。你把你家电闸拉了，你看你还能玩游戏吗，你还能看视频听歌吗，都不能。\n计算机是如何利用电实现了这么多功能呢，其实就回到了初中物理——通路和短路，电路正常接电就是通路，电路中间有断开的部分，整个电路都不工作，就是断路，这就是二进制的理论基础，计算机就是通过不断地组合线路板上数量非常庞大的电子元件实现了不同的逻辑组合，那数量有多庞大呢，一开始是没多大的，所以电脑所产生的功能也有限，但后来有了集成电路，计算机主板上能放的电子元件数量爆炸性增长，电脑的功能随之变得越来越多。甚至有一个叫摩尔的外国人提出“集成电路上可容纳的晶体管数量，约每隔两年就会增加一倍”（摩尔定律）这样的预言，这个预言到现在都一直没被打破，的确是按照这个规律发展的。\n这样我们就好理解为什么在今天有了人工智能、大数据，为什么阿尔法狗可以在围棋上战胜人类，答案就是因为同样大小的一台电脑，每过两年，其功能数量就能翻倍，其计算能力地增长更是不可预测。这样就把计算机从组成到发展串起来了，这样再来看看今天你手中的手机，手机中的 APP，是不是就更好理解了。\n那么回归正题，我们看看线性代数是怎么用于日常编程的，线性代数里有一种很强但是稍微有些难理解的运算叫做“异或”，我们试着从名字拆解以理解，“异或”即“不同”+“或”，或运算是线性代数中的基本运算，比如 1 或 0 就是 1，0 或 0 还是 0，1 或 1 也是 1，0 或 1 即是 1，有没有发现规律，这就是初中物理中的并联，如果两条电路是并联的，其中一条电路断掉是不影响整个电路通电的，这相当于什么呢，就相当于备用电器，你用两个插板都接着电，其中一个坏掉是不会影响你正常用电的，代码中也常见，比如\nif (a || b) { console.log(\u0026#34;hello world\u0026#34;); } 这段代码中 a 或 b 有一个为真，就会打印出“hello world”。当然，程序员看到这里还会指出一个知识点就是如果 a 已经是真了，那么计算机就不会再去看 b 是否为真了，就直接打印“hello world”了，俗称“断路”，即或操作中先为真的数会导致后面判断断掉而不去进行判断。当然，这都是程序员关心的小知识了，无足挂齿。\n那么我们继续看“异或”，先说结果，”异或“意味着两个数相同的时候结果就为假，而不同的时候则为真，即 1 异或 0 是 1，0 异或 1 也是 1，但 1 异或 1 是 0，0 异或 0 也是 0，纵观其规律就是两个字”拧巴“，就是两个数闹别扭，我偏不和你一样，这也符合当今时代年轻人的个性，不喜欢苟同，喜欢个性，与众不同。这样记“异或”就够了，就不用去咬文嚼字理解为什么这样的操作叫“异或”，记住“异或”重点在于“ 异”。只要“异”了就是真，“异”了就像在做“或”操作了，而“或”操作的精髓在于“有真则真”（后面这段解释可以不看，免得产生误导）\n那么怎么利用”异或计算“这个东西呢，有以下这样的推导公式：\na ^ (0 == a); a ^ (a == 0); a ^ b ^ (a == a) ^ a ^ (b == 0) ^ (b == b); 一个数和 0 进行异或操作，如果这个数是 0，那么结果为 0，因为 0 异或 0 是 0，那么结果是不是就和这个数相同了，如果这个数不是 0 呢，那就和 0 不同，结果就是这个数了；那如果这个数和自身进行异或操作呢，那永远是 0，因为和自身异或，相当于两个相同的数进行异或；同时多个数进行异或操作允许交换顺序，利用交换顺序，结合上面两个规律，便得出如果有两个相同的数和一个只出现一次的数进行异或操作，最后得出的便是那个只出现过一次的数，也就是本题的解。\n那我们只需要依次将数组的每个数都进行异或操作，即能得到那个”另类“的数，但给我们的是一个数组，我们只能依次遍历每一个数，那么如何记住上一次两个数的遍历结果呢，我们可以用一个变量存储这个值，那么这个数初始化为多少合适呢，只能是 0，假如是别的数，比如是 1，那么数组第一个数如果是 1，那么第一次异或结果就是 0，这样外部数据影响了数组内部数据的异或结果。但如果我们把外部变量初始化为 0，那么数组第一个数无论是几，第一次的异或结果都是数组第一个数本身，因为有理论做支撑（a 异或 0 等于 a）。因为所给数组中只存在出现两次的数和一个只出现一次的数，所以结果必然符合我们的异或推到公式（a ^ b ^ a == a ^ a ^ b == 0 ^ b == b），即多个出现两次的数和一个单独的仅出现一次的数在一次，都进行异或，顺序无所谓，最后只等于那个只出现一次的数。\n最终代码如下：\nvar a = 0; for (var i = 0; i \u0026lt; nums.length; i++) { a = a ^= nums[i]; } return a; 这样地计算既利用了计算机的数据结构，也利用到了算法，是应该优先考虑的解法，至于代码可读性自然没有前面的容易理解，这就要求编程人员掌握足够的计算机基础知识，知道什么”异或“操作，以及”异或“操作可以推导多个数进行”异或“的规律，而“异或”的知识就藏在《线性代数》那本书中。（这里我也不是推荐程序员都去写一些晦涩难懂的代码，从而其他和你水平不相当的人接手骂爹，因为看不懂你写的东西而全部重写。我们提供的是一种思路，作为程序员，应该拥有程序员精神，即是要有意识地提高你程序运行的速度，并使用尽可能少的内存资源，这种追求极致的精神其实在任何行业都是高手的基本素养）\n总算是首尾呼应，自圆其说了。曾经有很多人说大学学习的东西和毕业后工作的内容没什么联系，也就是大学学的东西都没什么用。我也曾慢慢加入到这样的呼声中，但可能再过一个阶段，你回过头再去看一切，也许就会理解到这世上不可能存在没有任何联系的事物，一切都在一个大的网络联络之中。如果你觉得两个事情没有任何联系，那可能只是你还没找到联络其两物之间的那复杂的联系。\n虽然标题是说计算机基础知识，但是字里行间插播了很多其他的内容，这也是为什么我把此文发在这里，而不是技术论坛，因为它的定位是杂谈，不算是技术文章，面向群体也是大众，所以尽量把很多计算机专业知识用白话解释，而不是一带而过。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2020-04-02-about-programmer-basic-learning/","summary":"因为一道 leetcode 题而引发的思考。","title":"为什么程序员要学习计算机基础知识"},{"content":"读 重新介绍 JavaScript（JS 教程） 一文整理的脑图\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-03-15-reintroduce-javascript/","summary":"读‘重新介绍 JavaScript（JS 教程）’一文整理的脑图","title":"重新介绍JavaScript"},{"content":"前端三大框架有什么不同\nangular Vue React 开发者 谷歌 Evan You Facebook 时间 2010 2014 2013 当前版本 9 2.6.x 16.x 使用者 谷歌 Facebook、Uber 阿里、Gitlab 语言 ts vue3计划引入ts Facebook 重大变化 2016年的Angular2，去掉了名字AngularJS的JS 变动性 每6个月一次主要更新 注重稳定性，因为twitter和airbnb在用 组件 被称为指令，只是DOM元素上的标记，Angular可以追踪并附加特定的行为。Angular将组件的UI部分分离为HTML标记的属性，并将它们的行为以js代码的形式表示出来 高度自定义，允许组合UI和行为，也支持使用预处理器取代CSS，便于集成其他库，例如Bootstrap 组合了UI和行为，同样一块代码同时负责创建UI元素和指示它的行为 学习曲线 陡峭，是一个完整的解决方案，需要学习ts和MVC等概念，投资回报在于可以理解程序前端是怎样工作的 提供高度自定义性，学习更容易，也因此允许丑代码，会导致代码调试和测试困难 不是完整的框架，高级功能需要第三方库，所以学习使用React并不意味着你在使用最佳实践 总结 最成熟，后台支持良好，完整的包。但是陡峭的学习曲线劝退了很多初学者。适用于大型项目，或已经在使用ts的团队 新成员，没有公司做支撑，但过去几年已经做的足够好，中国大公司在用，未来可期。适合喜欢简洁灵活的人群 足够成熟，拥有大量社区贡献者，具备广泛的接受度。工作市场好，前途一片光明。适用于初次学习前端框架的人，并且它和其他框架的集成能力适合喜欢代码灵活性的人 Watchers 3.2K 6K 6.6K Stars 57K 157K 144K Forks 15.9K 23.7K 27.6K 贡献者 1089 289 1361 参考\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-03-09-frontend-framework/","summary":"\u003cp\u003e前端三大框架有什么不同\u003c/p\u003e","title":"三大框架对比"},{"content":"小知识: 关于 z-index 的最大值\n小知识: 关于 z-index 的最大值 2147483647 记住这个值，win32 下 int 的最大值\n2 1 4 7 4 8 3 6 4 7 ！\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-01-20-css-zindex/","summary":"\u003cp\u003e小知识: 关于 z-index 的最大值\u003c/p\u003e","title":"关于z-index的最大值"},{"content":"关于 js 反转数组\n/** * [ 吃瓜][ 加油][ 汗][ 天啊][ Emm][ 社会社会][ 旺柴][ 好的][ 打脸][ 哇] * 这样一个字符串能不能去掉其中所有的空格 */ function removeBlanks(target) { console.log(\u0026#34;处理前：\u0026#34; + target); const result = target.replace(/\\s/g, \u0026#34;\u0026#34;); console.log(\u0026#34;处理后：\u0026#34; + result); console.log(\u0026#34;原数据：\u0026#34; + target); } /** * [吃瓜][加油][汗][天啊][Emm][社会社会][旺柴][好的][打脸][哇] * 能不能把顺序调过来变成 * [哇][打脸][好的][旺柴][社会社会][Emm][天啊][汗][加油][吃瓜] * 空间复杂度较差，使用了两个栈 */ function revert(target) { console.log(\u0026#34;处理前：\u0026#34; + target); let stack = []; let newStack = []; target.split(\u0026#34;\u0026#34;).forEach((char) =\u0026gt; { // 识别到关闭符且栈中有开始符则出栈 if (char === \u0026#34;]\u0026#34; \u0026amp;\u0026amp; stack.includes(\u0026#34;[\u0026#34;)) { stack.push(char); // 将字符组装成字符串，从二维数组头部装入 newStack.unshift(stack.join(\u0026#34;\u0026#34;)); // 关键步骤：清空栈，否则每一次向二维数组装入时都冗余之前装过的数据 stack.length = 0; } else { stack.push(char); } }); let result = \u0026#34;\u0026#34;; if (newStack.length \u0026gt; 0) { result = newStack.join(\u0026#34;\u0026#34;); } console.log(\u0026#34;处理后：\u0026#34; + result); console.log(\u0026#34;原数据：\u0026#34; + target); } // 程序入口 function main() { var str = \u0026#34;[ 吃瓜][ 加油][ 汗][ 天啊][ Emm][ 社会社会][ 旺柴][ 好的][ 打脸][ 哇]\u0026#34;; // removeBlanks(str); // 处理前：[ 吃瓜][ 加油][ 汗][ 天啊][ Emm][ 社会社会][ 旺柴][ 好的][ 打脸][ 哇] // 处理后：[吃瓜][加油][汗][天啊][Emm][社会社会][旺柴][好的][打脸][哇] // 原数据：[ 吃瓜][ 加油][ 汗][ 天啊][ Emm][ 社会社会][ 旺柴][ 好的][ 打脸][ 哇] var str2 = \u0026#34;[吃瓜][加油][汗][天啊][Emm][社会社会][旺柴][好的][打脸][哇]\u0026#34;; revert(str2); // 处理前：[吃瓜][加油][汗][天啊][Emm][社会社会][旺柴][好的][打脸][哇] // 处理后：[哇][打脸][好的][旺柴][社会社会][Emm][天啊][汗][加油][吃瓜] // 原数据：[吃瓜][加油][汗][天啊][Emm][社会社会][旺柴][好的][打脸][哇] } main(); ","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-01-15-js-revert-array/","summary":"\u003cp\u003e关于 js 反转数组\u003c/p\u003e","title":"反转数组"},{"content":"滑动穿透\n情况列举 body 无滚动，弹层无滚动 body 无滚动，弹层有滚动 body 有滚动，弹层无滚动 body 有滚动，弹层有滚动 body 无滚动，弹层无滚动 弹层出现时，body 置为超出隐藏，固定布局，弹层关闭后恢复\n打开弹层\nlayer.style.display = \u0026#34;block\u0026#34;; document.body.style.overflow = \u0026#34;hidden\u0026#34;; document.body.style.position = \u0026#34;fixed\u0026#34;; // 【弊端】因为加了fixed，就会自动回滚到顶部 关闭弹层\nlayer.style.display = \u0026#34;none\u0026#34;; document.body.style.overflow = \u0026#34;auto\u0026#34;; document.body.style.position = \u0026#34;static\u0026#34;; 问题 用户在超出一屏高度的位置点开弹层，页面会因为 fixed 布局回到顶部\n解决 可使用 swiper 控制页面一页一屏\nbody 无滚动，弹层有滚动 弹层出现时，body 置为超出隐藏，固定布局，样式中增加允许滑动，弹层关闭后恢复\n打开弹层\nlayer.style.display = \u0026#34;block\u0026#34;; document.body.style.overflow = \u0026#34;hidden\u0026#34;; document.body.style.position = \u0026#34;fixed\u0026#34;; // 【弊端】因为加了fixed，就会自动回滚到顶部 overflow-y: scroll; -webkit-overflow-scrolling: touch; /* 解决在IOS上滚动惯性失效的问题 */ 关闭弹层\nlayer.style.display = \u0026#34;none\u0026#34;; document.body.style.overflow = \u0026#34;auto\u0026#34;; document.body.style.position = \u0026#34;static\u0026#34;; 问题 滑动到页面顶部或底部时仍会发生穿透\n解决 当滑动到边界时禁止滑动\nbody 有滚动，弹层无滚动 阻止弹层的 touchmove 事件默认行为\nbody 有滚动，弹层有滚动 检测 touchmove 事件，如果 touch 的目标是弹窗不可滚动区域（背景蒙层）就禁掉默认事件，反之就不做控制\n参考 滚动穿透的 6 种解决方案【已自测】 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2020-01-15-scroll-strike/","summary":"\u003cp\u003e滑动穿透\u003c/p\u003e","title":"滑动穿透（遮罩下不允许滑动）"},{"content":"mpvue小程序迁移为uniapp项目A(用于标识项目)，同时编译部署微信小程序和微信服务号H5\n问题描述 页面刷新时会导致vuex内状态失效，但不准备在页面刷新前将vuex备份到localStorage等临时存储方式\n由于小程序使用开发者工具刷新时会回到项目首页（pages 中的第一个索引），于是将H5交互保持与小程序一致，使用微信内置刷新时项目跳转回首页。\n处理方式为：\n在 App.vue 的onLaunch（项目生命周期）中增加以下逻辑\n// #ifdef H5 const visit = sessionStorage.getItem(\u0026#34;appvue\u0026#34;); if (visit === \u0026#34;true\u0026#34;) { wx.reLaunch({ url: \u0026#34;/pages/home/home\u0026#34;, }); } else { sessionStorage.setItem(\u0026#34;appvue\u0026#34;, true); } // #endif 代码解释：\n条件编译控制此逻辑仅在 H5 编译方式下生效\n使用sessionStorage判断页面是否在进行刷新操作（在一次会话中，第一次进入项目时存储一个状态appvue，当使用微信浏览器内置刷新操作时，会话未过时，但项目会重新触发项目生命周期onLaunch，此时发现sessionStorage中包含appvue的状态，则执行页面跳回首页的交互）\n但项目中存在webview组件\n当项目中某个页面通过webview组件打开部署在另一个地方的H5项目 B 页面时，存在以下交互：\nB (webview)某页面点击按钮跳转到 A (小程序/H5)的页面，点击返回，会直接以访问 A 项目公网地址的方式进行跳转（类似https://www.xxx.com/A）\n此时跳回 A 会触发项目 A 的 App.vue 中的 onLaunch （项目生命周期）执行，但会话未过时，会触发跳转首页的逻辑，导致因为从 webview 跳转到项目 A 而跳回项目首页，而不是指定的路由，故存在问题。\n解决方案 方案一 在 webview 组件加载时去掉 sessionStorage 中的标识，这样当从 webview 访问项目 A 时不会刷新回首页\nweb-view.vue\nonLoad(query) { this.url = decodeURIComponent(query.url) const visit = sessionStorage.getItem(\u0026#39;appvue\u0026#39;); if (visit === \u0026#39;true\u0026#39;) { sessionStorage.removeItem(\u0026#39;appvue\u0026#39;); } } App.vue\nonLaunch(e) { // #ifdef H5 const visit = sessionStorage.getItem(\u0026#39;appvue\u0026#39;); if (visit === \u0026#39;true\u0026#39;) { wx.reLaunch({ url: \u0026#39;/pages/home/home\u0026#39; }); } else { sessionStorage.setItem(\u0026#39;appvue\u0026#39;, true); } // #endif } 方案问题\n从 webview 访问项目 A ，App.vue 执行 onLaunch 时不会跳转首页，但会记录 appvue ，此时页面返回到 webview 后再次进入，sessionStorage 检测到 appvue 有值，则仅第一次进入 A 时不会跳转首页，返回再进入时还是会跳转\n方案二 维护一个白名单，内容是在 webview 中访问的 A 项目路由，放行不进行跳转首页\nApp.vue\nmethods: { /** * 是否是从webview进行跳转的页面 * @return 是否进行跳转 */ pagesFromWebview(e) { let skipFlag = false; // 维护白名单控制在webview中访问的页面不做回到首页的跳转 const notFreshPages = [ \u0026#39;iou-reason\u0026#39;, \u0026#39;upload-reason-imgs\u0026#39;, \u0026#39;info-fill\u0026#39;, \u0026#39;iou-info\u0026#39;, ]; if (e \u0026amp;\u0026amp; e.path) { const list = e.path.split(\u0026#39;/\u0026#39;); if (list \u0026amp;\u0026amp; list.length \u0026gt; 0) { // 取最后一个作为路由标识 const flag = list[list.length - 1]; console.log(\u0026#39;==========flag: \u0026#39; + flag); // 如果该路由在不刷新的名单中则不进行回到首页的跳转 if (notFreshPages.includes(flag)) { skipFlag = true; } } } return skipFlag } }, onLaunch(e) { // #ifdef H5 const visit = sessionStorage.getItem(\u0026#39;appvue\u0026#39;); // TODO: 弃用维护白名单的方式，改用更好的方式 if (visit === \u0026#39;true\u0026#39; \u0026amp;\u0026amp; !this.pagesFromWebview(e)) { wx.reLaunch({ url: \u0026#39;/pages/home/home\u0026#39; }); } else { sessionStorage.setItem(\u0026#39;appvue\u0026#39;, true); } // #endif } 方案问题：需要维护白名单，当白名单内的路由变更时可能会因为遗漏维护而导致问题再次出现\n方案三 弃用白名单，增加第二个 sessionStorage 状态，当进入 webview 时禁用跳回首页的开关，离开 webview 时关闭禁用\nweb-view.vue\nonLoad(query) { this.url = decodeURIComponent(query.url) // 进入webview后禁止【页面刷新回首页】 const notfresh = sessionStorage.getItem(\u0026#39;notfresh\u0026#39;); if (!notfresh) { sessionStorage.setItem(\u0026#39;notfresh\u0026#39;, true); } }, onUnload() { // 从webview页返回到本项目时触发 this.url = \u0026#39;\u0026#39; // 离开webview时解禁【页面刷新回首页】 const notfresh = sessionStorage.getItem(\u0026#39;notfresh\u0026#39;); if (notfresh === \u0026#39;true\u0026#39;) { sessionStorage.removeItem(\u0026#39;notfresh\u0026#39;); } }, App.vue\nonLaunch(e) { // #ifdef H5 const visit = sessionStorage.getItem(\u0026#39;appvue\u0026#39;); const notfresh = sessionStorage.getItem(\u0026#39;notfresh\u0026#39;); if (visit === \u0026#39;true\u0026#39; \u0026amp;\u0026amp; notfresh !== \u0026#39;true\u0026#39;) { wx.reLaunch({ url: \u0026#39;/pages/home/home\u0026#39; }); } else { sessionStorage.setItem(\u0026#39;appvue\u0026#39;, true); } // #endif } 存在问题，无法对 webview 跳去的 A 项目页面做刷新后跳转首页的控制\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2020-01-10-mpvue/","summary":"\u003cp\u003e\u003ccode\u003empvue\u003c/code\u003e小程序迁移为\u003ccode\u003euniapp\u003c/code\u003e项目\u003ccode\u003eA\u003c/code\u003e(用于标识项目)，同时编译部署微信小程序和微信服务号\u003ccode\u003eH5\u003c/code\u003e\u003c/p\u003e","title":"mpvue刷新问题"},{"content":"关于 HTTP CORS\nCORS 全称为“跨域资源共享”（Cross Origin Resource Share）\n官方资料 MDN CORS\n本质 一种机制 使用额外的 HTTP 头 跨域 【域名】、【协议】、【端口】任意一个不同均为跨域\nhttp://www.xx.com/\nhttp://222.134.123.134:8080/\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-01-09-http-cors/","summary":"\u003cp\u003e关于 HTTP CORS\u003c/p\u003e","title":"HTTP访问控制（CORS）"},{"content":"翻页时钟实现调研\n调研 已有同名 iOS app 效果图 需求 进入即全屏 翻页时钟 方案 微信内 h5 index.html 微信小程序 原生 app 技术选型 h5(微信内打开，域名问题) flutter(发布问题？) rn(expo) 实现问题 全屏 横屏显示 翻页动效 发布 参考 前端 H5 横屏 独特处理方案详解 手机上如何让页面强制横屏 html5 数字翻页时钟代码 如何让 H5 页面在手机浏览器里和微信全屏显示 Flutter——启动页 splash 全屏效果实现 Expo like tool for flutter 一款很酷的 CSS3 翻页时钟动画 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-01-09-clock-web/","summary":"\u003cp\u003e翻页时钟实现调研\u003c/p\u003e","title":"翻页时钟"},{"content":"关于正则表达式学习\n应该大多数学习过正则的人都看过正则表达式 30 分钟入门教程，但这东西总感觉学一遍忘一遍，总做不到拿来一个正则匹配就能看懂，遂再复习一遍。\n规则 解释 补充解释 举例 . 除换行符以外的任意字符 \\w 字母、数字、下划线、汉字 \\w-\u0026gt;\u0026ldquo;word: A、b、3、_、张 \\s 空白符 \\s-\u0026gt;\u0026ldquo;space\u0026rdquo; \\d 数字 \\d-\u0026gt;\u0026ldquo;digit\u0026rdquo; 1 \\b 单词开始或结束 \\b-\u0026gt;\u0026ldquo;boundary\u0026rdquo; ^ 字符串开始 $ 字符串结束 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2020-01-08-regexp/","summary":"\u003cp\u003e关于正则表达式学习\u003c/p\u003e","title":"正则表达式"},{"content":"Headers # Header 1 ## Header 2 ### Header 3 Header 1 Header 2 Header 3 Unordered Lists - Bulleted - List Bulleted List Ordered Lists 1. Numbered 2. List Numbered List Fonts **Bold** Bold\n_Italic_ Italic\n`Code` Code\nLinks [Link](url) Link Name\n![LinkName](https://avatars.githubusercontent.com/u/23159565?v=4) Line para1 *** para2 para1\npara2\nRemove ~~Remove this line~~ Remove this line\nTable :--- 代表左对齐 :--: 代表居中对齐 ---: 代表右对齐 left center right default 代表左对齐 代表居中对齐 代表右对齐 默认 a b c d | left | center | right | default | | :--- | :--: | ---: | --- | | 代表左对齐 | 代表居中对齐 | 代表右对齐 | 默认 | | a | b | c | d | Detail \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;View More\u0026lt;/summary\u0026gt; Hello, I\u0026#39;m here! :stuck_out_tongue_closed_eyes: \u0026lt;/details\u0026gt; Hello, I\u0026rsquo;m here! \u0026#x1f61d;\nComment(hide content) [//]:#something [^_^]:#something Fault Use Nested Use Don\u0026rsquo;t use nested markdown symbols or you won\u0026rsquo;t get your expected effect, because maybe github or something else will add extra actions to your markdown symbols like ###, for example there will comes to a link symbol motion when you hover around the header following:\ne.g.\n- ### Something Something Advanced Use Todo list - [ ] Mercury Mercury ","permalink":"https://barnett617.github.io/wilson-blog/posts/2020-01-03-markdown/","summary":"markdown 基本使用","title":"markdown使用"},{"content":"第一部分：如何使用 vscode 调试 node 程序 一、准备待调试代码 const Koa = require(\u0026#34;koa\u0026#34;); const app = new Koa(); // logger app.use(async (ctx, next) =\u0026gt; { debugger; await next(); const rt = ctx.response.get(\u0026#34;X-Response-Time\u0026#34;); console.log(`${ctx.method} ${ctx.url} - ${rt}`); }); // x-response-time app.use(async (ctx, next) =\u0026gt; { const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set(\u0026#34;X-Response-Time\u0026#34;, `${ms}ms`); }); // response app.use(async (ctx) =\u0026gt; { ctx.body = \u0026#34;Hello World\u0026#34;; }); app.listen(3000); 二、配置 vscode node 调试自动关联开关 打开 vscode 设置（mac 下可通过 command + , 快捷打开） 搜索 Auto Attach 设置为开（on） 三、运行程序携带检查参数 node --inspect=0.0.0.0:9229 index.js node --inspect-brk index.js 四、Chrome 配置 在 Chrome 地址栏输入 chrome://inspect 点击 Open dedicated DevTools for Node 将端口号修改为启动程序时指定的端口号 在 Chrome inspect 菜单中找到 Target 下找到运行的 node 程序 点击 inspect 五、Chrome 作为调试客户端与程序建立关联 可在 vscode 中看到程序会在断点处停住\n参考链接 Debug Your Node.js App in 60 Seconds Node.js debugging in VS Code Debugging Guide 第二部分：如何调试 vue 一、为开发模式启动脚本添加参数 为 package.json 中 script 组内的 dev 脚本添加 --sourcemap 参数\n修改后为(随 vue 的更新可能会有稍许不同)：\n\u0026#34;dev\u0026#34;: \u0026#34;rollup -w -c scripts/config.js --environment TARGET:web-full-dev --sourcemap\u0026#34; 二、修改 index.html 中关于 vue 编译包的引用 选取 examples 中任一 index.html, 修改其原本对于 vue 包的引用为 \u0026lt;script src=\u0026quot;../../dist/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n修改对比：\n修改前\n\u0026lt;script src=\u0026#34;../../dist/vue.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 修改后\n\u0026lt;script src=\u0026#34;../../dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 三、在修改过 vue 包引入的 index.html 文件所引入的 app.js 中增加 debugger created: function () { debugger this.fetchData() }, 四、安装简易服务器工具并启动 npm i -g http-server hs -p 8100 五、使用 Chrome 访问被 http-server 代理的文件目录 http://localhost:8100/examples/ 按需调试 打开控制面板 source 在左侧找到 src 目录 即 vue.js 源码文件，根据自己需求断点调试即可\n参考链接 vuex 源码学习 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-12-17-debug-node-vue/","summary":"如何用 vscode 调试 node 程序和 vue 源码","title":"如何用vscode调试node程序和vue源码"},{"content":" 2019 年快结束了，又来到一年一度的复盘总结时\n这一年又学习了很多东西，但又感觉没什么，东西多是因为技术的更迭实在是快。常常会想，为什么前端会有这么多东西呢，但是站在更高的角度去看，只是前端东西多吗，后端呢，其他行业呢？其实都很复杂，整个人类社会都是复杂的，而且是螺旋式地由简单不断变得复杂。\n对于做技术的，可能是你掌握的技能越来越多，对于其他行业可能是掌握的话术、套路、方案越来越多。但其实，由简单变得复杂是必然的，是趋势所在，即使你不想变得复杂，大环境也会推着你向前走。此时会显得化繁为简，回归简单是多么难得。\n工作如此，你能够掌握更多的技能是由时间决定的，而能否拥有化繁为简的能力才是你的智慧所在。做人也如此，人的一生基本都是一个从简单变复杂，再从复杂回归简单的一个过程。\n“人之将死，其言也善” ——《论语》\n所谓大道至简，你能否从一个点出发，引申类比出其他所有你想要掌握的知识。\n霍金一生都在研究能否通过一个公式来描述全宇宙的规律，它叫做万物理论。最后他把目标锁定在【时间】这个点上。能否找到解释宇宙所有规律的钥匙，人类可能还需要很久很久的探索。\n如果不能，你看到的则是迎面而来越来越多的东西。但如果你能，你会看到世界是静止的，历史上从没有新鲜事物产生。但是能够做到这一点的人有多少呢？很少。做到的一些人被称为圣人。我们作为平凡的普通人，可能究其一生都在探索如何成为那样的人，其实我们都做不到。\n我们能做到在某一个领域有一定的成就积累就已经会被认为是成功者了，这就是大众的宽恕。\n本以为这篇总结会是对自己技术上的进步做一个复盘，但不知怎么的就上升为行而上的人生思考。\n回归技术本身，从事开发两年多，感受颇多，也感觉到自己的进步。\n我觉得作为一个技术人员，首先要学习的不是什么什么技术栈，而是认识自己。因为技术栈是死的，它就在那，虽然一直在变化，但它也是可观察、可追溯、有来源的变化。但人不同，你可能这五年还是一个技术员，但五年后你变成了另一种角色，另一种职业，比如你可能去开饭馆、做青旅老板、做自由摄影师等等。人的行为是很难预测的，因为受 思想 + 情感 二者的驱使。\n认识自己首先要了解自己的以下几个方面： 自己之前学过什么 擅长什么 对什么感兴趣并能一段时间内保持激情 以后要做什么、为什么 试着回答这几个问题，是不是感觉比回答面试官问你的面试题要难。\n因为面试题答不上来，你回来之后可以通过网上搜索就可以拿到答案，但这些问题的答案呢，你可能要安静地思考，和自己长期的对话才能得出，而且即使你这一刻把这些答案写下来了，你再过一段时间，可能会给出不同的答案，因为人的想法是会变的。 但那些技术难题的答案呢，显然一个答案是会在很长一段时间内都是固定的，即使会出现更好的方案，也是基于之前已有的方案而演进出的更优解决方案。\n那么我来回答自己所提出的这几个问题\n首先，我之前学过什么？ 我是一个理科生，所以肯定是学过数理化的，但是学的一般，或者说考试能力一般。但是我对学过的东西都乐于用在生活中的理解，比如学过生物，我会思考人的胖瘦是因为摄入食物，经过食物不同组成成分分解成热量和脂肪，如果消耗低于摄入，就会囤积脂肪，从而变胖；学过化学，我知道做鱼要加醋和酒，是因为醋的成分是酸，酒的成分是醇，二者混合会生成的脂类会有香味，等等类似这种例子。我觉得学习科学的目的是帮助人类认识这个世界的，前人通过实验总结出一些规律留给后人，是为了后人不再花很多的时间去研究为什么会是这样。所以如果你不是想去发现更多的自然规律，你大可不必去重头了解一遍之前的人是怎么一步一步得出现在这些结论的过程，而是直接用前人得出的结论就足以很好地和这个世界打交道了。\n当然，那些的确想在人类历史上做出自己贡献的人，我不讨论。因为我不是那其中一员，我没有资格评头论足。\n然后我大学学的是软件工程，计算机体系的一个分支，由软件和工程组成，软件主要学习软件是怎样构成的，通过使用编程语言按照人类的书写习惯编写程序交给操作系统，通过编译器解析成计算机所能执行的指令，最终转化为电路接通与断开的组合来控制电子元件所组成的设备去按照预期工作，这个设备叫电脑。工程就是生产这个软件的过程管理，使其能够高效、成体系地服务于人，比如我可以用一套模式把任何人类需求做成一个软件放在电脑上来服务于人。\n其中包括以下这些环节：\n需求整理：把想让计算机做的事情整理成人能看懂的文字或图，可以用于一个软件从没有到诞生的指导和参考 环境部署：操作系统、网络架设、代码运行环境 程序编写：不同编程语言的使用和组合，按照既定逻辑把需求转化为计算机程序 软件测试：也就是流水线工作中的质检环节，所以现在的测试工程师都叫 QA(Quality Assurance，质量保证) 运营售卖：这是软件成为如今商业社会一份子的重要环节，也是商业变现策略的运作环节 程序维护：程序和人一样，不可能从始至终健康，有个小病小灾的不能否定软件本身原有的价值，而应该遇到问题处理问题，保持它能一直很好的为人类服务。 最后就是能把上述所有环节整理成一个体系，也就是软件解决方案。这样，程序才不会只是跑在命令行输出 Hello World! 的小打小闹，被当作玩具。 软件是能改变世界的，不然怎么会成为第三次工业革命中的核心成员。同样这样一个东西，有人只能看到它就是程序员写出来跑在电脑上的程序，而有的人就能看到它无限的价值和可能。\n视角决定视野\n第二个问题，我擅长什么？ 我擅长整理和总结，从小我就能发现自己对于家里的杂物我会把它们分门别类的整理，虽然有时结果还是很乱，但我会不断地研究怎么样能让东西很好的在我的控制之下，也就是我想找什么应该从哪里找，被大人动了东西我能不能察觉到。 至于总结，是我长大后才发展出的属性，我擅长通过较长一段时间的观察和积累，思考周围人事物的变化，并总结其中的规律。\n比如 2019 年，我观察了公司的人是怎么获得晋升的，晋升了的人具有什么样的特点，他们做了哪些事，评委视角是怎么考量晋升者的，他们期望我们是怎样的，或者他们认为我们怎么样就会认为我们具备晋升的资格。于是在 2019 年结束前，我获得了自己工作以来的第一次晋升。\n第三个问题，我对什么感兴趣？ 我喜欢和事物打交道，所以我选择了走开发这条职业路线。 但这也因为成长过程的原因，我曾经是一个不擅长处理人之间关系的人，而且我所成长的环境，是一个人情世故很落后的地方。 对于我看到的那些阿谀奉承、灯红酒绿、推杯换盏，我觉得不适应，也有些拒绝参与其中，所以我选择了进入相对简单的技术群体。 但是时过境迁，我发现还是逃不过那些繁文缛节，这些东西可以理解为人们所说的游戏规则，也可以理解为任何事物都具有其一定的规则。\n没有规矩，不成方圆。——《孟子》\n所以这可能也是一种成长吧，就是心态上的转变，从以自己的角度看待外部世界，到去适应这个世界，迎合所处的环境，接受“没有绝对的公平”这样的观点。 这也正常，这不是妥协，从而沦为一条咸鱼，而是正确的和这个世界相处的方式。 那些拒绝和大家一样的人，最终都没了，比如尼采。\n最后一问，我以后要做什么，为什么。 这个其实我还没想好，有人说做长期的计划是不切实际的，也有人说没有长远的计划会迷失，对于这两种观点我还在摇摆。 而且对于工作尚短的我，的确很难在这个节点说自己以后一定会做什么，做到什么，那很不负责任，也会限制我本可以有的其他可能。 所以我目前只会定期思考复盘前面走过的路，来给自己后面的前进打气，增加笃定和从容，减少怀疑和困惑。\n没有工作总结，因为目前工作是在为别人做事，收获自己的成长。\n没有技术总结，因为还只是个工作不满三年的新手，网上那么多人已经总结过了，看看别人写的就很好。\n此文仅是一篇关于个人思想的整理。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-12-11-review-of-2019/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2019 年快结束了，又来到一年一度的复盘总结时\u003c/p\u003e\n\u003c/blockquote\u003e","title":"2019年终总结"},{"content":"js 全称是 javascript，它既不是 java 的嫡系，也不单单是一门脚本语言（script 直译）。\n暮色 编程语言的强大程度决定于它能使用的场景和所能处理的事情，比如现在这么多软硬件程序，都需要编程语言来编写程序逻辑使之能够提供功能。也因为使用场景之多以及环境之复杂，所以才诞生了不同的编程语言去处理不同的场景事务，就好比人类的职业划分是为了让人类根据自身属性不同去承担不同范围的工作。\n编程语言自诞生之初就是对人类世界的一种抽象。不同的编程语言（用于人类编写程序的计算机语言）都是对于计算机所能识别的基础指令的一些封装，语言之不同在于封装形式之不同。比如一个人，既能当警察，也能做医生，还能教书育人当老师，那么这个人可不可以这些都做，可以。但也有人选择只做一件事情。\n新月 编程语言也类似，一种编程语言既可以用于浏览器编程，也可以用于服务器编程，还可以用于家用电器内部程序的硬件编程，那它可不可以都做呢，可以。\n但大多数人的记忆中，js 还是仅适用于浏览器编程的。那么为什么 js 还可以用于浏览器以外的环境进行运行呢，这依赖于其所运行的宿主环境，也就是一个托盘。就好像你用微波炉加热一盘菜，你直接把菜倒在微波炉里加热，虽然菜能热，但是没法吃了，但如果你把菜放在一个盘子里，再把盘子放进微波炉加热，这样微波炉就能很好地服务于你。\njs 在各种环境运行也如此，既然服务器没有解析 js 的先天功能，就用服务器能解析的 c++写一套环境，然后这套环境里定义了解析 js 的规则，从而使得放在这个环境里的 js 可以为服务器所运行，这个环境就叫做 nodejs。\n那么其他环境呢，比如硬件设备，都可以拥有类似于 nodejs 的环境来使得 js 可以成为程序界的通用语言。但是功劳在于这些环境，也就是 js 引擎。那么当 js 可以变得如此通用，畅行于程序的世界，就不禁想到，js 于编程语言，正如英语于人类语言一般。\n比如你学英语，那么你走到世界大部分地区，都是能够与当地交流的，因为各个国家基本都拥有会英语的人，这些人就相当于 js 引擎，也就是中间翻译者，他们能听懂英语，就可以提供你要的服务。\n月食 那么为什么有这样通用语言存在的必要呢？我们反过来想，假如你去日本要学日语，你去法国要学法语，你去俄罗斯要学俄语，那岂不是你每去一个国家都要提前花时间学一门新的语言，这样成本很高，而且没必要。\n但是如果你学习一门国际上认可的通用人类交流语言，也就是英语，那么你基本上可以畅行无阻，岂不美哉。\n那么回到编程语言上，js 目前就有成为编程语言界通用语言存在的趋势，因为当你编写运行在浏览器的程序之时，你会使用 js，曾几何时你可能还可以选择另外一种语言叫 jscript，但随着历史的发展，它已经被 js 挤下去消亡了，就像百度外卖一样。\n然后当你编写服务端程序的时候，如今你同样可以使用 js，曾经你的选择可能会是 java、c、c++、c#、python、go 等等，但如果告诉你，他们能做的事情 js 都能做，你会不会感到高兴，因为你只会英语（只会 js）。\n破晓 曾经 js 只被当作一门玩具语言，因为它仅用于处理客户端一些简单不重要的逻辑，大多数用户使用的程序功能都是由服务端所提供的。但是现如今 nodejs 告诉你，我可以帮助你把 js 写的逻辑运行在服务器环境，你是不是可以考虑把前后端编程语言统一为 js 一种。\n那么当你开始心动，决定只用这一种语言编写程序的时候，不禁会想，它真的能完全取代别的语言，实现它们所提供的功能吗，那么便需要讨论到第二部分，即 js 所具备的功能。\n比如 java 可以利用计算机操作系统所提供的多线程来共用同一进程的内存资源，从而提高程序运行效率，同时处理多项事务的能力，那么 js 可以吗？\n预知后事如何，且听下回分解。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-12-05-why-2020-learn-js/","summary":"\u003cp\u003ejs 全称是 javascript，它既不是 java 的嫡系，也不单单是一门脚本语言（script 直译）。\u003c/p\u003e","title":"2020年你为什么要学习js"},{"content":"一些做事方法论的总结\n注重细节，80%的问题会集中出现在被轻视或忽略的那 20%部分 切忌舍近求远，当问题亟待解决时应先解决问题，再考虑旁枝末节 切忌破窗效应（当一个窗户破掉之后，人们并不会想着把它修好，而是使它变得更加糟糕），做事要避免给后人留坑，如果已经遇到坑应试着解决，而非继续埋坑。 程序员思考方式 偶然复杂度 优秀程序员的开发效率是普通程序员的 10 倍（工作方法和工作习惯共同决定） 解决问题的步骤 明确真正的目标 分治（大而化小） 沟通（减少理解偏差） 自动化 读代码 我们写不出来，是因为看的还不够多，当见多识广以后，设计模式、算法、脚本、框架都将跃然编辑器上。 读代码有助于理解框架原理，学习优秀的编程范式、思路，获得比看书更加直观的码感训练（参考英语口语的语感） ","permalink":"https://barnett617.github.io/wilson-blog/notes/2019-12-03-do-things-methods/","summary":"\u003cp\u003e一些做事方法论的总结\u003c/p\u003e","title":"做事方法论总结"},{"content":"突然有感而发想到这样一个话题——什么样的人适合做技术\n直接说例子\n当遇到一个技术问题后的解决思路\n比如浏览器里报出了这样的错“Access to XMLHttpRequest at \u0026lsquo;https://xxx.com\u0026rsquo; from origin \u0026lsquo;http://xxx.com\u0026rsquo; has been blocked by CORS policy: No \u0026lsquo;Access-Control-Allow-Origini\u0026rsquo; header is present on the requested resource”\nA 同学:之前不认识这种提示，然后找到相关人员了解到“哦，原来这是跨域导致的问题”，然后找后端在服务器配置里增加了跨域请求的配置，解决了。然后 A 默默把这个知识点记住了。注意！是记住了，像是背下一个数学公式一样的背下来了，或者把它当做笔记一样地记在自己某个记事本里，实体的或者电子的。\nB 同学：之前不认识这种提示，然后找到了相关人员了解到“哦，原来这是跨域导致的问题”，然后他就开始好奇了，啥是个跨域呢，他打开搜索引擎去学习跨域是什么（这也就是很多程序员自嘲自己是面向搜索引擎的程序员，其实这不是坏事，搜索引擎就是程序员的图书馆，大多技术点都能够通过搜索引擎学习到原理并消化），学习的过程中他自然而然就会再学习到什么是同源策略。\n最终他一知半解的学习了这个新的概念，虽然还是感觉迷迷糊糊的，但起码他今天学习到了新的知识点，自己的技能栈也得以进一步完善。当下一次，再下一次遇到跨域的问题时，他都会结合不同场景去加深之前对跨域的理解，最终达到对这个知识点的精通。\n久而久之，他可能做到对浏览器内部原理精通，前提是他能够坚持长期保持这样的学习方法并深耕某一技术领域。\n那我们来分析这次事例，这是一个知识点吗？是的，就是跨域，但这是像数学公式一样的东西吗？不是的。\n数学公式是什么，是公式，是能够解决计算问题的一种程式，不管是推导公式还是原始公式，都是很基础的工具，你给它输入各种各样的输入值，都会得到确定的计算结果，也就是输出值。\n这很像面向过程编程思想中的函数，还有现在前端流行的函数式编程中的纯函数，其实编程和数学一直都存在很强的关联性，甚至计算机的发明就是数学家用来处理数据运算的机器而已。\n那么回到我们这个问题当中，浏览器中的报错是一个公式吗？不是，它是一个结果，是因为你的配置不符合浏览器的同源策略限制，所以浏览器告诉你这里的访问跨域了，不让你进行访问，这是一个结果。\n至于这样的结果是唯一的吗？不是，有很多种，至于有多少种，那就要看浏览器同源策略的限制有多少种，只要你不满足其中的任何一种，你都会遭到跨域警告，而且每种违背同源的警告内容可能都会不同，当然大致都是在告诉你跨域了。\n那么这样情况下，A 如果只是记住了这个结果，有意义吗？有一点。但是对于他个人的技术成长没有帮助，因为他并没有通过这次跨域警告事件而真正认识跨域这个东西，他只是记住了这个知识点，像文科生背历史事件一样。当下一次遇到相似但不相同的情况时，他可能仍搞不定，而且还需要再记住一种新的情况。\n如此长期下去，如果有心者可能会意识到这个问题从而转变为寻找众多相似知识点之间的规律，去试着探寻问题核心。但如果没有这个心，那就是在不断地记忆新的知识点，直到背不动为止。那个时候他会觉得做技术太难了，要记的东西太多了，而且庞杂无规律，数量巨大。渐渐地，他可能会开始质疑自己是不是不适合做技术。\n这样的人的确不适合做技术，但如今互联网公司的程序员们中大量充斥着这样的人。\n那么 B 同学这样的是否适合做技术呢？是适合的。这就是当下互联网领域最受欢迎的技术人才类型，也就是具有研究型人格的人，他们往往对于每个技术点背后真正的原理感兴趣，能够不断深入到技术背后的本质，并不断完善自己的知识体系，形成一个完整的技术栈。这种研究型人格的技术人才是做技术岗位的不二首选。\n我这里说的只有 A 和 B 两个同学，但其实实际工作中会有 ABCDEFG 各种同学，这里举例的 AB 同学其实只是代表了面对问题时思路反差比较大的两类人，一类是记忆型学习人格，另一类是理解型学习人格。两者无对错之分，但有分别适合的职业和岗位之分，如果把自己的学习方式用在错误的职业位置上，会长期难以得到职业成就感。\n但我们反观研究型人格的人，他们也可能因为太过于执着于每件事情背后的本质，每件事都期望能够通过追本溯源找到确切的结果，而恰恰并不适合做管理岗位。因为管理是要和人打交道的，人和技术不一样，技术是死的，冰冷的，而人是活的，温度各异的。人有情绪，而且变幻莫测。技术的发展走向起码是有规律可循的，而人没有。\n人类作为在地球上进化千年的有机体，并且在征服了各大生物种群之后成为世界主宰者，可以说进化的十分复杂。\n那么管理字面上说是管理，其实更多的是和人的交流，对于不同的人采用不同的交流一方式，没有固定的方法，也没有可以用于计算的公式。这一点不管从可变性上还是复杂度上都极大地超越了技术。\n所以说适合的人做适合的事才是最高效正确的，乐于洽谈的人可能就是很难静下心来研究每件事物背后的本质。但他恰恰能够通过言语交谈办成事，而且能够通过合适的方式劝服他人去做某件事情，比如召集一帮技术很厉害的人去研发一款软件，并且使他们充满激情地做这件事情并乐此不疲。\n而适合做技术的人呢，可能就是很难去通过言语去取悦他人，而是更加乐意和冷冰冰的机器去交谈。因为他们的确善于操纵机器，对于机器里的每一个二进制的变动都心中有数。这样的人就适合做技术，但也不是绝对的。有些人也能够通过技术老本行先在科技界建立一定的威望，然后再利用这个光环转去创立公司，转型成为管理者，但是这样的人少之又少，仅有的那些成功转型者名字，大家也都知道了。\n那么我们每个人适合做什么事呢，需要花时间去和自己对话，认真思考自己的定位，先找到自己某个阶段适合做什么工作，再去落实执行，或许会事倍功半。但凡事没有绝对，也永远都有人唱反调，有人就是不管三七二十一先做了再说。但读过历史的人都知道，事前做计划的确会降低失败的概率。\n最后，推荐一本最近在读的书《人类简史》\n杂谈结束，后会有期\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-10-17-technical-people/","summary":"\u003cp\u003e突然有感而发想到这样一个话题——什么样的人适合做技术\u003c/p\u003e","title":"什么样的人适合做技术"},{"content":"关于阮一峰《ECMAScript6 入门》一书的观感，就把此文当做本人对于《ECMAScript6 入门》的书评吧\n原书链接\n暮色 首先，抛开技术不谈（这可能有点过分，一本技术书籍的书评竟然和技术没多大关系，但是秉承“一千个读者有一千个哈姆雷特”的原则，建议各位亲自去拜读此书，找寻自己的收获），当然此评也不是广告，因为阮一峰根本不认识我，我只是在学习 ES6 过程中了解到此书。再说一下为什么此文不谈技术，而更多地谈的是我看此书的感受，因为就我长期对对于阮一峰的了解和关注，他本身也认为技术只是他生活的一部分，而不是全部，令他更开心的可能是他关于人生的感想整理成书——《未来世界的幸存者》并出版。的确，我的人生规划也不会把技术看做多么重要的东西，它只是我当下阶段职业所需的技能，我会更多地从技术中抽取不同厉害的人或深刻或缜密的思维背后的哲学，用以加深我对这个世界的认知和理解。\n新月 阮一峰本身不是搞计算机的，他写的书却成为技术圈的参考教科书，至少在 ES6 这一个知识点上，被大家广为流传借鉴，可见学问存在“大同”效应，即大道至简。如果你是一个对于知识追求理解原理和本质的人，那么在学习了一部分知识后，自然而然会对其他未学的东西有着开导的作用。比如举个不一定恰当的例子，所谓举一反三是什么呢，在前端界我们都知道有三大主流框架 React、Vue、Angular，那放给初学者可能就觉得要学的东西太多了，竟然要掌握三种框架，去不同公司，做不同项目可能都要用不同的技术框架，简直像个学不完的无底洞。但如果是有一定经验的人会怎么看呢——举一反三，三大框架本师出同门，都是用基础语言 Javascript 经过不同的包装形式封装而成，所以高级开发经常会告诉初级工程师要打牢基础，因为基础好了，无论出现什么样的新技术都万变不离其宗，这样的学习方法就是举一反三。吃透理解一个框架，对比地再去学习另外两个，就会发现有很多相似的地方和思想，假如学习一门新技能需要花费 10 天的话，这样学起来也就不是 10x3=30 天了，而可能是 10+9+8=27 天，甚至是 10+7+3=20 天或者更少。因为伴随着你前面的积淀，再去学习新的东西，如果能利用上之前所学到的思想，大多情况下可能不会再用同样多的时间，而是越来越快，至少相近的知识是这样的。\n月食 那么回归 ECMAScript 6 入门这本书为什么能够一直被奉为学习 ES6 入门的首推宝书呢，可能读过此书的人才能感受到。首先该书从 2014 年 4 月 20 号发生第一次 github 上的提交，在开源大家庭的共同维护下已经走过了五个年头。那为什么它会成为一本开源的书呢，作者自己当然有自己的想法，但我们也可以看到，其实阮一峰自己也经常提及自己不是计算机科班出身的事实，但这也不影响他能够写出帮助其他计算机专业的人学习的教材，也不妨碍他和技术圈的人合作产出，所以通过开源的方式，可以云集世界各地的高手一同校验、纠错，历史提交记录中不乏一些很有价值的帮助，比如“fix: IIFE 不一定是匿名”、“修改示例代码使其更精确”。另外我们可以从很多细节中感受出他对于这本书的认真态度和投入，比如最后一章所列举的参考链接，就如同专业论文的参考文献，既做到了对于参考内容的版权尊重，也帮助读者对于某些知识点的追本溯源提供了便捷的帮助。同时，这也给人一种学无止境的感觉，当你花一段时间拜读完此书时，认为自己已经做到了“ES6 入门”，然而看到最后一章附注的参考链接，才发现你刚刚打开知识海洋的大门，你会发现自己学到的只是冰山一角，因为毕竟你读完这本书可能只要花费不到一个月的时间，而作者写成这本书却要花费五年的心血，甚至更多。所以说——学无止境，任何时候你感觉自己已经会了，或者对于某个领域或某个知识点完全理解了，都是在阻碍你后面更大的进步。\n破晓 再说一个令人咂舌的细节点，就我写下此评的这一天（2019 年 05 月 21 日 17:27:02）打开该书的 github 地址，发现issues和pull requests栏目的待审阅数双双为零，乍一看还以为是此书封版了，已经完善归档，不再需要更新，或是作者设置为禁止其他人继续提交改动了，但好像不是这样。点开近期 close 掉的 issue，发现刚发生在 3 天前，同时最近一次的 pull request 处理于 4 天前，看到这个足以令人震惊。因为逛开源圈的都知道，茫茫众多开源项目，能够做到这样及时关注用户反馈，对开源提交做出处理，达到 0 待处理 issue 和 0 待处理 pr 的开源项目实在不多，这有时也是从维护积极性维度衡量一个开源项目质量高低的核心指标，有些开源项目一开始很好，比如框架或者工具类的项目，大家会当做现成轮子去使用到生产中，但时过境迁，当项目中所使用的开源工具出现问题，由于是开源项目，所以项目作者就是项目的售后和客服，遇到问题了，如果从网上找不到太大的帮助，八成会回到 github 的项目原地址来看看 issue 或者 pr 中别人有没有睬过同样的坑，当欣喜若狂地搜索到结果后，迎面而来的可能是一盆冷水，就是这种问题的确也很多人遇到过，但作者已经很久没有再维护此项目了，issue 和 pr 中待处理的问题一堆，逐渐地人们可能会换用其他新的技术框架或方案，这样的开源项目便也就此论为昙花一现。与之不同的是，阮一峰能够持续地维护此书，的确值得钦佩。可能有人会说，这只是一本小书，文字内容为主，附以简单的代码片段说明，跟大的开源技术框架不能比，但我们这里看到的是态度，一个人对于小的事情能够报以认真严肃的态度，当面对大问题的时候大多能够从容应对，毕竟还有分治策略不是吗，大的问题大多可以拆解成多个小的问题的合集，继而分而治之。就好比一个人从刚入职场做着简单的岗位起，如果因为觉得基础岗位所做的事情简单无趣而不能认真对待，那么怎么能够得到晋升去做更大事情的机会呢，相反能够在基础岗位做出优异成绩的人大多稳步发展，逐步上升，成为厉害的人，这才是我们应该学习的态度。千里之行始于足下、高楼万丈平地起，这样的道理我们从小学时期就受过教育，只是很多人在成长的过程中都丢掉了。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-05-21-ecmascript6-reading-review/","summary":"\u003cp\u003e关于阮一峰《ECMAScript6 入门》一书的观感，就把此文当做本人对于《ECMAScript6 入门》的书评吧\u003c/p\u003e","title":"《ECMAScript6入门》读后感"},{"content":"关于一次使用 git 子模块功能备份 hexo 主题文件的记录\n背景 整个事情源于某天心血来潮又写了篇博客，当准备使用 hexo 发表时，突然想到一个问题之前虽然做到对于博客项目的git备份了，但是最近新换的主题配置修改也备份了吗？，有点像强迫症出门后思考房门有没有锁好的感觉。\n背景是这样的：最初我刚接触 hexo 的时候，觉得发现了宝贝，它是个不错的静态博客生成器，风格偏极客风。虽说是博客工具，但要拿给不会技术的人可能用起来还比较蹩脚，因为其虽然声称使用简便，只需要快速地搭建环境，敲敲命令，就可以在网页上展现出漂亮的个人博客网站来。\n但其搭建环境基于 Node.js，命令又依赖于 git，还得把本地的博客源文件编译成浏览器可解读的静态文件发布到远程 git 仓库，还得使用支持 pages 服务的 git 仓库，比如 github 的 github pages 或 coding pages。\n所以我当初刚接触的时候，对其原理也是一知半解，仅停留在”会用“程度，但随着时间的推移，免不了发生一些其他变动。比如换电脑，这时候我就发现，如果没有对本地博客项目进行版本库的管理和备份，那么只要硬盘上的博客项目文件夹出现丢失或者换电脑，就麻烦了。\n当然，换电脑还算好，只要用优盘把旧电脑里的文件夹拷贝过去，在新电脑搭建相同的环境，就能恢复使用了，但这方法不够优雅，不够 geek。于是就在网上查 hexo 博客备份的方法，最后结合查到的方式和自己的推敲尝试，记录了一篇我是如何备份博客的\n回顾 但今天再看，当时只解决了博客“根项目”的保存，最近换了新的主题，主题的配置文件改了一大通，当然就是根据自己进行的个性化修改。突然想到，主题项目是博客项目 themes 文件夹的一个子项目，是进到 themes 目录，通过git clone下载到本地的另一个 git 项目。\n问题来了，git 项目中嵌套 git 项目，事情看上去不那么简单。好在之前就了解过子项目git submodule的概念，知道这是那块的东西，但当时刚接触子项目的时候觉得有点复杂，就没再理会，现在发现逃不过了，这是最好也是最恰当的解决方案，所以再次开始了搜查。\n先是根据猜想结合自己使用 git 的经验进行尝试\n思路 首先，理了一下思路，新下载的hexo-theme-matery项目是不应该直接划为子模块的。因为它的远程关联是 github 中原作者的项目，我对其的修改不可能直接提交到人家那里，也提交不上去，所以我首先应该有一份自己的关于hexo-theme-matery项目的拷贝。\n无论是本地 git 还是远程仓库，都是自己的，所以先进入到themes/hexo-theme-matery目录，把 git 初始化删掉（后来想到这里其实不用直接把 git 初始化删掉，只要把远程仓库关联改成我自己的就可以了，因为在本地 git 的提交都是我自己的，只要同步到自己的远程仓库就可以了）\n删除 git 初始化（使一个项目脱离 git 的管理）\nrm -rf ./.git 然后再重新初始化themes/hexo-theme-matery目录成为一个 git 项目，并关联我远程建的空项目\n由于远端建的是空项目，所以可以毫无冲突的直接 push 并建立默认分支设置（加参数 -u）\ncd hexo-theme-matery git init . git add . git commit -m \u0026#39;initial matery theme as a divided git project\u0026#39; git remote add origin git@git.coding.net:daemonG/my-hexo-theme-matery.git git push -u origin master 接下来要建立子项目关联了，参考了网上的一篇文章在 hexo 中使用 git submodules 管理主题\n照猫画虎地进行了如下的操作\n按照我对网上文章的理解，以为是通过如下命令，把某个文件夹变成一个项目并命名子项目为 theme-matery\ncd hexo-theme-matery git add submodule . theme-matery 但发现提示错误，发现是命令的参数顺序错了，于是改正为\ngit submodule add . theme-matery 还不对，提示子模块必须是一个绝对路径的目录，修改为\ngit submodule add ./ theme-matery 可以了，但发现好像不对，子模块添加成功的提示告诉我，我敲的这个命令是在当前目录添加了一个 theme-matery 目录，内容是当前目录的所有，这并不是我想要的，于是准备删掉这次操作的产物\ngit submodule remove theme-matery 提示并没有 remove 这个命令，并提示了我有哪些关于子模块的命令可用，于是\ngit submodule deinit 提示需要对全部文件进行子模块撤销\ngit submodule deinit --all 提示新建立的子模块已经有了 git 修改记录，如果此时要撤销子模块，需要进行强制撤销操作\ngit submodule deinit --all -f 这样发现，新建的theme-matery文件夹消失了，但还残留一个.gitmodules文件，这是 git 子模块的描述文件，既然刚才是一次失败的尝试，这个也删掉\nrm -rf .gitmodules 终于恢复如初了，再来，继续尝试其他方法。既然刚才的确生成了子模块描述文件和对应的子项目，那么方向不错，只是生成的位置和预期不符，于是我退到项目根路径重新操作\ncd .. cd .. git submodule add themes/hexo-theme-matery/ theme-matery 同样提示了刚才犯的一个错误，指定的子模块要以绝对路径给出\ngit submodule add ./themes/hexo-theme-matery/ theme-matery 这回的确在项目根路径生成子模块了，但也不对，原来命令中的最后一个参数是最终生成的子模块文件夹名称，而不是对于子模块定义的别名，我理解错了，所以还得删掉重来\ngit rm theme-matery git rm theme-matery -f git rm .gitmodules 这我就迷茫了，到底应该怎么添加子模块呢，再看网上查的文章，里面举的例子是把一个远程 git 项目下载到根项目中并作为子模块，前提是我原来只有一个 git 根项目，然后再添加一个远程 git 项目到本地的 git 项目的一个子文件夹作为一个子模块存在，下载+子模块初始化两步合并操作，但我的情况是，我本地已经是一个 git 根项目里套着一个别人的 git 项目了，想在本地操作，把这个子 git 项目变成根 git 项目的子模块。\nemmmmm\u0026hellip;\n解决 灵光一闪，有了办法\n反正刚才已经把本地的主题项目同步到远端新建的空项目了，所以也就是我修改过配置文件的主题项目已经在远端有了备份，所以我可以把本地的删掉，然后按照参考文章里的做法，通过下载远端项目到本地并初始化为子模块的方式进行操作了\ngit submodule add git@git.coding.net:daemonG/my-hexo-theme-matery.git themes/my-hexo-theme-matery 完美，效果是我想要的\n接下来还有提交的问题，我已经预料到这个问题，虽然是子模块，但肯定也存在提交的问题，毕竟是两个独立的 git 项目，只是存在父子关联关系，应该存在单独提交父项目、单独提交子项目和同时提交父项目和子项目三种情况\n先试一下\ngit add . git commit -m \u0026#39;add theme/matery as submodule\u0026#39; 在根目录发现这样提交并不会提交子模块的修改\n难道是子模块的修改没被 git 管理到？\ngit submodule add . git add . --recursive 呃，这都是无用操作\n再试了一下参考文章里的git commit -am 'update config of submodule'，也不行\n感到无助的时候回归官方文档Git 工具 - 子模块和另一篇文章的参考Git Submodule 的使用，有一句说法醍醐灌顶\n主 git 仓库中存在.gitmodules 文件，它记录了 submodule 的基本信息。例如 remote 地址。\n同时在某处记录了主 git 仓库所用的 submodule 的 commit 号。\n主 git 仓库并不同步 submodule 中的所有代码，而是同步其 remote 地址和 commit 号，每个 clone 都是根据这两个信息自行到 remote 地址获取到该 commit 版本的内容。所以，如果你要更新 submodule 必须做上面的操作步骤。而你操作完成后，你的 git 仓库中 submodule 的 commit 号得到更新。\n所以，根项目想要把子模块的修改一并作为主项目的一部分进行提交，需要察觉到子模块中的 commit 号改变\ncd .. cd .. git add . git commit -m \u0026#39;update config of submodule\u0026#39; 这样再回到主项目，子模块的提交就一并提交到主项目的远程了，当然子项目还是“自治”的，子模块的提交还是子模块的提交，它也是一个独立的 git 项目\n总结 虽然啰嗦了这么一大篇，主要是为了再现当时的各种失败尝试，这样在日后遇到问题时能够想起当时的思路。但也免不了此时的结论就是最佳的方案，可能还有一些操作是错误的，或者存在隐患的，关于 git 子模块的使用还在进一步的实践和学习中。\n补充 刚做了这样的尝试，博客就崩了，发布上去直接白屏。经过多方排查，想到是我重新命名了主题项目的名称，而整个 hexo 的设计都是约定优于配置的，所以改动主题项目名，必定导致配置上对不上，出现报错，并且还不好定位到错误。\n还好想到了是这里的问题，所以把根项目配置文件中 theme 的配置项改为修改后的名称，博客恢复正常了。\n子模块常用命令 改动子模块 cd 子模块目录 git add . git commit -m \u0026#39;像正常修改提交git项目一样操作\u0026#39; git push cd 父模块目录 git add . git commit -m \u0026#39;提交父模块中子模块的改动\u0026#39; git push 核心步骤：进到子模块目录进行提交，再回到父模块项目再次提交\n更新子模块 方式一 在父模块目录遍历更新其下的子模块\ncd 父模块目录 git submodule foreach git pull 方式二 进入到子模块目录中正常更新\ncd 子模块 git pull 下载包含子模块的 git 项目 递归下载，同时下载父模块 git 项目并递归检查其包含的子模块 git 项目一并下载\ngit clone 项目地址 --recursive 先下载父模块项目，下载后如果父项目包含子模块则会有对应子项目名称的空目录，进入子模块目录初始化子模块\ngit clone 项目地址 cd 子模块目录 git submodule init git submodule update git submodule update用以确保子模块更新到最新和下载完整，比如使用递归下载git clone 项目地址 --recursive时下载不全的情况\n移除子模块 git 不支持直接删除子模块\ncd 子模块 git rm --cached . cd 父模块 rm -rf 子模块 rm .gitmodules hexo 优缺点 优点 高度可定制化 支持二次开发 开源，具备维护性并可参与到功能开发中 满足用户极客心理的诉求 主题拓展性强，有活跃的群体在丰富着可用的主题 缺点 不稳定，区别于知乎、简书这样的商业产品，具备专业团队保证使用的稳定性 使用基于配置，需要对配置规则较熟悉，否则会产生预料之外的错误，并且不易定位到 依赖于 git、git 远程仓库和 pages 服务，如果想通过自己的域名访问博客还依赖域名服务（以及域名租用的费用） 使用建议 对博客源项目进行 git 独立项目备份 因为使用 hexo-deployer 发布到远端 git 仓库的是对源项目进行编译后的文件，与原项目有着完全不同的目录格式，一旦源项目丢失，无法通过已经发布的远程 git 项目逆向生成\n对使用到的主题项目进行独立项目备份 因为主题项目一般都是独立的 git 项目，也会独立的更新功能，如果不能很好的将其作为子模块和博客项目关联并对其进行独立 git 项目备份的话，在换电脑或主题项目变更后，很难保留用户自己的修改\n对每一次的博客变动在本地发布测试通过后再向远端部署 因为 hexo 是基于配置约定的，所以有时用户会错误的使用一些命令或配置修改，会导致 hexo 在部署到远端的时候发生错误，而产生覆盖远端发布文件，导致博客不可访问的问题。所以对待 hexo 博客要像对待一个 web 项目一样经过本地测试，命令如下（s 为 server 的首字母标识）\nhexo s 如果默认的 4000 端口被占用，可通过添加-p参数指定其他端口\nhexo s -p 4001 经本地验证无误，符合改动预期后再发布远程\nhexo g -d 其他情况 还有可能导致博客无法正常访问的原因可能是 pages 服务配置不正确，或者域名不可用，域名过期等原因，需要查阅网上其他人的解决方案\n参考链接 使用 Git Submodule 管理子模块 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-05-21-git-submodule/","summary":"\u003cp\u003e关于一次使用 git 子模块功能备份 hexo 主题文件的记录\u003c/p\u003e","title":"Git子模块功能使用实践"},{"content":"用 Python 生成柱状图、折线图、饼状图来统计自己的手机话费\n环境 macOS PyCharm 依赖库 matplotlib numpy 中文字体 SimHei\n步骤详解 一、配置依赖包 使用 pycharm，直接依赖 matplotlib，如果当前环境变量的 pip 中不包含 matplotlib 库则会报错，根据 IDE 提示自动下载 matplotlib 库\nimport matplotlib 二、配置中文字体 下载中文字体文件 SimHei 并双击则安装到操作系统的字体库，然后输入一下代码找到 matplotlib 库的字体目录\nimport matplotlib print(matplotlib.matplotlib_fname()) 参考输出/usr/local/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc 打开 finder（访达）并按 command+shift+g 输入上面得到的路径并前往 找到 matplotlib 字体文件库，如/usr/local/lib/python3.7/site-packages/matplotlib/mpl-data/fonts/ttf 将下载的 SimHei.ttf 文件拷贝到这里 找到字体配置文件 matplotlibrc 可能在/usr/local/lib/python3.7/site-packages/matplotlib/mpl-data/目录下 修改其中的以下三项 重新加载字体配置使新增字体生效 matplotlibrc 配置\nfont.family : sans-serif font.sans-serif : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif axes.unicode_minus:False 重新加载字体配置\nfrom matplotlib.font_manager import _rebuild _rebuild() 三、准备数据源 mobile_176xxxx4617 = [6.33, 24.1, 40.7, 47.9, 31.9, 31.4, 41.7, 46.4, 38.9, 39, 48, 47.4] mobile_155xxxx9617 = [41.4, 36.5, 16.4, 16.6, 16.1, 16, 16, 31.2, 20, 16, 22.1, 16] mobile_173xxxx9636 = [9.4, 9.1, 9.7, 9.1, 9.2, 9, 9, 9.1, 39, 9, 19.22, 19] time = [\u0026#39;2018.4\u0026#39;, \u0026#39;2018.5\u0026#39;, \u0026#39;2018.6\u0026#39;, \u0026#39;2018.7\u0026#39;, \u0026#39;2018.8\u0026#39;, \u0026#39;2018.9\u0026#39;, \u0026#39;2018.10\u0026#39;, \u0026#39;2018.11\u0026#39;, \u0026#39;2018.12\u0026#39;, \u0026#39;2019.1\u0026#39;, \u0026#39;2019.2\u0026#39;, \u0026#39;2019.3\u0026#39;] 四、生成统计图 柱状图 module_histogram.py 折线图 module_line_graph.py 饼状图 module_pie_chart.py 五、效果预览图 柱状图\n折线图\n饼状图 项目地址\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-05-07-use-python-visualize-to-statistics/","summary":"\u003cp\u003e用 Python 生成柱状图、折线图、饼状图来统计自己的手机话费\u003c/p\u003e","title":"用Python生成柱状图、折线图、饼状图来统计自己的手机话费"},{"content":"关于 WEB 中宽高的一些整理\n屏幕宽高（screen.width \u0026amp; screen.height） 屏幕宽高的计量单位是设备像素（但 IE8 对其计量单位使用CSS像素）\n由此可见\n截图工具对于截图的计量（值和单位）基本与 screen.width \u0026amp; screen.height 一致（差 1） 截图工具是对于用户的设备屏幕上的某个区域进行选择 screen的属性更偏向于表示物理设备的属性参数 window的属性更偏向于表示 WEB 的参数 进一步观察\nscreen还有 4 个更加“实用”的属性\nscreen.availHeight 877 screen.availWidth 1440 screen.availLeft 0 screen.availTop 23 为什么说实用呢，因为这些屏幕的实际宽高并不一定在用户应用中都能被使用，比如这里可以看到screen.availTop有 23 的长度是不在可用范围呢，那这段长度是什么呢，见下图\n其实是设备（电脑）系统本身的状态栏高度，这一部分高度在浏览器未全屏显示的时候的确是不算在应用（浏览器）高度内的，同时很明显可以看到screen.availHeight + screen.availTop = 877 + 23 = 900 = screen.height，这三个属性的值形成一个完整的闭环，详细的描述了设备屏幕在不同使用场景下的参数\n窗体宽高（window.width \u0026amp; window.height） 窗体宽高的计量单位使用CSS像素（但不被 IE 支持，并且欧朋浏览器对其计量单位使用设备像素）\n以上所说的计量单位区分是因为在浏览器中访问这些对象属性的时候返回值只是一个数字，而没有单位，其在不同的环境中（浏览器类型）计算方式并不同\n以下两张图可见\nwindow.innerHeight \u0026amp; window.innerWidth 是随着浏览器视窗当前的真实展现宽高变化的\n滑动偏移量（Scrolling offset） 实验如图\n当前位置时\nwindow.pageYOffset 0 而滑动到此位置时\nwindow.pageYOffset 416 两次之前的滑动差值第二次减去第一次的 416 其实是屏幕在 Y 轴上的滚动量，并且由于这是计算视窗滑动量，所以在不同的浏览器上计算方式没有差别\n存在如下一个关系\ndocument.documentElement.clientHeight 797 window.innerHeight 797 window.outerHeight 877 screen.availHeight 877 还有一个反应 WEB 文档真实宽高的属性\ndocument.documentElement.scrollHeight 12061 参考文章\nA tale of two viewports — part one ","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-04-12-web-height/","summary":"\u003cp\u003e关于 WEB 中宽高的一些整理\u003c/p\u003e","title":"关于WEB中宽高的一些整理"},{"content":"出处：JavaScript 高级程序设计（第三版）第四章——变量、作用域和内存问题\n一句话总结 JS 的方法参数是按值传递的\n前提 ES 变量分为两种数据类型的值：基本类型和引用类型\n基本类型存储 基本类型的值在申请内存时是固定大小，所以保存在栈内存，故在复制基本类型变量时也是在栈内存中新开辟一份内存空间进行存储\n引用类型存储 而引用类型变量的值大小不固定，且可任意改动，引用类型变量的本质是指向某一块内存区域的指针变量，故引用类型变量存储在内存自由分配的堆内存中，在对引用变量作直接复制（重新赋值）时也只是将新的变量指向相同的一片内存区域（即两个指针指向同一片堆内存空间）\n引用类型探析 引用类型的值是存放在内存中的对象，但由于 JS 语言不允许直接访问内存中的位置（即不能直接操作对象的内存空间），故操作对象时实际是在操作对象的引用，而不是直接操作实际的对象本身（即引用类型的值是按引用访问的，这个引用可以理解为对象的句柄）\n特别地 很多语言对于字符串是以对象形式进行表示，故为引用类型变量，但 ES 不是\n详解 ES 中所有函数（方法）的参数都是按值传递的，即调用一个方法时，是将调用该方法时传入该方法的参数的值复制给函数内部的参数（将实参的值复制给形参）\n具体分类 JS 在访问变量时有按值和按引用两种方式，但参数只会按值传递\n向参数传递基本类型的值 被传递的值会被复制给一个局部变量（这个局部变量就是形参，在 ES 中就是 arguments 对象的一个元素）\n实例 function addTen(num) { num += 10; return num; } var count = 20; var result = addTen(count); // 看有没有影响到原变量 alert(count); alert(result); 执行结果\n20; 30; 向参数传递引用类型的值 JS 会把被传递的值的地址复制给一个局部变量，因为复制的是地址，所以在函数执行时，函数形参在函数内部改变时会影响到函数外部的该引用变量的值，因为两个地址指向同一片内存区域，但在函数执行结束，函数内部的局部变量被销毁，影响即会消失\n实例 function setName(obj) { obj.name = \u0026#34;tom\u0026#34;; } var person = new Object(); setName(person); // 当把person传递给setName时，obj和person都指向相同的内存，所以对obj所指向的内存区域修改会影响到person alert(person.name); 执行结果\ntom; 分析 因为 person 指向的对象在堆内存中只存在一个，并且是全局对象\n求证参数是按值传递而不是按引用传递 function setName(obj) { obj.name = \u0026#34;tom\u0026#34;; obj = new Object(); obj.name = \u0026#34;jerry\u0026#34;; } var person = new Object(); setName(person); // 当把person传递给setName时，obj和person都指向相同的内存，所以对obj所指向的内存区域修改会影响到person alert(person.name); 执行结果\ntom; 结论 函数内部重新生成的对象 obj，并对其新赋值 jerry 并没有改变函数外部 person 对应的属性值\n如果向引用类型参数赋值是按引用赋值，那么 person 的 name 应该变为 jerry，因为假设形参 obj 拿到的是 person 的引用，而不是 person 引用的值，那么当函数内部生成新对象，并对 obj 进行重新指向时，形参 obj 的指向改变，外部的 person 的指向也应该改变，但是结果证明 alert(person.name)显示的依旧是 tom，所以即使函数参数是引用类型，也是按值传递\n而实际上在函数内部重写 obj 时，这个变量引用的是一个局部对象变量，该局部对象会在函数执行完毕之时销毁\n原文自 个人 github 博客，欢迎 star\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2019-02-12-js-function-arguments/","summary":"\u003cp\u003e出处：JavaScript 高级程序设计（第三版）第四章——变量、作用域和内存问题\u003c/p\u003e","title":"JS的方法参数传递（按值传递）"},{"content":"关于 js 浅拷贝和深拷贝\n浅拷贝 典型案例 Object.assign() 展开赋值 Array.prototype.slice() Array.prototype.concat() 定义 浅拷贝对于 js 基本类型进行正确拷贝，对引用类型只拷贝指针，但指针指向的堆内存相同，所以对于原对象的基本类型属性进行改变不会影响到新拷贝出的对象对应的属性，但对原对象的引用类型属性改变，新拷贝的对象对应的属性也会随之变化\nObject.assign 实例 var obj = { name: \u0026#34;hello\u0026#34;, child: { name: \u0026#34;tom\u0026#34;, age: 10 } }; var copy = Object.assign({}, obj); obj; child: age: 20; name: \u0026#34;jerry\u0026#34;; name: \u0026#34;world\u0026#34;; copy; child: age: 20; name: \u0026#34;jerry\u0026#34;; name: \u0026#34;hello\u0026#34;; obj.name = \u0026#34;world\u0026#34;; obj.child.name = \u0026#34;jerry\u0026#34;; obj.child.age = 20; obj; child: age: 20; name: \u0026#34;jerry\u0026#34;; name: \u0026#34;world\u0026#34;; copy; child: age: 20; name: \u0026#34;jerry\u0026#34;; name: \u0026#34;hello\u0026#34;; rest 实例 var rest = {name: \u0026#39;iamrest\u0026#39;, child: {childname: \u0026#39;iamchild\u0026#39;, age: 30}}; undefined var restcopy = {...rest} undefined rest {name: \u0026#34;iamrest\u0026#34;, child: {…}} child: {childname: \u0026#34;iamchild\u0026#34;, age: 30} name: \u0026#34;iamrest\u0026#34; restcopy {name: \u0026#34;iamrest\u0026#34;, child: {…}} child: {childname: \u0026#34;iamchild\u0026#34;, age: 30} name: \u0026#34;iamrest\u0026#34; rest.name = \u0026#39;imnotrest\u0026#39;; rest.child.age = 40 40 rest {name: \u0026#34;imnotrest\u0026#34;, child: {…}} child: {childname: \u0026#34;iamchild\u0026#34;, age: 40} name: \u0026#34;imnotrest\u0026#34; __proto__: Object restcopy {name: \u0026#34;iamrest\u0026#34;, child: {…}} child: {childname: \u0026#34;iamchild\u0026#34;, age: 40} name: \u0026#34;iamrest\u0026#34; __proto__: Object Array.prototype.slice 实例 MDN 官方定义 slice 方法用于数组对象浅拷贝slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。，详见https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\nslice 方法用法（核心：对数组进行浅拷贝） arr.slice(); // [0, end] arr.slice(begin); // [begin, end] arr.slice(begin, end); // [begin, end) 实例 var arr = [3, 4, [5, 6]]; undefined var slice0 = arr.slice(); undefined slice0; (3) [3, 4, Array(2)] 0: 3 1: 4 2: (2) [5, 6] length: 3 __proto__: Array(0) 结论：如果不传任何参数，则对原数组进行完整浅拷贝\nvar slice1 = arr.slice(1); undefined slice1; (2) [4, Array(2)] 0: 4 1: (2) [5, 6] length: 2 __proto__: Array(0) 结论：如果传一个参数，则从数组的该索引位置（包含索引位置的元素）浅拷贝到数组最后一个元素\nvar slice2 = arr.slice(0, 2); undefined slice2 (2) [3, 4] 0: 3 1: 4 length: 2 __proto__: Array(0) 如果传两个参数，则对原数组进行从第一个参数的索引位置（包含该元素）到第二个参数位置止（不包含该元素）进行浅拷贝\n插播数组 splice 方法的使用（核心：对数组进行切片，同时增删元素，直接对原数组进行操作） array.splice(start[, deleteCount[, item1[, item2[, ...]]]])\n初看这种方法 api 抽象的表达方式可能会很晕，这里 start 表示为必填的参数，而后面的中括号内的部分表示可选参数，也就是如果在 start 后面的第二个参数会被认为是 deleteCount，后面不要看嵌套多少层，其实都是从第三个参数开始也都是可填可不填的，如果填了就依次累加，表示要新添加进数组的元素\n方法注意点 方法返回值是被删除元素所组成的数组 方法对于元素的删除和新增都基于原数组，即对数组进行直接操作（也就相当于对数组进行区别于栈结构和队列结构的顺序操作，可以像对链表操作一样一样操作数组，修改内部元素） 参数注意 start 操作起点 deleteCount 删除个数 item 新增元素 start 可以是任意整数，分正整数、负整数和 0 如果是 0，则表示从数组第一个元素开始（并且包括 start 索引所在元素） 如果是数组长度范围内的负整数，则表示从数组尾部往前数 如果是数组长度范围内的正整数，则表示从数组头部往后数 整体看来 splice 方法属于对数组的高级切片操作，可以对数组同时进行删除、新增元素操作\ndeleteCount 表示要删除的元素个数，如果为 0 或者负数时不会删除数组元素 实例 [3, 4, 7, 8].splice(\u0026#39;s\u0026#39;) (4) [3, 4, 7, 8] [3, 4, 7, 8].splice(false) (4) [3, 4, 7, 8] [3, 4, 7, 8].splice(true) (3) [4, 7, 8] [3, 4, 7, 8].splice(1000) [] [3, 4, 7, 8].splice(-1000) (4) [3, 4, 7, 8] [3, 4, 7, 8].splice(0) (4) [3, 4, 7, 8] [3, 4, 7, 8].splice(1) (3) [4, 7, 8] [3, 4, 7, 8].splice(3.1) [8] [3, 4, 7, 8].splice(3.6) [8] 以上为只传一个参数的情况，此时 deleteCount = arr.length - start\n当 start 传奇怪的参数，比如字符串，splice 会试着把字符串转换为数字，如果转换不成功即变成 NaN，那么就会当做 0 处理，会清空数组； 对于布尔类型数值同样会转换为数字，true 是 1，false 是 0； 对于浮点数，splice 会对浮点数做取整处理，即只保留整数部分； 所以当传一个大于数组长度的正整数，不会删除数组元素，当传一个绝对值大于数组长度的负整数时，deleteCount = arr.length - start 会得到一个大于数组长度的数，所以会清空数组 [3, 4, 7, 8].splice(\u0026#39;s\u0026#39;, 3) (3) [3, 4, 7] [3, 4, 7, 8].splice(false, 3) (3) [3, 4, 7] [3, 4, 7, 8].splice(true, 3) (3) [4, 7, 8] [3, 4, 7, 8].splice(-1000, 3) (3) [3, 4, 7] [3, 4, 7, 8].splice(1000, 3) [] [3, 4, 7, 8].splice(0, 3) (3) [3, 4, 7] [3, 4, 7, 8].splice(\u0026#39;1\u0026#39;, 3) (3) [4, 7, 8] Number(\u0026#39;s\u0026#39;) NaN [3, 4, 7, 8].splice(NaN, 3) (3) [3, 4, 7] [3, 4, 7, 8].splice(3.6, 3) [8] [3, 4, 7, 8].splice(3.2, 3) [8] Number(3.6) 3.6 parseInt(3.6) 3 parseInt(3.2) 3 以上为传两个参数的情况，这个时候显性地指定了要删除的元素个数，对于 start 不合理的传参情况会按照上面的处理方式，唯一特别的就是当 start 为绝对值大于数组长度的整数时，由于删除起点已超出数组范围，所以无论 deleteCount 为多少，都不会怼数组进行删除操作，而当 start 为绝对值大于数组长度的负整数时，start 会按 0 处理\n展开剖析反而会显得更复杂，上述仅为理解过程，附上官方原定义：\nstart​ 指定修改的开始位置（从 0 计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1 计数）；如果负数的绝对值大于数组的长度，则表示开始位置为第 0 位。\ndeleteCount 可选整数，表示要移除的数组元素的个数。如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。 如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 如果 deleteCount 被省略，则其相当于(arr.length - start)。\nitem1, item2, \u0026hellip; 可选 要添加进数组的元素,从 start 位置开始。如果不指定，则 splice() 将只删除数组元素。\n深拷贝 定义 深拷贝即对被拷贝对象进行绝对拷贝，拷贝前后的两个对象绝对独立，互不影响\n实现方式 var tom = {name: \u0026#39;iamtom\u0026#39;, child: {age: 20, name: \u0026#39;imtomchild\u0026#39;}}; undefined var tomcopy = JSON.parse(JSON.stringify(tom)); undefined tomcopy {name: \u0026#34;iamtom\u0026#34;, child: {…}} child: {age: 20, name: \u0026#34;imtomchild\u0026#34;} name: \u0026#34;iamtom\u0026#34; __proto__: Object tom {name: \u0026#34;iamtom\u0026#34;, child: {…}} child: {age: 20, name: \u0026#34;imtomchild\u0026#34;} name: \u0026#34;iamtom\u0026#34; __proto__: Object tom.child.age = 30; 30 tom {name: \u0026#34;iamtom\u0026#34;, child: {…}} child: {age: 30, name: \u0026#34;imtomchild\u0026#34;} name: \u0026#34;iamtom\u0026#34; __proto__: Object tomcopy {name: \u0026#34;iamtom\u0026#34;, child: {…}} child: {age: 20, name: \u0026#34;imtomchild\u0026#34;} name: \u0026#34;iamtom\u0026#34; __proto__: Object 结论：使用 JSON 对象的 stringify 方法对被拷贝对象进行字符串化，再对生成的字符串对象化，会生成一个和原对象完全相同，但内存空间不同的对象\nvar arr = [2, 3, 5, 11, 49]; undefined; var arrcopy = JSON.parse(JSON.stringify(arr)); undefined; arr(5)[(2, 3, 5, 11, 49)]; arrcopy(5)[(2, 3, 5, 11, 49)]; arr[2] = 6; 6; arr(5)[(2, 3, 6, 11, 49)]; arrcopy(5)[(2, 3, 5, 11, 49)]; 结论：数组同样适用（因为数组本质也是对象）\n存在问题 对于对象的特殊属性无法拷贝，包括：\nundefined symbol 值 函数 日期类型 正则类型 …… var special = { name: \u0026#39;normal\u0026#39;, a: undefined, b: function test() { console.log(\u0026#39;hello\u0026#39;) }, c: Symbol(\u0026#39;world\u0026#39;), } // undefined var specialcopy = JSON.parse(JSON.stringify(special)) // undefined special {name: \u0026#34;normal\u0026#34;, a: undefined, b: ƒ, c: Symbol(world)}a: undefinedb: ƒ test()c: Symbol(world)name: \u0026#34;normal\u0026#34;__proto__: Object a: undefined b: ƒ test() c: Symbol(world) name: \u0026#34;normal\u0026#34; __proto__: Object specialcopy {name: \u0026#34;normal\u0026#34;} ","permalink":"https://barnett617.github.io/wilson-blog/notes/2019-01-22-shallow-clone-and-deep-clone/","summary":"\u003cp\u003e关于 js 浅拷贝和深拷贝\u003c/p\u003e","title":"浅拷贝和深拷贝"},{"content":"关于 js 数据类型\n赋值 基本类型变量赋值 引用类型变量赋值 前言 在 es6 出现以前，js 有六大数据类型，由五大基本类型+一个引用类型所组成，五大基本类型分别为undefined、null、boolean、number、string，一大引用类型为object\n但随着 es6 的普及（从新知识变成基本知识），新添一位成员名叫 symbol，js 的数据类型格局变为六大基本类型+一大引用类型，symbol 的出现被列入基本类型队列，而引用类型并无变化\n基本类型变量（primitive value） undefined null boolean number string symbol object 另附以上六种基本类型在chrome71控制台中实际输出\nundefined typeof undefined; (\u0026#34;undefined\u0026#34;); undefined首字母不大写\nnull typeof null; (\u0026#34;object\u0026#34;); 空对象的类型当然是对象\nboolean typeof Boolean(true); (\u0026#34;boolean\u0026#34;); boolean首字母不大写\nBoolean是window对象提供的 js 全局方法，用于将一个值转换为布尔类型，以下是我能想到比较有代表的转换 case:\nBoolean(); false; Boolean(false); false; Boolean(0); false; Boolean(111); true; Boolean(\u0026#34;\u0026#34;); false; Boolean(undefined); false; Boolean(null); false; Boolean(\u0026#34;false\u0026#34;); true; number typeof Number(); (\u0026#34;number\u0026#34;); 同Boolean()，Number()是将变量转换为 number 类型的内置方法，以下为示例:\nNumber(); 0; Number(1); 1; Number(false); 0; Number(true); 1; Number(\u0026#34;\u0026#34;); 0; Number(\u0026#34;false\u0026#34;); NaN; Number(\u0026#34;true\u0026#34;); NaN; Number(\u0026#34;1\u0026#34;); 1; Number(undefined); NaN; Number(null); 0; Number(\u0026#34;1str\u0026#34;); NaN; Number(\u0026#34;str1\u0026#34;); NaN; 以上看出，Number()方法在转换字符串时，会尽量把数字字符串顺利转换为 number 类型，但包含字符串或干脆就是是纯字符串的字符串类型变量显得无能为力，经过 Number()方法处理的返回值是得到一个特殊的变量NaN，它是 js 内置的一个用以表示非数字的 number 类型常量，为什么说它是变量，而不是类型呢，因为：\ntypeof NaN; (\u0026#34;number\u0026#34;); string typeof String(); (\u0026#34;string\u0026#34;); 同样，string类型首字母不大写，首字母大写的是 js 内置的用以将某个值转换为该类型的方法，同Boolean()、Number()，也有String()，case 如下:\nString(); (\u0026#34;\u0026#34;); String(\u0026#34;boolean\u0026#34;); (\u0026#34;boolean\u0026#34;); String(\u0026#34;number\u0026#34;); (\u0026#34;number\u0026#34;); String(Number(\u0026#34;false\u0026#34;)); (\u0026#34;NaN\u0026#34;); String(1); (\u0026#34;1\u0026#34;); String(undefined); (\u0026#34;undefined\u0026#34;); String(null); (\u0026#34;null\u0026#34;); typeof String(undefined); (\u0026#34;string\u0026#34;); typeof String(null); (\u0026#34;string\u0026#34;); 以上看出，“万物皆可字符串化”，NaN、undefined、null也难逃于此，它们被 String()大法转变后，都乖乖套上了双引号，用typeof一照都是字符串类型\nsymbol typeof Symbol(1); (\u0026#34;symbol\u0026#34;); typeof Symbol(); (\u0026#34;symbol\u0026#34;); 以上就是传统主流 js(es5 标准实现下的 js)的六大基本类型\n引用类型变量（reference value） 首先所有的引用类型都隶属于 object 类型，细分有array、function、object、date、regexp等\n注意：引用类型无法再通过 typeof 进行判断，因为引用类型都衍生与 object，typeof 引用于判断基本类型的区分\ntypeof Array(); (\u0026#34;object\u0026#34;); typeof new Date(); (\u0026#34;object\u0026#34;); typeof function a() {}; (\u0026#34;function\u0026#34;); typeof []; (\u0026#34;object\u0026#34;); object typeof Object(); (\u0026#34;object\u0026#34;); 同样object首字母也不大写，同样 js 内置了Object()方法将一切转换为 js 对象，但这和String()、Boolean()、Number()不可同日而语，因为Object可以说是 js 的根、源头，一切生自Object，没有它就没有 js 的其他一切\ntypeof Object() \u0026#34;object\u0026#34; Object() {} typeof new Date() \u0026#34;object\u0026#34; typeof Object() \u0026#34;object\u0026#34; Object(1) Number {1} typeof Number(1) \u0026#34;number\u0026#34; Object(null) {} typeof Object(null) \u0026#34;object\u0026#34; typeof Object(false) \u0026#34;object\u0026#34; Object(false) Boolean {false} 特性 引用类型的值是可变的，区分于基本类型不可变，所以对于基本类型的数据进行拷贝，就真的是拷贝出了一份类型相同的一个新值。但引用类型的变量只是指向一片内存空间的指针，所以对引用类型的直接拷贝得到的只是一个指向同一片内存空间的另一个指针而已，但拷贝前后所表示的值是相同的，所以此时如果改变原引用变量的值，会同时改变拷贝出的变量的值，举个例子:\nvar x = { name: \u0026#34;hello\u0026#34; }; undefined; var y = x; undefined; x; { name: \u0026#34;hello\u0026#34;; } y; { name: \u0026#34;hello\u0026#34;; } x.name = \u0026#34;world\u0026#34;; (\u0026#34;world\u0026#34;); x; { name: \u0026#34;world\u0026#34;; } y; { name: \u0026#34;world\u0026#34;; } 补充 instanceof见名知意，判断某个对象实例是否是某种对象的实例，（晦涩版：用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上，这里牵扯到构造函数、ptototype属性、原型链重要概念，需要后面一一详解）\n({}) instanceof Object; true([]) instanceof Array; true(/a/) instanceof RegExp; true(function () {}) instanceof Function; true; 本篇系整合各篇优质内容并加以个人理解整理而成，参考文章如下：\nJavaScript 深入了解基本类型和引用类型的值 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2019-01-21-js-copy/","summary":"\u003cp\u003e关于 js 数据类型\u003c/p\u003e","title":"js中的“拷贝”（第一篇）——js数据类型"},{"content":"对于 An Introduction to JavaScript 的个人翻译及一些“添油加醋”\n什么是 javascript js 最初被创造来使 web 动起来，即画龙点睛的点睛之笔，在没有点睛之前的 web 即是 html+css 的静态页面（当然 css 也可以让 html 动起来），但 js 可以让 web 充满更多可能，比如看现在的前端工程就可以得知，从前后端分离后单独的前端项目工程可能就是一个或几个压缩后的 js 文件外加几个静态配置文件，到前端项目打包工具是用 js 编写，再到 js 能够动态改变 DOM 结构以完成页面在浏览器渲染时的千变万化，js 的威力可见一斑。\n究其本质，js 只是一种脚本语言，可以写在 html 内容，并可以在页面被加载时自动执行，但是 js 不需要被机器编译，因为它运行在浏览器环境或其他 js 引擎之上，这是它和 java 最大的区别。\n而我们有时候听到的 js 编译过程实际上指的是对 js 进行打包压缩，在符合 js 解析规则的前提下最大化减少 js 代码之间的空隙，以使得它在能够实现预期功能的前提下变得尽可能的小，因为它是要在用户访问 html 时下载到用户电脑本地的文件，不同于服务端代码是运行在远离用户电脑的服务器上。\n为什么叫 javascript 在其创立之初，其实它叫 livescript，名字也很直观，“动态的脚本”，但时值当时 java 火极一时，想要搭载快车，通过“蹭热度”一并火起来的 js 便改名为 javascript。\n但随着其不断地迭代演进，js 逐渐脱离 java 的热度，成为一门独立的语言，基于其自己的规范——ECMAScript（European Computer Manufacturers Association，欧洲计算机制造商组织制定的脚本规范），此规范几乎每年都会有更新和不断完善，js 是其规范的一种实现，所以随着 es 的更新迭代，js 的特性也在不断地扩充。\n现在 js 不仅能在浏览器中运行，还能在服务端环境运行，甚至任何设备上，这得益于 js 的运行环境——js 引擎\n引擎如何工作 引擎很复杂，但其一些最根本的概念也很好理解\n引擎读取（解析）脚本 然后把脚本转化（“编译”）成机器语言 随后机器代码运行起来，非常之快 引擎会在每一个环节执行优化，甚至当脚本运行时侦查并分析运转在脚本内的数据并基于它的能力去对机器代码执行优化，当完成后脚本会运行的非常快。\n浏览器内的 js 可以做什么 现在 js 是一种“安全”的语言，它不提供底层对于内存或 CPU 的访问，因为它创建之初被用在不需要它们的浏览器内部\njs 的能力强依赖于它所运行的环境，比如 nodejs 支持允许 js 读写任意文件或是处理网络请求等等。\n浏览器内的 js 可以做任何和网页计算、人机交互、网页服务等相关的事情\n例如它可以：\n添加新的 html 到已有的页面上，改变已存在的内容，修改页面样式 响应用户的动作，比如鼠标点击、鼠标移动、键盘按键 将请求通过网络发送给服务器，下载上传文件（所谓的 AJAX 和 COMET 技术） 读取写入 cookie，询问访问者问题，展示消息 记住客户端数据（本地数据，local storage） 浏览器内的 js 不能做什么 网页上的 js 不能任意读写、拷贝硬盘上的文件或执行上面的程序，它不具备直接访问操作系统的方法 现代浏览器允许对文件的操作，但被限于仅仅提供用户做特定的动作，比如拖动文件到浏览器窗口或是通过一个 input 标签选择文件\n同时也可以合摄像头、麦克风或其他设备交互，但需要用户明确的授权，所以一个能够运行 js 的网页不会偷偷启动一个网页摄像头去观察着周围的一切并把数据发送给 NSA（美国安全局）\n不同的页签或窗口彼此之间不互知，有时候它们可能知道，比如用户通过一个窗体使用 js 打开另一个窗体。但即使这种情况，一个页面上的 js 也无法访问另一个页面如果它们来自不同的网站（同一个域名、同一种协议、同一个端口） 这就是同源策略，想要绕开它，两个网站都需要包含一段特殊的 js 代码来处理数据交换\n这个限制同样是为了保证用户的安全，一个用户通过http://anysite.com打开的页面必须不能够访问另一个通过http://gmail.com上打开的网页并从那里窃取信息\njs 可以很轻易地通过网络和当前页面从那来的那台服务进行通信，但其从其他网站或其他域下获得数据的能力是受阻的，虽然也可能，但其需要来自远端明确的允许（包含在 HTTP 头内），同样这也是一个安全限制 这些限制如果 js 不是在浏览器内使用是不存在的，比如在服务器端。现代浏览器也允许通过询问拓展许可的插件或拓展\n什么使得 js 独一无二 和 HTML、CSS 的完全集成 简单的事情被简单地处理 被所有的主流浏览器支持并默认打开 js 是唯一集合了这三件事的浏览器技术\n这铸就了 js 的独一无二，这也是为什么它成为传播最广的创建浏览器接口的工具\n“超越”javascript 的语言 js 的语法并不适合每个人的需求，不同的人需要不同的特征\ncoffeescript 是 js 一个“语法糖”，它介绍了更简短的语法，允许我们写更加清晰准确的代码，通常 Ruby 开发起来和它很像 typescript 是一个集中于添加“严格的数据类型检查”以简化开发过程并支持复杂的系统，它由微软开发 dart 是一种单独的语言并拥有其自己的引擎运行在非浏览器环境（比如移动应用），它最初被谷歌提供用于作为 js 的替代品，但现在浏览器要求其被转化成 js，就像如上的其他语言 还有更多，当然尽管我们使用这其中的一种语言，我们也需要了解 js 以真正地理解我们在做什么\n总结 js 最初被创建用来作为一种仅在浏览器端的语言，但它现在也被用于其他许多环境中 今天，js 拥有着独一无二的定位，作为最广泛适配浏览器的语言拥有着对 HTML、CSS 的完全集成 还有众多语言可以被转译成 js，并提供着特定的特征。了解一下它们是被推荐的，至少简短地了解下，在征服 js 之后 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2019-01-17-reread-js/","summary":"\u003cp\u003e对于 \u003ca href=\"https://javascript.info/intro\"\u003eAn Introduction to JavaScript\u003c/a\u003e 的个人翻译及一些“添油加醋”\u003c/p\u003e","title":"重读javascript第一篇"},{"content":"每当思绪万千，就想化作文字来记录片刻的美好。每当提笔却又不知从何写起，索性只能洋洋洒洒。\n2023-06-17 16:46:02 更新：本来是以前用七牛云当图床的，如今没有备案域名，连原本上传的图片都看不了了\u0026hellip;\n只好又整理了一遍照片放到自己的博客仓库\n17 到 18 这一年，是丰满的一年\n2017 年 3 月 杭州三月的油菜花，生机勃勃 上班必经的柳荫路，每经于此，都心旷神怡 上班工具 开始一天的工作 下班后自己做饭的尝试 后来才知道小时候吃的加黄瓜的宫保鸡丁原来是天津的做法\n住所 那时标准的体重 3 月份的游玩 去“莲都”之称的丽水跑马拉松 \u0026#x1f3c3; 第一次感受到江南小城的惬意和舒适\n跑步记录 4 月份 烟花三月下扬州（三月指农历的三月） 其实是去跑扬州国际半马，顺便游玩 \u0026#x1f606;\n千里跃进大别山（参加“将军县”六安金寨的百里毅行） 5 月份 返校准备答辩，整理了一下过去一年的跑步记录 \u0026#x1f3c3; 奶奶生病，回家看望奶奶 家乡的蓝天依旧 又跑去黄山歙县跑第一个全马 图片待补充：黄山\n整个县城的人大多都以枇杷的种植、加工、售卖为主要生活和工作，整个村子漫山遍野随处可见枇杷成群\n2017 年 10 月 从新闻上得知十月一号当天进入杭州的游客有一千万之多，抱着看热闹的心态，晚上一个人独自跑到西湖去看人山人海，其实西湖早在 2016 年刚到杭州的淡季逛过了，那天只是想看看千万游客是啥样 \u0026#x1f602;\n11 月，陪伴着公司度过了通宵三天，充实的双十一。地处杭州，那是一家主营电商业务的公司，同时也是毕业后加入的第一家互联网公司。\n11 月，跑了临近杭州的浙江舟山群岛国际马拉松，结识了一个同在异乡的河北老乡，并且现在还在联系。\n2018 年 5 月 5 月初的西北旺，北京互联网的聚集地 第一次来天安门 2018 年 7 月 7 月的后海 7 月的十渡 还有 7 月的天津 2018 年 8 月 圆明园 曾经只从课本上才能看到图片，身临其境感受不一样的历史厚重感 2018 年 9 月 中秋节回家（家乡的天，依旧的蓝） 与家人匆忙相聚后的离乡返京的站台 也许是漂泊在外已经习惯，恋乡情愫已淡，也许是还没到怀念家乡的年龄\n人真的是越长大越容易感动\n还记得在杭州的时候，想组一台自己的台式机，却一直经费紧张，只买了一个主机电源就没再继续。\n如今也有了自己的台式机，可以在住的地方作为固定的工作站\n想知道自己现在还跑的动半马\n从六千块的笔记本到公司配的二手 Mac Pro，再到自己一万六买的 Mac Pro\n从杭州到北京，经过一年多的厚积薄发，工资翻倍，房租翻倍\n看着自己身边的装备一件一件通过自己的努力和进步挣得，满是欣喜满足\n有些喜悦，无法分享，因为别人没有过同样的经历，可能永远无法感受到你的那一份感受\n回望过去，是为了夯实脚下的步伐，更好的向前方前进\n乔布斯说要 Stay hungry Stay foolish\n张一鸣说要 Stay hungry Stay young\n嗯，流水账结束，继续加油 \u0026#x1f4aa;\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-10-02-review-of-2017-to-2018/","summary":"\u003cp\u003e每当思绪万千，就想化作文字来记录片刻的美好。每当提笔却又不知从何写起，索性只能洋洋洒洒。\u003c/p\u003e","title":"2017-2018年个人盘点(多图)"},{"content":"心血来潮，想做一个苹果发布会的倒计时\n访问地址 https://barnett617.github.io/clock/\n过程 步骤如下：\n首先，网页标题来个标志性的苹果图标 一个好的图标网站\nsvg 转换 ico 在线工具\n如何为网站添加图标：\n在\u0026lt;head\u0026gt;标签中添加\u0026lt;link rel=\u0026quot;shortcut icon\u0026quot; href=\u0026quot;favicon.ico\u0026quot;\u0026gt;，其会从项目根目录找 favicon.ico 文件\nrel表示将要引用的资源类型，href表示指向资源的 URL， \u0026lt;link rel=\u0026ldquo;shortcut icon\u0026rdquo; href=\u0026ldquo;favicon.ico\u0026rdquo;\u0026gt;中 rel=\u0026quot;shortcut icon\u0026quot;是一种固定写法，不写或错写会导致图标无法正常显示。\n主体布局 背景 如果要背景铺满屏幕，来一个渐变色要怎么做呢\n首先，为什么要用渐变，因为好看啊\n其次，为什么渐变不用 PS 做的图片，因为 CSS3 提供了 gradients 属性，通过 CSS 实现其实渐变是由浏览器生成的，可以减少下载的事件和宽带的使用\n既然渐变是浏览器生成的，就会涉及到不同浏览器的支持问题（Safari、Opera、Firefox 等）\n另外，渐变的方式分为两种：线性渐变（Linear Gradients）和径向渐变（Radial Gradients），顾名思义，线性渐变是从一个起点沿着一个方向从一种颜色渐变成另一种颜色，而径向渐变是从一个起点沿着一个角度渐变\n线性：linear-gradient\n径向：radial-gradient\n其参数对于不同的浏览器有着不同的写法，但基本都是在配置渐变方向和渐变首末的颜色\n从上到下（默认）\nbackground: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */ 从左到右\nbackground: -webkit-linear-gradient(left, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red, blue); /* 标准的语法 */ 左上角到右下角\nbackground: -webkit-linear-gradient(left top, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient( bottom right, red, blue ); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red, blue); /* 标准的语法 */ 注意：Internet Explorer 9 及之前的版本不支持渐变\n上面的是指定方向，也可以指定角度，如下：\nbackground-image: linear-gradient(to top, #7a88ff, #7affaf); /* 等价 */ background-image: linear-gradient(0deg, #7a88ff, #7affaf); 角度指的是过渡在哪个方向截止，浏览器会绘制一条经过元素中心点的假想线。指定的角度就是这条线的角度，同时还指明过度在哪里结束\n度数 解释 描述 0deg 表示元素的顶边 to top 90deg 表示元素的右边 to right 180deg 表示元素的底边 to bottom 270deg 表示元素的左边 to left 如果仍然无法理解角度如何用，这里有一个在线演示\n除此，透明度（transparent）使用\nCSS3 渐变也支持透明度（transparent），可用于创建减弱变淡的效果。\n可使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。\n如下为从左侧完全透明的红色到右侧完全不透明的红色\nbackground: -webkit-linear-gradient( left, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1) ); /* Safari 5.1 - 6 */ background: -o-linear-gradient( right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1) ); /* Opera 11.1 - 12*/ background: -moz-linear-gradient( right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1) ); /* Firefox 3.6 - 15*/ background: linear-gradient( to right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1) ); /* 标准的语法 */ 以上都是线性渐变\n接下来是径向渐变\nradial-gradient(center, shape size, start-color, ..., last-color); 若不指定前面的参数，只指明颜色，则按照默认情况对颜色进行均匀分布\n可以根据需求添加任意多个颜色。额外添加的颜色叫色标（color stop）\n添加色标后，背景会从第一个颜色过渡到第二个颜色，再从第二个颜色过渡到第三个颜色，直到渐变的最后一个颜色为止。浏览器会平均分布各个颜色\nbackground: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法 */ 如下为背景色从左到右开始渐变，最左边是玫红，在元素宽度 20%的位置变成青色，80%的位置变成黄色，最后是蓝色。\nlinear-gradient(to right, #E94E65, #15A892 20%, #A89215 80%, #1574A8); 使用多色渐变时，第一个颜色和最后一个颜色无需指定位置，因为浏览器会嘉定第一个颜色从 0%的位置开始，最后一个颜色在 100%的位置结束。除非想把第一个颜色或最后一个颜色的位置放在指定的位置开始，才需要专门定位。\n若想颜色不均匀分布，可手动对颜色增加权重\nbackground: -webkit-radial-gradient( red 5%, green 15%, blue 60% ); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient( red 5%, green 15%, blue 60% ); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient( red 5%, green 15%, blue 60% ); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */ shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。\nbackground: -webkit-radial-gradient( circle, red, yellow, green ); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient( circle, red, yellow, green ); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient( circle, red, yellow, green ); /* Firefox 3.6 - 15 */ background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */ repeating-radial-gradient() 函数用于重复径向渐变\n/* Safari 5.1 - 6.0 */ background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%); /* Opera 11.6 - 12.0 */ background: -o-repeating-radial-gradient(red, yellow 10%, green 15%); /* Firefox 3.6 - 15 */ background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%); /* 标准的语法 */ background: repeating-radial-gradient(red, yellow 10%, green 15%); 布局 需要文字内容水平垂直居中，这就涉及到一个老生常谈的问题\n一开始随手一加，使用 flex 布局\n\u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span\u0026gt;倒计时\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; .container { display: flex; justify-content: center; align-items: center; } 发现效果并不理想，只水平居中了，垂直方向并没有居中\n这里犯了一个 flex 布局的理解错误，对某个元素进行 flex 的设置，将影响其子元素，而不是其本身的布局，所以这里其实想 container 这一级水平垂直居中，那么display: flex;应该加在它的父级，即 body 的属性上\n而在 body 上加过多的样式不是理想的做法，我们是想以 container 为页面根级，所以在其上加 flex 布局，然后将其子元素达到居中的效果，那么要让 container 作为页面根级，则需要其铺满屏幕，这里需要做一些样式设计。\n首先，发现 container 并未铺满屏幕，即元素没有贴边浏览器，这是因为 body 有一个默认外边距，会随着不同的浏览器有着不同的行为，所以即使 container 高度和宽度 100%贴着 body，也无法占满屏幕，这就是为什么要对 css 作全局初始样式，重置其默认样式\nbody { display: block; margin: 8px; } 需要在 body 上进行重置\nbutton, p, pre { margin: 0; } 另外，要让渐变色的背景铺满屏幕，这里采用了对 html 和 body 元素设置高度 100%，从而达到自适应，背景总占满屏幕的效果\nhtml, body { width: 100%; height: 100%; } body { background-image: linear-gradient(45deg, #7a88ff, #7affaf); } 倒计时 接下来，需要一个定时器来展示倒计时\n这里结束时间从简处理，即使用(后续可优化为目标时间从目标网站中获取)\n思路 倒计时即是要计算剩余时间，即目标时间的时间戳减去当下时间的时间戳来做一个格式化显示，因为当下时间是实时变化的，所以并不需要做特殊处理，只要用目标时间戳(常量) - 当前时间(变量)便可得到倒计时应该显示的剩余时间\n这里国际化是重点\n首先来看一下 js 提供的当地时间（根据浏览器所设地区显示相应时间）方法\nnew Date().toLocaleString(); // \u0026#34;2018/9/4 下午5:04:02\u0026#34; new Date().toLocaleDateString(); // \u0026#34;2018/9/4\u0026#34; new Date().toLocaleTimeString(); // \u0026#34;下午5:04:21\u0026#34; 这是 js i18n程序提供的时间格式化方法\nDate 对象是 js 原生时间库，以1970年1月1日00:00:00作为起点\nDate 对象作为普通函数直接调用会返回代表当前时间的字符串（无论是否传递参数）\nDate(); // \u0026#34;Tue Sep 04 2018 17:23:42 GMT+0800 (中国标准时间)\u0026#34; Date(\u0026#34;2018-08-08\u0026#34;); // \u0026#34;Tue Sep 04 2018 17:23:55 GMT+0800 (中国标准时间)\u0026#34; Date(2018, 08, 08); // \u0026#34;Tue Sep 04 2018 17:24:05 GMT+0800 (中国标准时间)\u0026#34; Date 作为构造函数时，使用 new 返回一个 Date 对象实例\nnew Date(); // Tue Sep 04 2018 17:25:49 GMT+0800 (中国标准时间) new Date(\u0026#34;2018-08-08\u0026#34;); // Wed Aug 08 2018 08:00:00 GMT+0800 (中国标准时间) new Date(2018, 08, 08); // Sat Sep 08 2018 00:00:00 GMT+0800 (中国标准时间) *** 特殊地\n普通对象求值，都默认调用其 valueOf()方法，而 Date 实例求值，默认调用 toString()方法\nvar a = \u0026#34;hello\u0026#34;; a; // \u0026#34;hello\u0026#34; a.valueOf(); // \u0026#34;hello\u0026#34; a.toString(); // \u0026#34;hello\u0026#34; var b = 3; b; // 3 b.valueOf(); // 3 b.toString(); // \u0026#34;3\u0026#34; var c = new Date(); c; // Tue Sep 04 2018 17:31:30 GMT+0800 (中国标准时间) c.valueOf(); // 1536053490129 c.toString(); // \u0026#34;Tue Sep 04 2018 17:31:30 GMT+0800 (中国标准时间)\u0026#34; 使用 Date 构造函数生产日期实例可传递各种类型的参数\nnew Date().valueOf(); // 1536053659322 // 参数为时间零点开始计算的毫秒数 new Date(1536053659322); // Tue Sep 04 2018 17:34:19 GMT+0800 (中国标准时间) // 参数为日期字符串 new Date(\u0026#34;Sep 4, 2018\u0026#34;); // Tue Sep 04 2018 00:00:00 GMT+0800 (中国标准时间) new Date(\u0026#34;Oct 4, 2018\u0026#34;); // Thu Oct 04 2018 00:00:00 GMT+0800 (中国标准时间) new Date(\u0026#34;Oct 4, 2018, 08:59:59\u0026#34;); // Thu Oct 04 2018 08:59:59 GMT+0800 (中国标准时间) new Date(\u0026#34;Oct 4, 2018, 08:61:59\u0026#34;); // Invalid Date // 参数为多个整数 // 代表年、月、日、小时、分钟、秒、毫秒 new Date(2018, 10, 23, 6, 34, 59, 500); // Fri Nov 23 2018 06:34:59 GMT+0800 (中国标准时间) new Date(\u0026#34;Fri Nov 23 2018 06:34:59\u0026#34;); // Fri Nov 23 2018 06:34:59 GMT+0800 (中国标准时间) new Date(\u0026#34;Fri Nov 23 2018 06:34:59\u0026#34;).valueOf(); // 1542926099000 既然这样，那么 Date()构造方法的参数都可以是什么格式的呢？\n答：任何可以被 Date.parse()方法解析的字符串\n注意点\n参数可以是负整数，代表 1970 年元旦之前的时间\n参数为多个整数时，至少需要两个参数，即年和月，若只传递一个参数，将按照毫秒数处理\n参数取值范围\n年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前 月：0表示一月，依次类推，11表示12月 日：1到31 小时：0到23 分钟：0到59 秒：0到59 毫秒：0到999 参数如果超出了正常范围，会被自动折算\n参数只有一个时，使用负整数表示1970年元旦之前的时间，参数为多个整数时，使用负整数表示从基准日扣去相应的时间\nnew Date(-1542926099000) // Wed Feb 09 1921 09:25:01 GMT+0800 (中国标准时间) new Date(2018, 09, -1) // Sat Sep 29 2018 00:00:00 GMT+0800 (中国标准时间) new Date(2018, 0) Mon Jan 01 2018 00:00:00 GMT+0800 (中国标准时间) new Date(2018, 0, -1) Sat Dec 30 2017 00:00:00 GMT+0800 (中国标准时间) new Date(2018, 1, -1) Tue Jan 30 2018 00:00:00 GMT+0800 (中国标准时间) new Date(2018, 1) Thu Feb 01 2018 00:00:00 GMT+0800 (中国标准时间) 留个疑问，如何求明年的昨天，比如，现在是Tue Sep 04 2018 18:04:58 GMT+0800 (中国标准时间)，明年的昨天即是Wed Sep 03 2019 18:04:58 GMT+0800 (中国标准时间)，有好的方法可以提 PR，\n此处的目标时间如下：\n2018 年 9 月 12 日上午 10 点（北京时间 9 月 13 日凌晨 1 点） 后记 没想到最终呈现出来这么简单的一个页面竟涉及到这么多东西，而且每一个环节都可以细究到很多深层次的东西，这就是 web 的世界\n补充 使用 vscode+搜狗输入法编辑本 md 文件上传至 github 后发现隐藏字符\n查得原因为\n在 mac 版 vscode 的中文输入法下，按下任意字母，出现中文候选后按删除键，删除完刚才输入的字母再按删除会出现这个控制字符\nmac 版的 vscode 中这个隐藏字符默认隐藏，可通过修改如下配置打开，将文档中显示BS的退格符全局搜索并替换为空即可\n//控制编辑器是否应呈现控制字符 \u0026#34;editor.renderControlCharacters\u0026#34;: true 原理解析：BS为 ASCII 码中的退格符的 Unicode 表示法，而所有 ASCII控制字符都有一个图形外观\n参考资料：\njianshu-【CSS】渐变背景 runoob-CSS3 渐变 oschina-介绍 JavaScript 国际化 API JavaScript 标准参考教程（alpha）之 Date segmentfault-JavaScript 时间与日期处理实战:你肯定被坑过 runoob-jquery jianshu-如何优雅的选择字体 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-09-05-html5-clock-webapp/","summary":"\u003cp\u003e心血来潮，想做一个苹果发布会的倒计时\u003c/p\u003e","title":"如何使用原生技术写一个倒计时时钟"},{"content":"记录如何把博客从离线存储配置成可通过 git 维护\n背景 本博客之前一直处于离线保存方式，因为 hexo 最终发布后的目录结构和源文件目录结构并不相同，发布后的博客的确是发布到 git 远程仓库，并通过 pages 服务提供网页端展示的，但是源博客结构要如何通过 git 进行维护呢？试想，如果源博客文件夹如果不慎丢失，且没有备份，那么即使下载发布后的博客，也无法使用该目录进行新的博客发布和维护，或者即使有备份，也是过时的备份（总不能每次发布新的博客都手动进行新的备份），那么同样会丢失备份时间之后的博客源文件，所以使用 git 进行版本管理当务之急。\n方案 另起一个远程 git 仓库，用于存储博客源文件夹（首先将其初始化一个 git 仓库）\n问题 第一次初始化博客文件夹并将其添加进暂存区提交时会提示 theme 文件夹中存在 git 子项目，需要对其进行子项目处理，其实只是 theme 中的项目原本也是 git 项目，然而此处不需要对其单独维护，而将其作为博客主目录的一个子目录进行维护便可，所以将主题中的.git 目录删除，将其脱离子项目的 git 管理，而作为博客主目录的一个子文件夹存在即可。\n优化 尽管现在博客目录在 git 管理之下，但是仍需每次对博客进行变动后手动提交对其进行维护，由于每次发布博客或修改博客内容后都需要编译发布将其更新到远端，所以这里可以写一个脚本，将 git 提交与博客发布进行联动处理即可，脚本如下：\nhexo g -d git add . git commit -m \u0026#39;another commit\u0026#39; git push origin master 结语 这样便达到既可以每次更新博客，又可以将其纳入 git 维护，而不用担心博客文件丢失，因为每次对博客的更新都会存储在远端仓库，当想要恢复博客的时候从远端仓库拉下最新的内容即可继续使用\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-09-03-blog-backup/","summary":"\u003cp\u003e记录如何把博客从离线存储配置成可通过 git 维护\u003c/p\u003e","title":"我是如何备份博客的"},{"content":"函数表达式 定义函数方式 函数声明 function fun() {} 函数表达式 var fun = function () {}; 关键词 函数声明提升 执行代码前会先读取函数声明，所以在函数声明前也可以调用函数\ntest(); function test() { alert(\u0026#34;test\u0026#34;); } // ok 匿名函数（lambda 函数） 函数表达式同其他表达式，使用前需先声明，否则报错\ntest(); function test() { alert(\u0026#34;test\u0026#34;); } // 报错 递归 经典阶乘\nfunction factorial(num) { if (num \u0026lt;= 1) { return 1; } else { return num * factorial(num - 1); } } 如下会使这个函数报错\n// 把factorial()函数保存在another变量中 var another = factorial; // 把变量factorial置空 factorial = null; // 调用another()必须执行factorial(),而factorial不再是函数 alert(another(4)); 解决：使用arguments.callee(指向正在执行的函数的指针)\nfunction factorial(num) { if (num \u0026lt;= 1) { return 1; } else { return num * arguments.callee(num - 1); } } 结论：使用递归函数，通过arguments.callee替代函数名更保险\n特例：严格模式下无法通过脚本访问arguments.callee\n方案：使用命名表达式（适用于严格和非严格模式）\nvar factorial = function f(num) { if (num \u0026lt;= 1) { return 1; } else { return num * f(num - 1); } }; 对比不适用命名表达式的情况\nvar factorial = function (num) { if (num \u0026lt;= 1) { return 1; } else { return num * factorial(num - 1); } }; 创建了名为 f()的命名函数表达式，并将其赋值给 factorial，这样尽管把函数赋值给其他变量，函数名 f 仍有效\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-09-03-js-note/","summary":"函数表达式 定义函数方式 函数声明 function fun() {} 函数表达式 var fun = function () {}; 关键词 函数声明提升 执行代码前会先读取函数声明，所以在函数声明前也可以调用函数\ntest(); function test() { alert(\u0026#34;test\u0026#34;); } // ok 匿名函数（lambda 函数） 函数表达式同其他表达式，使用前需先声明，否则报错\ntest(); function test() { alert(\u0026#34;test\u0026#34;); } // 报错 递归 经典阶乘\nfunction factorial(num) { if (num \u0026lt;= 1) { return 1; } else { return num * factorial(num - 1); } } 如下会使这个函数报错\n// 把factorial()函数保存在another变量中 var another = factorial; // 把变量factorial置空 factorial = null; // 调用another()必须执行factorial(),而factorial不再是函数 alert(another(4)); 解决：使用arguments.","title":"JavaScript高级程序设计第3版笔记（一）"},{"content":"服务器搭建 Gitlab\n创作于 2018 年左右，最初创建时间已丢失\n环境 ubuntu16.04 安装 gitlab-ee 步骤(无特殊说明，安装过程中采用默认配置项) 安装和配置必要依赖 sudo apt-get update sudo apt-get install -y curl openssh-server ca-certificates 安装邮件服务器 sudo apt-get install -y postfix 下载 gitlab 安装包并安装 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash 设置访问路径(此处有坑) sudo EXTERNAL_URL=\u0026#34;http://gitlab.example.com\u0026#34; apt-get install gitlab-ee 这里的方式是在安装 gitlab 企业版的命令上通过参数的方式指定访问地址，官网示例中直接给的是一个域名地址，此操作其实会在 gitlab 安装后的/etc/gitlab/gitlab.rb文件里有个EXTERNAL_URL的配置项（整个 gitlab 的所有配置都在此）\n所以当然这里也就可以只进行安装，即\nsudo apt-get install gitlab-ee 然后再修改默认的配置文件，把EXTERNAL_URL改成 gitlab 的访问地址\nvi /etc/gitlab/gitlab.rb 重新加载配置文件\nsudo gitlab-ctl reconfigure 重启 gitlab 服务\nsudo gitlab-ctl restart 问题来了，如果你这里EXTERNAL_URL配置为机器的 IP，即\nEXTERNAL_URL=\u0026#34;http://xx.xx.xx.xx\u0026#34; 那么默认访问的是http://xx.xx.xx.xx的 80 端口，而 80 端口可能被占用，或受 ECS 限制，需要单独配置 80 端口的访问权限，所以这里可以自定义访问的端口，方法也很简单，就是在 IP 地址后面加上端口，例如：\nEXTERNAL_URL=\u0026#34;http://xx.xx.xx.xx:8800\u0026#34; 然后还有关键的一步，就是开放端口对外的访问权限，这里以 ubuntu16.04 为例\n安装 iptables\nsudo apt-get install iptables 添加规则\niptables -I INPUT -p tcp --dport 8800 -j ACCEPT 保存规则\niptables-save 这样操作后，服务器重启后会失效，需要持久化规则\n安装 iptables-persistent\nsudo apt-get install iptables-persistent sudo netfilter-persistent save sudo netfilter-persistent reload 初始化账号 访问配置好的 gitlab 地址，例如http://xx.xx.xx.xx:8800，会提示设置密码，这里设置的即是管理员 root 的密码，重设后使用如下账号登录管理员账号\n用户名：root\n密码：重设后的密码\n初始化组、用户、项目 创建一个 group，点击顶部扳手图标（admin area），添加用户，添加用户后保存，然后再通过 Edit 修改可设置初始密码（用户使用该账号登录后会提示修改密码）\n将用户添加进组，创建项目\n用户初始操作\n登录 gitlab 地址，点击 Setting，添加本地已有的或生成的 SSH-KEY\n完成 卸载 gitlab-ee 这才是个大坑，比安装麻烦（卸载干净不容易），官网也没找到官方的卸载步骤\n还好*nix 系统秉承一切皆文件，并且提供了一系列强大工具，比如 ls、find、grep，可以全局查找进行手动清理\n停服务 sudo gitlab-ctl stop 进程操作（可选） 查看进程\nps -ef|grep gitlab 找到守护进程runsvdir -P /opt/gitlab/service log的 PID 并停掉\nkill -9 端口号 删除 gitlab 相关文件 find / -name gitlab |xargs rm -rf 删除包含 gitlab 的相关目录和文件 find / -name *gitlab*|xargs rm -rf 删除 uninstall 时生成的备份文件（可选） ls /root/gitlab* rm -rf /root/gitlab* Done 安装 gitlab-ce 1、2 步同企业版(简略如下)\nsudo apt-get install curl openssh-server ca-certificates postfix 下载 gitlab-ce 包 curl -O https://downloads-packages.s3.amazonaws.com/ubuntu-14.04/gitlab_7.4.2-omnibus-1_amd64.deb 或者直接下载安装脚本 curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash 上面的脚本执行后会添加 gitlab 服务器配置到/etc/apt/sources.list.d目录，并且添加配置文件gitlab_gitlab-ce.list到/etc/apt/sources.list.d目录，内容如下 # this file was generated by packages.gitlab.com for # the repository at https://packages.gitlab.com/gitlab/gitlab-ce deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ xenial main deb-src https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ xenial main 可通过more /etc/apt/sources.list.d/gitlab_gitlab-ce.list查看\n后缀为 deb 的为包，使用 curl -O 下载到本地当前文件夹，名称为 deb 包的文件名，使用-o参数可以自定义下载到本地的文件名，例如curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html，后缀为 deb.sh 的为安装脚本，需要通过管道调用 bash 来运行安装脚本，例如curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash\n安装 gitlab-ce sudo apt-get install gitlab-ce 修改配置文件，把EXTERNAL_URL改成 gitlab 的访问地址 vi /etc/gitlab/gitlab.rb 重新加载配置文件 sudo gitlab-ctl reconfigure 重启 gitlab 服务 sudo gitlab-ctl restart 其他操作见企业版安装（比如开放外部访问端口等）\n访问配置好的地址\n账号初始化\n参考链接 gitlab 官方文档——安装篇 ubuntu 开放指定端口 使用本地已有 ssh-key 或生成 ssh-key 社区版 gitlab 部署 gitlab 论坛关于卸载 gitlab 社区版 CentOs 7 安装 GitLab、完全卸载 GitLab Ubuntu16.04 安装 gitlab-ce ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-08-27-gitlab-use/","summary":"\u003cp\u003e服务器搭建 Gitlab\u003c/p\u003e","title":"服务器搭建Gitlab"},{"content":"使用 vue-cli3 脚手架初始化前端项目\n1. 安装 vue-cli3 npm install -g @vue/cli 2. 创建项目 vue create code-monkeys-fe-vue 3. 核心配置文件 vue-cli3 采用约定优于配置的思想，去除了很多配置项，转而都由项目根目录下的vue.config.js中既定的格式进行配置\n4. 示例配置 const express = require(\u0026#34;express\u0026#34;); const app = express(); const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); var apiRoutes = express.Router(); app.use(\u0026#34;/mock\u0026#34;, apiRoutes); const responseFunction = (req, res) =\u0026gt; { const fileName = req.params.fileName; let obj = null; try { // require 有缓存问题 let objStr = fs .readFileSync(path.join(__dirname, \u0026#34;/mock/data/\u0026#34; + fileName)) .toString(); if (objStr) { obj = JSON.parse(objStr); } } catch (e) { // console.log(\u0026#39;无法打开 =\u0026gt; \u0026#39; + fileName + \u0026#39; 文件\u0026#39;); } if (!obj || obj == undefined) { res.json({ err: \u0026#34;json文件无数据\u0026#34;, }); } else { res.json(obj); } }; module.exports = { devServer: { // 中间加一道代理，根据识别到的路由规则拦截请求（此函数相当于拦截器） before(app) { app.get(\u0026#34;/mock/data/:fileName\u0026#34;, responseFunction); app.post(\u0026#34;/mock/data/:fileName\u0026#34;, responseFunction); }, // 解决跨域问题，对`/api`请求代理跨域 proxy: { \u0026#34;/api\u0026#34;: { // target: \u0026#39;http://127.0.0.1:3000/\u0026#39;,//设置你调用的接口域名和端口号 target: \u0026#34;http://xx.xx.xx.xx:3000/\u0026#34;, //设置你调用的接口域名和端口号 changeOrigin: true, //跨域 // pathRewrite: { // \u0026#39;^/api\u0026#39;: \u0026#39;/\u0026#39; //这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用\u0026#39;http://10.1.5.11:8080/xxx/duty?time=2017-07-07 14:57:22\u0026#39;，直接写‘/api/xxx/duty?time=2017-07-07 14:57:22’即可 // } }, }, }, configureWebpack: { devtool: \u0026#34;source-map\u0026#34;, }, }; 5. package.json { \u0026#34;name\u0026#34;: \u0026#34;code-monkeys-fe-vue\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;cross-env NODE_ENV=dev vue-cli-service serve --inspect --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_ENV=prod vue-cli-service build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vue-cli-service lint\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;axios\u0026#34;: \u0026#34;^0.18.0\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;^2.5.17\u0026#34;, \u0026#34;vue-router\u0026#34;: \u0026#34;^3.0.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vue/cli-plugin-babel\u0026#34;: \u0026#34;^3.0.0\u0026#34;, \u0026#34;@vue/cli-plugin-eslint\u0026#34;: \u0026#34;^3.0.0\u0026#34;, \u0026#34;@vue/cli-service\u0026#34;: \u0026#34;^3.0.0\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^5.2.0\u0026#34;, \u0026#34;vue-template-compiler\u0026#34;: \u0026#34;^2.5.17\u0026#34; }, \u0026#34;eslintConfig\u0026#34;: { \u0026#34;root\u0026#34;: true, \u0026#34;env\u0026#34;: { \u0026#34;node\u0026#34;: true }, \u0026#34;extends\u0026#34;: [\u0026#34;plugin:vue/essential\u0026#34;, \u0026#34;eslint:recommended\u0026#34;], \u0026#34;rules\u0026#34;: {}, \u0026#34;parserOptions\u0026#34;: { \u0026#34;parser\u0026#34;: \u0026#34;babel-eslint\u0026#34; } }, \u0026#34;postcss\u0026#34;: { \u0026#34;plugins\u0026#34;: { \u0026#34;autoprefixer\u0026#34;: {} } }, \u0026#34;browserslist\u0026#34;: [\u0026#34;\u0026gt; 1%\u0026#34;, \u0026#34;last 2 versions\u0026#34;, \u0026#34;not ie \u0026lt;= 8\u0026#34;] } 6. 加入 router 修改入口文件\nimport Vue from \u0026#34;vue\u0026#34;; import App from \u0026#34;./App.vue\u0026#34;; import \u0026#34;./utils/global\u0026#34;; import router from \u0026#34;./router\u0026#34;; Vue.config.productionTip = false; new Vue({ router, render: (h) =\u0026gt; h(App), }).$mount(\u0026#34;#app\u0026#34;); router.push(\u0026#34;/\u0026#34;); // 相当于以下完整写法，见：https://segmentfault.com/a/1190000014254740 // const app=new Vue({ // el:\u0026#39;#app\u0026#39;, // router, // compoments:{ // App // }, // template:\u0026#34;\u0026lt;App/\u0026gt;\u0026#34; // }); 增加路由配置\nimport Vue from \u0026#34;vue\u0026#34;; import Router from \u0026#34;vue-router\u0026#34;; import HomeContent from \u0026#34;@/views/HomeContent\u0026#34;; import SinglePostContent from \u0026#34;@/components/ForumPost/SinglePostContent.vue\u0026#34;; Vue.use(Router); export default new Router({ mode: \u0026#34;history\u0026#34;, routes: [ { path: \u0026#34;/\u0026#34;, name: \u0026#34;homeContent\u0026#34;, component: HomeContent, }, { path: \u0026#34;/single-post/:id\u0026#34;, name: \u0026#34;single-post-content\u0026#34;, component: SinglePostContent, }, ], }); 7. 开发主页面 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ForumHome /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ForumHome from \u0026#39;./components/ForumHome.vue\u0026#39; export default { name: \u0026#39;app\u0026#39;, components: { ForumHome } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: \u0026#39;Avenir\u0026#39;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; color: #2c3e50; height: 100%; /* margin-top: 60px; */ } html, body { height: 100%; } a { text-decoration: none; cursor: pointer; } \u0026lt;/style\u0026gt; 8. 封装 ajax 请求对象 // export 时使用default，则import时不需要加大括号，否则需要加大括号引入export导出的变量 import apiConfig from \u0026#34;./apiConfig\u0026#34;; import axios from \u0026#34;axios\u0026#34;; /** * 使用立即执行函数表达式（IIFE）声明一些全局性（window对象的）方法或属性 */ (function (win) { /** * 为 String 添加 endsWith 方法，此方法在ES6中实现，以下为向下兼容处理（Polyfill） */ if (!String.prototype.endsWith) { String.prototype.endsWith = function (search, this_len) { if (this_len === undefined || this_len \u0026gt; this.length) { this_len = this.length; } return this.substring(this_len - search.length, this_len) === search; }; } /** * 判断是否是字符串 * @param {*} obj */ function isStr(obj) { return typeof obj === \u0026#34;string\u0026#34;; } /** * ajax请求 * @param {*} obj */ const ajax = function (obj) { // 最终ajax请求的地址 let url; const ajaxUrl = obj.url; // 如果地址以Api结尾 if (isStr(ajaxUrl) \u0026amp;\u0026amp; ajaxUrl.endsWith(\u0026#34;Api\u0026#34;)) { // 判断环境是否为开发环境 const env = process.env.NODE_ENV; // 存在环境变量设置并且在枚举范围内 if (env \u0026amp;\u0026amp; apiConfig[ajaxUrl] \u0026amp;\u0026amp; apiConfig[ajaxUrl][env]) { url = apiConfig[ajaxUrl][env]; } } else { url = ajaxUrl; } /* eslint-disable */ console.log(obj); console.log(url); if (obj.type == \u0026#34;get\u0026#34;) { axios .get(url) .then(function (response) { obj.callback(response); }) .catch(function (error) { obj.err(error); }); } else { console.log(url, obj.params); axios .post(url, obj.params) .then(function (response) { obj.callback(response); }) .catch(function (error) { obj.err(error); }); } }; win.ajax = ajax; win.isStr = isStr; })(window); 9. 路由使用 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;home-center-nav\u0026#34;\u0026gt; \u0026lt;router-link class=\u0026#34;home-router\u0026#34; to=\u0026#34;/\u0026#34;\u0026gt; {{ page_title }} \u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 以下为路由所决定显示的部分 --\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HomeCenter\u0026#39;, data() { return { page_title: \u0026#39;Home\u0026#39;, } }, components: { }, props: { msg: String }, methods: { }, created() { } } \u0026lt;/script\u0026gt; \u0026lt;!-- Add \u0026#34;scoped\u0026#34; attribute to limit CSS to this component only --\u0026gt; \u0026lt;style scoped\u0026gt; body { height: 100%; } .home-router { color: rgb(119, 119, 119); } .home-center { display: flex; flex-direction: column; height: 100%; background-color: #EEEEEE; padding: 0 143px; } .home-center-nav { padding: 15px 0; } .home-center-content { display: flex; justify-content: flex-start; } \u0026lt;/style\u0026gt; 10. jenkins 自动化打包发布 拉取指定 git 仓库指定分支或指定 tag 代码并执行以下脚本完成编译打包\nnpm config set registry http://registry.npm.taobao.org/ \u0026amp;\u0026amp; npm install \u0026amp;\u0026amp; npm run build \u0026amp;\u0026amp; cd dist \u0026amp;\u0026amp; tar -zcvf dist.tar.gz * 指定服务器地址，通过 ssh 方式发送项目包并解压到指定目录\ncd /opt/www/codemonkeys-fe tar -zxvf dist.tar.gz rm -rf dist.tar.gz 11. 配置 Nginx server { listen 80; server_name xxx.com; #charset koi8-r; access_log /var/log/nginx/xxx.com.access.log main; location / { root /opt/www/xxx; index index.html index.htm; } # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 12. 使用 Koa 开发后端服务器提供接口 初始化 package.json\nnpm init 配置 package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;code-monkeys-fe-node\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;#### 项目介绍 前段项目node代理服务\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;export NODE_ENV=development \u0026amp;\u0026amp; nodemon --harmony ./app.js\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;deploy_setup\u0026#34;: \u0026#34;pm2 deploy ecosystem.config.js production setup\u0026#34;, \u0026#34;deploy\u0026#34;: \u0026#34;pm2 deploy ecosystem.config.js production\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;export NODE_ENV=production \u0026amp;\u0026amp; pm2 start ./app.js --max-memory-restart 300M -n codemonkeys-node --watch\u0026#34;, \u0026#34;stop\u0026#34;: \u0026#34;export NODE_ENV=production \u0026amp;\u0026amp; pm2 stop ./app.js -n codemonkeys-node\u0026#34; }, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;git@xxx.git\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;codemonkeys@wangxin\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;babel-preset-es2015\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-preset-stage-0\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;koa\u0026#34;: \u0026#34;^2.5.3\u0026#34;, \u0026#34;koa-bodyparser\u0026#34;: \u0026#34;^4.2.1\u0026#34;, \u0026#34;koa-logger\u0026#34;: \u0026#34;^3.2.0\u0026#34;, \u0026#34;koa-mysql-session\u0026#34;: \u0026#34;0.0.2\u0026#34;, \u0026#34;koa-redis\u0026#34;: \u0026#34;^3.1.2\u0026#34;, \u0026#34;koa-router\u0026#34;: \u0026#34;^7.4.0\u0026#34;, \u0026#34;koa-session-minimal\u0026#34;: \u0026#34;^3.0.4\u0026#34;, \u0026#34;koa2-cors\u0026#34;: \u0026#34;^2.0.6\u0026#34;, \u0026#34;mysql\u0026#34;: \u0026#34;^2.16.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^1.18.4\u0026#34;, \u0026#34;pm2\u0026#34;: \u0026#34;^3.2.2\u0026#34; } } 入口主文件app.js\nconst Koa = require(\u0026#34;koa\u0026#34;); const app = new Koa(); const routers = require(\u0026#34;./router/index\u0026#34;); const koaLogger = require(\u0026#34;koa-logger\u0026#34;); const session = require(\u0026#34;koa-session-minimal\u0026#34;); const redisStore = require(\u0026#34;koa-redis\u0026#34;); const cors = require(\u0026#34;koa2-cors\u0026#34;); const bodyParser = require(\u0026#34;koa-bodyparser\u0026#34;); const { HOST, PORT } = require(\u0026#34;./config/server-info\u0026#34;); const env = process.env.NODE_ENV; // cookie // 存放sessionId的cookie配置 /* session cookie */ let cookieConfig = { maxAge: 86400000, // cookie有效时长 expires: \u0026#34;\u0026#34;, // cookie失效时间 path: \u0026#34;\u0026#34;, // 写cookie所在的路径 domain: HOST, // 写cookie所在的域名 httpOnly: true, // 是否只用于http请求中获取 overwrite: true, // 是否允许重写 secure: \u0026#34;\u0026#34;, sameSite: \u0026#34;\u0026#34;, signed: \u0026#34;\u0026#34;, }; // 使用koa2-cors中间件解决跨域请求 app.use(cors()); app.use(bodyParser()); // 配置session中间件 app.use( session({ key: \u0026#34;USER_SID\u0026#34;, store: redisStore(), cookie: cookieConfig, }) ); app.use(koaLogger()); // 初始化路由中间件 app.use(routers.routes()).use(routers.allowedMethods()); app.use(async (ctx) =\u0026gt; { if (ctx.status === 404) { ctx.redirect(\u0026#34;/not-found\u0026#34;); } }); // 监听启动端口 app.listen(PORT); console.log(`the server is start at port ${PORT}`); 13. 使用 pm2 部署启动后端项目 核心配置文件\nmodule.exports = { apps: [ { script: \u0026#34;app.js\u0026#34;, interpreter: \u0026#34;node@10.0.0\u0026#34;, // Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/ // args: \u0026#39;one two\u0026#39;, instances: 1, autorestart: true, watch: false, max_memory_restart: \u0026#34;300M\u0026#34;, env: { NODE_ENV: \u0026#34;development\u0026#34;, }, env_production: { NODE_ENV: \u0026#34;production\u0026#34;, }, }, ], deploy: { production: { user: \u0026#34;root\u0026#34;, host: \u0026#34;xx.xx.xx.xx\u0026#34;, ref: \u0026#34;origin/master\u0026#34;, repo: \u0026#34;git@xx.git\u0026#34;, path: \u0026#34;/opt/www/xxx\u0026#34;, ssh_options: \u0026#34;StrictHostKeyChecking=no\u0026#34;, \u0026#34;post-deploy\u0026#34;: \u0026#34;npm install \u0026amp;\u0026amp; pm2 reload ecosystem.config.js --env production\u0026#34;, }, }, }; 14. 增加后端请求路由配置 const router = require(\u0026#34;koa-router\u0026#34;)(); const api = require(\u0026#34;../controller/api\u0026#34;); module.exports = router .get(\u0026#34;/\u0026#34;, api.homepage) .get(\u0026#34;/api/forum-post/list\u0026#34;, api.getPosts) .post(\u0026#34;/api/forum-post/getById\u0026#34;, api.getPostById); 15. 接收请求并处理 const forumPost = require(\u0026#34;../models/forum-post\u0026#34;); const timeFormat = require(\u0026#34;../utils/time-format\u0026#34;); module.exports = { async homepage(ctx) { return (ctx.body = \u0026#34;server running\u0026#34;); }, /** * 分页查询列表 * @param {*} ctx */ async getPosts(ctx) { const currentPage = ctx.request.query.currentPage || 1; let pageSize = ctx.request.query.pageSize || 10; const page = { currentPage: currentPage, pageSize: pageSize, }; let result = await forumPost.getPostList(page); result = result.map((item) =\u0026gt; { item.create_time = timeFormat(item.create_time); return item; }); return (ctx.body = { status: 200, data: { result, }, }); }, /** * 根据ID查询 * @param {*} ctx */ async getPostById(ctx) { const postId = ctx.request.body.postId; let result = await forumPost.getPostById(postId); return (ctx.body = { status: 200, data: { result, }, }); }, }; 16. 操纵数据库做数据获取 const dbUtils = require(\u0026#34;../utils/db-utils\u0026#34;); const ForumPost = { /** * 分页查询文章列表 * @param {*} page */ async getPostList(page) { const _sql = ` SELECT * FROM forum_post WHERE is_delete = 0 AND is_publish = 1 ORDER BY forum_post.create_time DESC LIMIT ${page.pageSize} OFFSET ${page.currentPage - 1}`; const result = await dbUtils.query(_sql); return result; }, /** * 获取指定文章 * @param {string} id 文章id */ async getPostById(id) { const _sql = ` SELECT forum_post.* FROM forum_post WHERE forum_post.id = ${id}`; const result = await dbUtils.query(_sql); if (result.length) { return result[0]; } return null; }, }; module.exports = ForumPost; 17. 新建数据库 /** 建库 **/ CREATE DATABASE IF NOT EXISTS `codemonkeys-node` DEFAULT CHARSET utf8 COLLATE utf8_general_ci; /** 建帖子表 **/ CREATE TABLE IF NOT EXISTS `forum_post`( `id` INT NOT NULL AUTO_INCREMENT, `avatar` VARCHAR(100) NULL, `title` VARCHAR(40) NOT NULL, `author` VARCHAR(40) NOT NULL, `date` datetime, `create_time` datetime DEFAULT CURRENT_TIMESTAMP, `category` VARCHAR(40) NULL, `content` VARCHAR(20000) NOT NULL, `commentNum` INT NULL, `is_delete` INT DEFAULT 0, `is_publish` INT DEFAULT 1, PRIMARY KEY ( `id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; /** 原始数据 **/ INSERT INTO forum_post (avatar, title, author, date, category, content, commentNum) VALUES (\u0026#39;http://ourcia6f4.bkt.clouddn.com/avatar3.jpg\u0026#39;,\u0026#39;基于Spring Cloud的微服务设计\u0026#39;,\u0026#39;wangzhenzhong\u0026#39;,\u0026#39;2018-08-27\u0026#39;,\u0026#39;微服务\u0026#39;,\u0026#39;微服务这个词大家应该都不陌生，是最近几年技术发展的热门词汇之一。在当前系统需求越来越复杂，实现和维护成本越来越高的背景下，微服务确实是未来的发展趋势之一。由于工作的需要，最近花了半个月左右的时间研究了基于Spring Cloud的微服务设计与实现，颇有收获，本文就来对这半个月的成果进行一个总结，并聊一聊在我对微服务的一些思考。\u0026#39;,\u0026#39;64\u0026#39; ), (\u0026#39;http://ourcia6f4.bkt.clouddn.com/avatar4.jpg\u0026#39;,\u0026#39;再品Git, 深度解读\u0026#39;,\u0026#39;Taikoo\u0026#39;,\u0026#39;2018-08-23\u0026#39;,\u0026#39;git\u0026#39;,\u0026#39;和一个长期使用IDE(eclipse)集成git进行代码版本管理的人交流项目，博文内容将采用类似《大话设计模式》的对话体进行，场景真实，有代入感，正文部门前面是对方参照我写的readme搭建基于vue-cli的demo项目，安装node并通过npm安装项目依赖并本地启动项目等等，由于对方为后端Java开发，对新前端技术栈了解比较少，在搭建环境和启动项目过程中滋生一些趣事，比如使用npm启动项目后如何在浏览器访问项目，我为了让其醒目意识到我们的项目首页就是未经改动的Vue-cli首页，于是我将首页改动并推到远程master分支，后面便是我们的搞笑对话。\u0026#39;,\u0026#39;60\u0026#39; ); 18. 后端接口服务 nginx 配置 server { listen 80; server_name xxx.com; access_log /var/log/nginx/xxx.com-access.log; error_log /var/log/nginx/xxx.com-error.log; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://xx.xx.xx.xx:3000/; proxy_redirect off; } } 19. 发布后端服务到服务器指定目录 npm run deploy_setup 会在指定目录生成三个目录\nnpm run deploy 会将后端项目部署到指定目录\n20. 启动后端项目在服务器后端运行 进入服务器，在后端项目目录执行\nnpm run start 21. 完成 即可通过浏览器访问前端项目，调用后端接口返回数据进行显示\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-08-27-koa-vue-forum/","summary":"\u003cp\u003e使用 vue-cli3 脚手架初始化前端项目\u003c/p\u003e","title":"一周时间使用Vue+Koa全栈开发论坛项目"},{"content":"在 Ubuntu 16.04 安装禅道\n创作于 2018 年左右，最初创建时间已丢失\n1. 在任意目录下载解压版压缩包 wget http://dl.cnezsoft.com/zentao/10.4/ZenTaoPMS.10.4.stable.zbox_64.tar.gz 下载地址\n2. 将压缩包解压到指定目录/opt（必须） sudo tar -zxvf ZenTaoPMS.10.4.stable.zbox_64.tar.gz -C /opt 3. 指定 apache 和 mysql 端口启动 /opt/zbox/zbox -ap 8080 -mp 3306 start 查看是否提示\nStart Apache success Start Mysql success 4. 登录使用 初始账号\nadmin 123456 5. 机器开机自启配置 方法一 在/etc/init.d/rc.local中添加要运行的脚本（不建议使用）\n方法二 新建一个脚本 zentao.sh #!/bin/bash ### BEGIN INIT INFO # Provides: codemonkeys # Required-Start: $local_fs $network # Required-Stop: $local_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: zentao service # Description: zentao service daemon ### END INIT INFO /opt/zbox/zbox -ap 8090 -mp 3390 start 需要添加中间的一段注释内容，否则会在sudo update-rc.d zentao.sh defaults 99时提示\ninsserv: warning: script \u0026#39;zentao.sh\u0026#39; missing LSB tags and overrides 或者一劳永逸（不推荐）\napt-get remove insserv 设置脚本执行权限 sudo chmod 755 /etc/init.d/zentao.sh 将脚本加入启动脚本中 sudo update-rc.d zentao.sh defaults 99 最后的数字为脚本启动顺序号，取值范围是 0-99\n验证是否已成功添加 在上面脚本中配置的 rc 等级Default-Start: 2 3 4 5中的任意一个 rc 目录中查看是否增加了zentao.sh\ncd /etc/rc2.d ls 查看是否有zentao.sh后缀的脚本\n移出执行脚本方法 sudo update-rc.d -f zentao.sh remove 6. 停止和重启 /opt/zbox/zbox stop /opt/zbox/zbox restart 7. 其他(查看命令) /opt/zbox/zbox -h ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-08-27-install-zendao-on-ubuntu/","summary":"\u003cp\u003e在 Ubuntu 16.04 安装禅道\u003c/p\u003e","title":"在Ubuntu 16.04安装禅道"},{"content":"和一个长期使用 IDE(eclipse)集成 git 进行代码版本管理的人交流项目，博文内容将采用类似《大话设计模式》的对话体进行，场景真实，有代入感。\n正文部分前面是对方参照我写的 readme 搭建基于 vue-cli 的 demo 项目，安装 node 并通过 npm 安装项目依赖并本地启动项目等等，由于对方为后端 Java 开发，对新前端技术栈了解比较少，在搭建环境和启动项目过程中滋生一些趣事。\n比如使用 npm 启动项目后如何在浏览器访问项目，我为了让其醒目意识到我们的项目首页就是未经改动的 Vue-cli 首页，于是我将首页改动并推到远程 master 分支，后面便是我们的搞笑对话。\n正文 暂定对方昵称为lzz\nBegin\n我：“你再从 master 拉一下最新的代码，然后重跑一下”\nlzz：“速度教一波拉代码，我没操作过命令行”\n我：“git pull origin master”\nlzz：“我天天在 eclipse 操作”\nlzz：“要在项目目录下吗”\n我：“嗯”\nlzz：“这是 pull 下来吧，接下来的呢，ok 了？”\n我：“pull 会自动合并进当前分支，fetch 只拉，还需要手动 merge”\n此处涉及 git pull 和 git fetch \u0026amp; git merge 的区别\nlzz：“怎么上传分支”\n我：“你新建分支了吗，我瞅瞅”\nlzz：“如何瞅，命令行在哪看”\n我：“截图，git checkout -b 新建的分支名”\n我：“git branch 看现在在哪个分支”\nlzz：“你的分支”\nlzz：“我拉你的分支还是从主分支上拉比较好”\n我：“当然主分支，你为啥在我的分支”\nlzz：“我看看怎么拉主分支”\n我：“git checkout master”（我因得知他在我的分支上，所以让他先切到主分支上去）\nlzz：“我又没上传这个分支”\n我：“切换到主分支，你为啥会到我的分支”\nlzz：“不知道”\n我：“骚操作”\nlzz：“昨晚 zz 教我拉的时候拉的吧”\n我：“不学好”\nlzz：”fxxk，还要提交，我直接把这个分支删了吧“（我内心 os：\u0026quot;\u0026hellip; 为啥要删我分支 \u0026hellip;\u0026quot;）\n我：”你改啥了，你改动后删不掉的，git status“\n这里涉及使用git status查看本地仓库文件状态\nlzz：”fxxk you“\n我：”fxxk you too“\n我：”git status, 看看改啥了“\nlzz：”嗯“\n我：”git checkout .“\n我：”git checkout master“\n我：”git checkout -b lzz“\n我：”git push origin lzz“\nlzz：”我还原了，这是依赖吧“\n然后我看到他的控制台还有 package.json 和 package-lock.json 文件为已修改状态，于是提示他撤销全部\n我：”git checkout .“\nlzz：”npm clean？“\n我：”no“\nlzz：”你这是重放个位置了“\n我：”你执行就是了“\nlzz：”没鸟用，是../吧“\n我：”git status“\n他了一张截图，提示他所在目录不是一个 git 目录，因为他已经通过..到了项目上一级目录，自然不是 git 目录\n我：”回到项目目录“\nlzz：”git init?“\n我：”你乱跑啥“\n我：”cd ./项目目录名“\n我：”init 你妹“\n此时他已回到项目目录再次 git status，提示工作树干净(working tree clean)\n我：”git checkout master“\n我：”git checkout -b lzz“\n我：”git push origin lzz“\n我：”赶紧，让我看到你的分支，刷个存在感“\n经过操作，他在远端仓库推送了新的分支 lzz 到项目\n我：”不容易“\nlzz：”这个主分支和你的分支就 index.html 不一样吗“(因为他看到的是旧的 master，他并没有按照我的要求使用 git pull origin master 拉取我新提交的 master)\n我：”你就没改东西，一毛一样，现在三个分支内容一样“\nlzz：”页面不一样“\n我：”一样的，master 我改了，你刚才看到的就是 master 的“\nlzz：”嗯，提交就是，git push origin lzz？“\n严谨来说这里并不一定，因为 origin 只是 git 约定俗成的远程主机名，其实这个参数可以自定义，比如你需要推到多个远程仓库时，需要在 origin 之外自定义远程主机名\n我：”不是“\nlzz：”还是直接 git push“\n我：”这是把本地分支推到远程“\nlzz：”嗯“\n我：”提交是 git commit“\nlzz：”1，想起来了“\n我：”直接 git push 需要把本地同名分支和远程同名分支绑定“\n这里有待考究，我说的这是否是必要条件，但 git 的确是提供了-u 参数用于绑定本地分支与一个默认远程分支，这样仅使用 git pull 和 git push 便可将该远程分支与本地分支进行互动\nlzz：”git checkout . 放弃文件的修改吧？“\n我：”是，其实是把远端的覆盖本地的“\n关于 git checkout 的使用，理解为放弃修改，从效果上看的确是这样的，也是我一开始学习和使用 git 的理解，但从本质上 git checkout 实际还是在执行其本质行为，就是检出远程文件，只不过这样做的确就会将本地的覆盖，达到放弃本地文件的修改的效果\nlzz：”我每次重新切换分支，要 npm install 吗？“\n我：”新分支需要，已经 install 过的分支不需要“(此处涉及 npm 项目的知识，与本文关系不大)\nlzz：”我 push 的时候不会将这些包带着吧“\n我：”不会，.gitignore 忽略 node_modules 目录“(这当然是我配置的，不过这个问题问的很好，说明其意识到的 git 对于项目文件的管理细节)\nlzz：”貌似没有忽略啊“(他看到 package.json 和 package-lock.json 文件被提示尚未加进暂存区)\n我：”这两个文件可以提交，也可以手动忽略，我加一下“(所谓手动忽略当然就是使用 git checkout 检出远程同名文件覆盖本地的修改，我加一下是指其实 package-lock.json 的确不需要提交，而 package.json 随着项目的迭代可能有包的更新，所以项目团队间需要互通，不过如果使用相同的 node 环境，这样的更新每个人在本地都会有及时的感知，所以这两个文件是否要纳入版本管理不重要)\nlzz：”上面的.json 文件我并未改动，应该就像 maven 的 pom 文件一样，为什么会变动呢“(此处涉及 npm 对于依赖包的管理)\n我：”因为你又 npm install 了，会更新版本“\nlzz：”拉下新的版本，拉下我的“\n我：”干啥“(其实我已经在远端仓库客户端，我们会使用的 gitee，看见他的修改，一个小小的恶作剧)\nlzz：”你瞅瞅我的 master piece“\n我：”你发 pull request“\n此处涉及 gitee、github 这类用于公共开源，不同于 gitlab 的 merge request，而是通过发起 pull request 将分支合入 master\n他给我发了一张他提交记录的截图，标识他已经将自己本地的分支提交到远端仓库\n我：”你不提交 pull request，你就只是在自己的分支玩，你看看你能 merge 进 master 吗“\nlzz：”你拉我的分支不行吗，你把我的分支拉下来啊“\n我：”我干嘛要拉你的分支“\n我给他发一张我对于其提交的评论截图(基于 gitee)\nlzz：”你这个页面在哪，github 还是码云上“\n我：”gitee“\nlzz：”什么鬼？？？“(因为码云这个对于代码评论的功能的确做的看上去和 github 很像)\n我：”码云，就是 gitee“\n我：”洗洗睡吧“\nlzz：”这样？“\n他发了一张在操作 pull request 操作的截图，但填写是错误的，源分支为远程 lzz，目标分支为远程 lzz，其实 pull request 是要发起申请将你提交到远程仓库的分支 merge 进远程的 master 分支，经过操作，他最终成功发起了正确的 pull request\nlzz：”知道 PR 啥作用了“\n我：”目标分支填 master 啊“\nlzz：”嗯，知道了，睡觉“\nEND\n总结 整个过程其实就是一个经典的新手入手 git 并结合第三方远程仓库管理个人项目的各种操作，对话看上去愚蠢，但其实基本覆盖了团队基于 git 进行协作的基本操作和重要核心的 git flow\n结论 在此过程中虽然我使用 git 有一些经验，但还是觉得仍有部分环节的细节有待深入研究，不过经验就是：使用 git 一定要随时保持清醒，知道自己所处位置（git 仓库、暂存区、本地仓库、远程仓库），对分支的分分合合要有着清醒的头脑，否则很有可能在使用 git 这个管理代码和版本的强大工具之下也会搞的一团糟，它就像一把双刃剑，用好的话可以事倍功半，用不好也可能对代码项目带来严重的灾难\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-08-23-git-use/","summary":"\u003cp\u003e和一个长期使用 IDE(eclipse)集成 git 进行代码版本管理的人交流项目，博文内容将采用类似《大话设计模式》的对话体进行，场景真实，有代入感。\u003c/p\u003e","title":"再品Git, 深度解读"},{"content":"js 异步编程的4种方式\n背景 js 语言执行环境——单线程（Single Thread）\n单线程 一次只能执行一个任务，超过一个的就只能排队\n单线程优势 实现简单\n执行环境单纯\n单线程劣势 存在耗时很长的任务会拖慢整个程序的运行\n单线程带来的问题 浏览器无响应（假死）\n浏览器假死原因分析 某段 js 代码（某个任务）长时间运行（比如死循环）\njs 对于单线程劣势的解决方案 执行模式分为：同步（Synchronous）和异步（Asynchronus）\n同步模式 后一个任务等待前一个任务结束\n程序执行顺序同任务排列顺序\n异步模式 每个任务有 1 个或多个回调函数（callback）\n前一个任务结束，不是继续执行后一个任务，而是执行回调\n后一个任务不等前一个任务结束就执行\n程序的执行顺序和任务排列顺序不一致\n异步模式使用 浏览器端耗时长的任务都应该异步执行\n避免浏览器失去效应\n异步模式实践 Ajax\n异步编程的 4 种方式（实践） 1.回调函数（最基本） 实际场景 两个函数 f1()、f2()，f1()耗时长\n解决方案 把 f2()函数写成 f1()函数的回调函数\nfunction f1(callback) { setTimeout(function () { // code of f1 callback(); }, 1000); } f1(f2); f1 不会阻塞程序执行\n先执行程序主逻辑，耗时操作推迟执行\n回调函数存在的问题 不利于代码阅读和维护\n各部分间耦合高（Coupling）\n流程变乱\n每个任务仅支持一个回调函数\n2.事件监听（信号） 使用事件驱动模式——任务的执行不取决于代码顺序，而是事件的发生\n为 f1 绑定一个事件\nf1.on(\u0026#34;done\u0026#34;, f2); 解释：当 f1 发生 done 事件时执行 f2\nfunction f1() { setTimeout(function () { f1.trigger(\u0026#34;done\u0026#34;); }, 1000); } f1.trigger(\u0026lsquo;done\u0026rsquo;)表示当执行完其上的内容，立即触发 done 事件（即执行 f2）\n优势 容易理解\n每个事件可指定多个回调函数\n可以去耦合（decoupling）\n有利于实现模块化\n缺陷 整个程序变成事件驱动的\n运行流程不清晰\n3.发布/订阅模式 或 观察者模式（publish/subscribe pattern or observer pattern） 制造一个信号中心，某任务完成后向信号中心**发布（publish）一个信号，其他任务可向信号中心订阅（subscribe）**这个信号，从而得知自己什么时候执行\n该模式的多种实现 Ben Alman\u0026rsquo;s gist https://gist.github.com/661855 (recommended) Rick Waldron\u0026rsquo;s jQuery-core style take on the above https://gist.github.com/705311 Peter Higgins\u0026rsquo; plugin (http://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js). Ben Truyman\u0026rsquo;s gist https://gist.github.com/826794 参考：https://msdn.microsoft.com/en-us/magazine/hh201955.aspx\n这里举例第一种，是 jQuery 的一个插件\nf2 向 jQuery（信号中心）订阅 done 信号 jQuery.subscribe(\u0026#34;done\u0026#34;, f2); f1 向 jQuery（信号中心）发布 done 信号 function f1() { setTimeout(function () { jQuery.publish(\u0026#34;done\u0026#34;); }); } 如果 f2 只要执行一次，可以在执行后取消订阅\njQuery.unsubscribe(\u0026#34;done\u0026#34;, f2); 发布订阅模式优劣分析 与事件监听类似，但可通过信号中心清晰了解到存在多少信号（发布者发布了多少信号）、每个信号有多少订阅者，从而监控程序的执行\n4.Promises 对象 Promises 对象是 CommonJS 工作组提出的一种规范，目的旨在为异步编程提供统一的接口\nPromises 实现异步编程的思想 每一个异步任务返回一个 Promise 对象\n该对象有一个then方法，允许指定回调函数\n实例操作 为 f1 指定回调函数为 f2\nf1().then(f2); jQuery 的实现\nfunction f1() { var dfd = $.Deferred(); setTimeout(function () { dfd.resolve(); }, 1000); return dfd.promise; } 优点分析 回调函数变成了链式写法，程序流程清晰\n有配套的整套方法，可实现强大的功能\n应用场景 指定多个回调函数 f1().then(f2).then(f3); 指定发生错误时的回调函数 f1().then(f2).fail(f3); Promises 使用的优缺点 优点 一个任务已完成，再添加回调函数，该回调函数会立刻执行\n不用担心是否错过某个事件或信号\n缺点 难以理解和编写 参考链接：\nhttp://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-03-06-js-asynchronize/","summary":"\u003cp\u003ejs 异步编程的\u003cstrong\u003e4\u003c/strong\u003e种方式\u003c/p\u003e","title":"js异步编程"},{"content":"记录在运行 redux 官方文档中给出的基础实例运行时报错的解决思路\n核心 进程占用\n背景 在阅读 redux 文档http://cn.redux.js.org/时，遇到推荐示例simple-redux-example\n于是便按照 readme 说明实操一把\ngit clone npm install npm start 一切顺理成章，然而 boom!\n一脸懵逼\n什么原因呢？先是仔细看了报错信息，里面讲的还算清楚，告诉我不是 npm 的问题，于是按照推荐，打开具体的日志文件\n也没看出什么明显的问题\n于是在 error 附近的日志信息里找几个关键字拉近 google 搜索一下\n在 stackoverflow 的一篇帖子中的找到灵感\n没错，进程占用！经过上面几个人说的情况都不匹配后，这个原因我是感觉特别可能的\n于是赶紧检查 8000 端口是不是已经被占用\nnetstat -ano | findstr 8000 (进程 ID 之前是 3260，这是后来写本文时补的)\n果然被占用了，看一下哪个进程的 PID 是 3260\n之前这里有一个进程 PID 是 3260，发现是一个应用程序，没什么用，kill 掉\ntaskkill /PID 3260 再次启动\nnpm start Nice!搞定\n总结 解决问题的能力很重要，程序的世界不可能一帆风顺，耐心看日志，多借助有效途径（google not baidu, stackoverflow not zhidao），带上自己分析问题的思路和经验，问题总是能解决的。\n写此篇博客的目的在于加深此类问题的印象，对于一些常用操作做一个记录，避免下次遇到类似问题时把时间花在查阅搜索和问题定位上\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-25-redux-using/","summary":"\u003cp\u003e记录在运行 redux 官方文档中给出的基础实例运行时报错的解决思路\u003c/p\u003e","title":"记一次关于运行redux示例启动错误的分析"},{"content":"关于 jQuery 选择器的整理\n第一种分类规则 第一类——基本 通配：$(\u0026quot;*\u0026quot;)——所有元素\nid 唯一选择：$(\u0026quot;#name\u0026quot;)——匹配 id 为 name 的元素\nclass 匹配：$(\u0026quot;.name\u0026quot;)——匹配所有 class=\u0026ldquo;name\u0026quot;的元素\n标签元素：$(\u0026ldquo;p\u0026rdquo;)——所有元素\n且关系匹配：$(\u0026quot;.a.b\u0026rdquo;)——所有 class=\u0026ldquo;a\u0026quot;且 class=\u0026ldquo;b\u0026quot;的元素\n第二类——首尾、奇偶 某种标签的第一个：$(\u0026ldquo;p:first\u0026rdquo;)——第一个元素\n某种标签的最后一个：$(\u0026ldquo;p:last\u0026rdquo;)——最后一个元素\n某种标签的偶数元素：$(\u0026ldquo;tr:even\u0026rdquo;)——所有偶数元素\n某种标签的奇数元素：$(\u0026ldquo;tr:odd\u0026rdquo;)——所有奇数元素\n第三类 第 n 个元素：$(\u0026ldquo;ul li:eq(3)\u0026quot;)——列表中的第四个元素（索引从 0 起）\n大于某个索引值的元素：$(\u0026ldquo;ul li:gt(3)\u0026quot;)——索引大于 3 的元素\n小于某个索引值的元素：$(\u0026ldquo;ul li:lt(3)\u0026quot;)——索引小于 3 的元素\n非某个条件的元素：$(\u0026ldquo;input:not(:empty)\u0026quot;)——所有不为空的 input 元素\n第四类——指定标签 标题元素：$(\u0026quot;:header\u0026rdquo;)——所有标题元素（h1-h6）\n动画元素：$(\u0026quot;:animated\u0026rdquo;)——所有动画元素\n第五类 包含特定字符串的元素：$(\u0026quot;:contains(\u0026lsquo;someString\u0026rsquo;)\u0026quot;)——包含字符串 someString 的元素\n无子节点的所有元素：$(\u0026quot;:empty\u0026rdquo;)——没有子元素节点的所有元素\n隐藏元素：$(\u0026ldquo;p:hidden\u0026rdquo;)——所有隐藏的元素\n可见元素：$(\u0026ldquo;table:visible\u0026rdquo;)——所有可见的表格\n第六类——或关系多匹配 逗号分隔的多匹配元素：$(\u0026ldquo;th, td, .intro\u0026rdquo;)——所有 th、td 和 class=\u0026ldquo;intro\u0026quot;的元素\n第七类——元素属性 含有某个属性的元素：$(\u0026quot;[href]\u0026quot;)——所有包含 href 属性的元素\n属性为特定值的元素：$(\u0026quot;[href=\u0026rsquo;#\u0026rsquo;]\u0026quot;)——所有 href 属性为#的元素\n属性不为特定值的元素：$(\u0026quot;[href!=\u0026rsquo;#\u0026rsquo;]\u0026quot;)——所有 href 属性不为#的元素\n符合属性值通配的元素：$(\u0026quot;[href$=\u0026rsquo;.jpg\u0026rsquo;]\u0026quot;)——所有 href 属性以.jpg 结尾的元素\n第八类——不同 type 的 input 元素 text、password、radio、checkbox、submit、reset、button、image、file\n第九类——input 不同元素状态 可用元素：$(\u0026quot;:enabled\u0026rdquo;)——所有可用的 input 元素\n不可用元素：$(\u0026quot;:disabled\u0026rdquo;)——所有不可用的 input 元素\n选取的元素：$(\u0026ldquo;selected\u0026rdquo;)\n多选被选中的：$(\u0026ldquo;checked\u0026rdquo;)\n第二种分类规则 基本选择器\nid（指定元素）\nclass（css 类）\nelement（遍历 html 元素）\n*（所有元素）\n,（并列）\n层次选择器\nparent \u0026gt; child（直系子元素）\nprev + next（下一个兄弟，等同于 next()方法）\n$(\u0026#34;.item + div\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;#FF0000\u0026#34;); 等价于\n$(\u0026#34;.item\u0026#34;).next(\u0026#34;div\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;#FF0000\u0026#34;); prev ~ siblings（所有兄弟，等同于 nextAll()方法） $(\u0026#34;.inside ~ div\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;#FF0000\u0026#34;); 等价于\n$(\u0026#34;.inside\u0026#34;).nextAll(\u0026#34;div\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;#FF0000\u0026#34;); 过滤选择器\n基本过滤\n首尾元素\n:first\n:last\n取非\n$(\u0026#34;div:not(.wrap)\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;#FF0000\u0026#34;); \u0026lt;div\u0026gt;a\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt;b\u0026lt;/div\u0026gt; a 着色，b 不着色\n特别地，当非 wrap 元素包含子元素时，即是其子元素 class 为 wrap，仍会被选择到（因为父影响子）\n\u0026lt;div\u0026gt;a \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt;b\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; a、b 都着色\n奇偶（索引从 0 开始）\n:even\n:odd\n取指定元素（:eq(index)）\n大于或小于某个索引值\n:gt(index)\n:lt(index)\n标题(:header) 内容过滤\n包含（:contains(text)）\n不包含子元素或文本内容为空（:empty）\n取选择器匹配的元素（:has(selector)）\n$(\u0026#34;div:has(span)\u0026#34;).css(\u0026#34;border\u0026#34;, \u0026#34;1px solid #000\u0026#34;); \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt; A \u0026lt;span\u0026gt;B\u0026lt;/span\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; 因为此处的 div 子元素中的确含有 span，所以此处的 div 被选中，其子元素也会同样生效，所以 A 和 B 都会被加边框\n包含子元素或文本的元素（:parent） 某个元素因包含子元素或文本，而成为父元素，即被选中\n$(\u0026#34;ol li:parent\u0026#34;).css(\u0026#34;border\u0026#34;, \u0026#34;1px solid #000\u0026#34;); \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;A\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;D\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; A 和 D 因为包含文本而晋升为父元素，所以被加上边框\n可见性过滤\n隐藏元素（不占空间）——:hidden\n1.3.2 版本后:hidden 仅匹配隐藏且不占空间的元素（display:none、），对于 visibility:hidden、opacity:0 这样隐藏但占据空间的元素无效\n可见元素——:visible（凡不可见的元素均不选中）\n属性过滤\n[attribute]（选择拥有 attrbute 属性的元素）\n[attribute = value]、[attribute != value]（属性等于或不等于某值的元素）\n[attribute ^= value]、[attribute $= value]、[attribute *= value]（attribute 以 value 开头、以 value 结束、包含 value 的元素）\n[selector1][selector2]（复合型属性过滤，同时满足多个条件）\n$(\u0026#34;a[title^=jQuery][class=item]\u0026#34;).hide(); title 属性以 jQuery 开头并且 class=\u0026lsquo;item\u0026rsquo;的 a 元素选中并隐藏\n子元素过滤\n:first-child、:last-child :first 和:last 返回单个元素\n:first-child 和:last-child 返回集合元素\n:only-child（有且只有一个子元素的元素）\n:nth-child（第 n 个元素，n 从 1 开始）\n表单对象属性过滤\n可用或不可用元素（:enabled、:disabled）\n选中的单选框或多选框（:checked）\n下拉框中选中的元素（:selected）\n表单选择器\n总结：\n基本选择器 层次选择器 过滤选择器 表单选择器 参考链接：\nhttp://www.w3school.com.cn/jquery/jquery_ref_selectors.asp\nhttp://www.cnblogs.com/keepfool/archive/2012/06/02/2532203.html\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-23-js-basic-about-jquery-selector/","summary":"\u003cp\u003e关于 jQuery 选择器的整理\u003c/p\u003e","title":"前端基础知识整理——jQuery选择器"},{"content":"关于 Angular 学习整理\n简介 Angular 是谷歌开发和维护的一个开发跨平台应用程序的框架，适用于手机和 PC\n特点 跨平台：Web、移动、PC\n渲染快：Web Worker+SSR\n可伸缩：基于 RxJS、Immutable.js 及其他推送模型，可适应海量数据需求\n特性 DHTML\n表单系统（模型驱动）\n试图引擎\n事件处理\n快速渲染\n灵活路由\nHTTP 服务\n视图封装\nAOT、Tree Shaking\nAngular 与 AngularJS 区别 不再有 Controller 和 Scope\n更好的组件化及代码复用\n更好的移动端支持\n引入 RxJS 和 Observable\n引入 Zone.js，提供更智能的变化检测\n开发配置 基于 QuickStart 拷贝 quickstart 项目\ngit clone https://github.com/angular/quickstart 安装所需依赖\nnpm i 启动\nnpm start 基于 Angular CLI npm install -g @angular/cli npm install --save-dev @angular/cli@latest ng --version ng new projectname 切换到刚创建的工程目录\n浏览器访问 localhost:4200\n参考链接：\nhttps://segmentfault.com/a/1190000009733649 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-22-angular4/","summary":"\u003cp\u003e关于 Angular 学习整理\u003c/p\u003e","title":"Angular学习笔记"},{"content":"Vue.js 教程之 Vue 实例\n创建实例 每个 Vue 应用都是通过用Vue函数创建一个新的Vue 实例开始\nvar vm = new Vue({ // options }); 虽然没有遵守MVVM模型，但 Vue 的设计也受 MVVM 启发，故示例中常使用 vm(viewmodel 缩写)表示 Vue 实例\n一个 Vue 应用的组成：\n一个通过 new Vue 创建的根 Vue 实例\n可选的嵌套的、可复用的组件树\n所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象（一些根实例特有的选项除外）\nMVVM MVVM（model-view-viewmodel）是一种软件架构，有助于将图形用户界面开发与业务逻辑或后端逻辑开发分离开来，通过置标语言或 GUI 代码实现\nMVVM 的 viewmodel 是一个值转换器，意味着负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面 viewmodel 比 view 做的更多，且处理大部分视图的显示逻辑。\nviewmodel 可实现中介者模式，组织对 view 所支持的用例集的后端逻辑的访问\n标记语言 置标语言也称标记语言、标志语言、标识语言、markup language，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的计算机文字编码。\n与文本相关的其他信息（文本结构和表示信息等）与原文本结合在一起，但使用标记进行标识\n现状及历史 如今广泛使用的标记语言是 HTML 和 XML，广泛用于网页和网络应用程序，最早用于出版业，是作者、编辑及出版商之间用于描述出版作品的排版格式所使用的\n分类 标记语言通常分为三种：表示性、过程性、描述性\n表示性：编码过程中标记文档的结构信息 例如文本文件中，文件标题可能需要特定格式（居中、放大等），则需要标记文件的标题。\n字处理及桌面出版产品有时能自动推断出这类结构信息，但绝大多数，像 Wiki 这样的纯文本编辑器还不能解决这个问题\n过程性：一般专门于文字表达，但通常对于文本编辑者可见，且能够被软件依其出现顺序依次解读 为格式化一个标题，在标题文本之前，会紧接着插入一系列格式标识符，以指示计算机转到居中的显示模式，同时加大及加粗字体。在标题文本后，会紧接缀上格式中止标识\n对于更高级的系统宏命令或者堆栈模式会让这一过程的实现方式更加丰富\n大多数情况下，过程性标志能力包含有一个图灵完备编程语言\n图灵完备：当一组数据操作的规则（一组指令集、编程语言、元胞自动机）满足任意数据按照一定的顺序可以计算出果，称为图灵完备\n过程性标志语言范例：nroff、troff、TeX、Lout、PostScript\n过程性标志语言广泛用于专业出版领域，专业的出版商会根据要求使用不同的标志语言达到出版要求\n描述性 又称通用标识，描述文件的内容或结构，而非文件的显示外观或样式\n指定 SGML 的基本思想就是把文档的内容与样式分开，XML、SGML 都是典型的通用标识语言\n应用 GenCode\nTeX：功能强大的排版软件\nSGML：被用作编写《牛津英语词典》电子版本，由于复杂而难以普及\nHTML\nXML\nXHTML：（eXtensible HyperText Markup Language），表现方式与 HTML 类似，语法上更严格\n基于 XML 的应用：RDF、XForms、DocBook、SOAP、Web Ontology Language(WOL)\n数据与方法 当一个 Vue 实例被创建时，即向 Vue 的响应式系统中假如其 data 对象中能找到的所有的属性\n当这些属性改变时，试图将随之响应，即匹配更新的新值\n// 我们的数据对象 var data = { a: 1 }; // 该对象被加入到一个 Vue 实例中 var vm = new Vue({ data: data, }); // 它们引用相同的对象！ vm.a === data.a; // =\u0026gt; true // 设置属性也会影响到原始数据 vm.a = 2; data.a; // =\u0026gt; 2 // ……反之亦然 data.a = 3; vm.a; // =\u0026gt; 3 注意：只有当实例被创建时data 中存在的属性才是响应式的，如果再添加一个属性，那么对其改变不会触发试图更新，若想解决此问题，可在起初设置一些属性，初始化为空\ndata: { newTodoText: \u0026#39;\u0026#39;, visitCount: 0, hideCompletedTodos: false, todos: [], error: null } 特殊: 使用 Object.freeze()会阻止修改现有属性，即响应系统无法再追踪变化\nvar obj = { foo: \u0026#34;bar\u0026#34;, }; Object.freeze(obj); new Vue({ el: \u0026#34;#app\u0026#34;, data() { return { obj, }; }, }); \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ obj.foo }}\u0026lt;/p\u0026gt; \u0026lt;!-- 这里的 `obj.foo` 不会更新！ --\u0026gt; \u0026lt;button @click=\u0026#34;obj.foo = \u0026#39;baz\u0026#39;\u0026#34;\u0026gt;Change it\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 除数据属性外，Vue 实例还暴露了一些有用的实例属性和方法，都有前缀$，以便用户定义的属性区分开\nvar data = { a: 1 }; var vm = new Vue({ el: \u0026#34;#example\u0026#34;, data: data, }); vm.$data === data; // =\u0026gt; true vm.$el === document.getElementById(\u0026#34;example\u0026#34;); // =\u0026gt; true // $watch 是一个实例方法 vm.$watch(\u0026#34;a\u0026#34;, function (newValue, oldValue) { // 这个回调将在 `vm.a` 改变后调用 }); 实例生命周期钩子 每个 Vue 实例创建时都将经历一系列初始化过程，例如设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等\n这个过程中也会运行一些叫做的生命周期钩子的函数，给用户在不同阶段添加自己代码的机会\n例如：created 钩子可用来在一个实例创建后执行代码\nnew Vue({ data: { a: 1, }, created: function () { // `this` 指向 vm 实例 console.log(\u0026#34;a is: \u0026#34; + this.a); }, }); // =\u0026gt; \u0026#34;a is: 1\u0026#34; 还有一些钩子，在实例生命周期不同阶段被调用，如 mounted、updated、destroyed\n生命周期钩子的 this 上下文指向调用它的 Vue 实例\n注意！不要在选项属性或回调上使用箭头函数，比如 created: () =\u0026gt; console.log(this.a)或 vm.$watch(\u0026lsquo;a\u0026rsquo;, newValue =\u0026gt; this.myMethod())，因为箭头函数和父级上下文绑定在一起，this 不会是所预期的 Vue 实例，会导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类错误\n生命周期图 参考链接：\nhttps://cn.vuejs.org/v2/guide/instance.html ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-22-vue-basic/","summary":"Vue.js 教程之 Vue 实例\n创建实例 每个 Vue 应用都是通过用Vue函数创建一个新的Vue 实例开始\nvar vm = new Vue({ // options }); 虽然没有遵守MVVM模型，但 Vue 的设计也受 MVVM 启发，故示例中常使用 vm(viewmodel 缩写)表示 Vue 实例\n一个 Vue 应用的组成：\n一个通过 new Vue 创建的根 Vue 实例\n可选的嵌套的、可复用的组件树\n所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象（一些根实例特有的选项除外）\nMVVM MVVM（model-view-viewmodel）是一种软件架构，有助于将图形用户界面开发与业务逻辑或后端逻辑开发分离开来，通过置标语言或 GUI 代码实现\nMVVM 的 viewmodel 是一个值转换器，意味着负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面 viewmodel 比 view 做的更多，且处理大部分视图的显示逻辑。\nviewmodel 可实现中介者模式，组织对 view 所支持的用例集的后端逻辑的访问\n标记语言 置标语言也称标记语言、标志语言、标识语言、markup language，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的计算机文字编码。\n与文本相关的其他信息（文本结构和表示信息等）与原文本结合在一起，但使用标记进行标识\n现状及历史 如今广泛使用的标记语言是 HTML 和 XML，广泛用于网页和网络应用程序，最早用于出版业，是作者、编辑及出版商之间用于描述出版作品的排版格式所使用的\n分类 标记语言通常分为三种：表示性、过程性、描述性\n表示性：编码过程中标记文档的结构信息 例如文本文件中，文件标题可能需要特定格式（居中、放大等），则需要标记文件的标题。","title":"Vue.js技术回顾——实例"},{"content":"初探 Vue.js\n简介 Vue 是一套用于构建用户界面的渐进式框架，与其他大型框架不同在于，Vue 被设计为可以自底向上逐层应用。\nVue 的核心只关注视图层，即 View。不仅易于上手，还便于与第三方库或既有项目整合\n与现代化工具链及各种**支持类库结合使用时，能够为复杂的单页应用**提供驱动\n快速上手 JSFiddle 在线演示\n或按照上例在本地引入 Vue\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 声明式渲染 vue.js 核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统\n解读：vue 是这样一个系统：允许你使用简洁的模板语法来声明式地将数据渲染进DOM\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{ message }} \u0026lt;/div\u0026gt; 这是一个 DOM 结构，div 有唯一标识(id)——app\nvar app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue!\u0026#39; } }) 声明一个 VUE 对象，来给 id 为 app 的这个元素声明式地将\u0026rsquo;Hello Vue!\u0026rsquo;（字符串数据）渲染进其 DOM\n这样就已经创建了一个 Vue 应用，并且数据和DOM建立起关联，所有东西都是响应式的\n测试：在浏览器控制台中修改 app.message 的值，会看到相应更新\n除了上面的文本插值，还可以如下这样绑定元素特性：\n\u0026lt;div id=\u0026#34;app-2\u0026#34;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;message\u0026#34;\u0026gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; var app2 = new Vue({ el: \u0026#34;#app-2\u0026#34;, data: { message: \u0026#34;页面加载于 \u0026#34; + new Date().toLocaleString(), }, }); v-bind称为指令，vue 的指令都以v-为前缀，它们会在渲染的 DOM 上应用特殊的响应式行为\n此处指令 v-bind:title=\u0026ldquo;message\u0026quot;意指“将这个元素节点的 title 属性和 Vue 实例（new Vue()）的 message 属性保持一致”\n同样，在 Vue 中数据和 DOM 存在响应式关联，即修改 app2.message = \u0026lsquo;其他消息\u0026rsquo;会看到绑定了 title 特性的 HTML 发生更新\nThat is really interesting!\n条件与循环 控制一个元素是否显示：\n\u0026lt;div id=\u0026#34;app-3\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;现在你看到我了\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; var app3 = new Vue({ el: \u0026#34;#app-3\u0026#34;, data: { seen: true, }, }); 此外，Vue 还提供强大的过渡效果系统，可以在 Vue插入/更新/移除元素时自动应用过渡效果\n每个 Vue 指令都有特殊的功能，例如 v-for 指令可以绑定数组的数据来渲染一个项目列表\n\u0026lt;div id=\u0026#34;app-4\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; var app4 = new Vue({ el: \u0026#34;#app-4\u0026#34;, data: { todos: [{ text: \u0026#34;元素1\u0026#34; }, { text: \u0026#34;元素2\u0026#34; }, { text: \u0026#34;元素3\u0026#34; }], }, }); 在控制台内向 app4 这个 Vue 实例中的数组再添加一个对象\n处理用户输入 v-on 指令可添加一个事件监听器，通过其调用Vue 实例中定义的方法，可与用户进行交互\n\u0026lt;div id=\u0026#34;app-5\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;button v-on:click=\u0026#34;reverseMessage\u0026#34;\u0026gt;反转消息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; var app5 = new Vue({ el: \u0026#34;#app-5\u0026#34;, data: { message: \u0026#34;Hello Vue!\u0026#34;, }, methods: { reverseMessage: function () { this.message = this.message.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); }, }, }); 注意点：\n选择器是#app-5 而非 app-5\n中英文符号{}\nmethods 而非 method\nVue 还有 v-model 指令用于实现表单输入和应用状态之间的双向绑定\n\u0026lt;div id=\u0026#34;app-6\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;input v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; var app6 = new Vue({ el: \u0026#34;#app-6\u0026#34;, data: { message: \u0026#34;Hello Vue!\u0026#34;, }, }); 该双向绑定对比 Angular 最简示例更加轻便\n组件化应用构建 组件系统是 Vue 另一重要概念（区别于前面过渡系统）\n因为组件系统是一种抽象，允许使用小型（tiny）、**独立（independent）**和可复用（reusable）的组件构建大型应用（类似 React）\n一个组件的本质是一个拥有预定义选项的一个 Vue 实例\n在 Vue 中注册组件：\nVue.component(\u0026#34;todo-item\u0026#34;, { template: \u0026#34;\u0026lt;li\u0026gt;待办项\u0026lt;/li\u0026gt;\u0026#34;, }); 现在可以有用它构建另一个组件模板\n\u0026lt;ol\u0026gt; \u0026lt;todo-item\u0026gt;\u0026lt;/todo-item\u0026gt; \u0026lt;/ol\u0026gt; 但这样为每个待办项渲染同样的文本很差劲\n应能从父作用域将数据传到子组件\nVue.component(\u0026#39;todo-item\u0026#39;, { props: [\u0026#39;todo\u0026#39;]. template: \u0026#39;\u0026lt;li\u0026gt;{{ todo.text }}\u0026lt;/li\u0026gt;\u0026#39; }) 使用 v-bind 指令将待办项传到循环输出的每个组件中\n\u0026lt;div id=\u0026#34;app-7\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;todo-item v-for=\u0026#34;item in groceryList\u0026#34; v-bind:todo=\u0026#34;item\u0026#34; v-bind:key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;todo-item\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; Vue.component(\u0026#34;todo-item\u0026#34;, { props: [\u0026#34;todo\u0026#34;], template: \u0026#34;\u0026lt;li\u0026gt;{{ todo.text }}\u0026lt;/li\u0026gt;\u0026#34;, }); var app7 = new Vue({ el: \u0026#34;#app-7\u0026#34;, data: { groceryList: [ { id: 0, text: \u0026#34;待办1\u0026#34; }, { id: 1, text: \u0026#34;待办2\u0026#34; }, { id: 2, text: \u0026#34;待办3\u0026#34; }, ], }, }); 这就像是在前端使用面向对象思想声明了了类，并实例化一个实例来处理数组\n这个例子将应用分割成两个更小的单元。\n子单元通过 prop 接口与父单元进行了良好的解耦\n可进一步改进组件，提供更为复杂的模板和逻辑，而不影响父单元\n在一个大型应用中有必要将整个应用划分为组件，以使开发更易管理\n如下例展示了使用了组件的应用模板是什么样：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;app-nav\u0026gt;\u0026lt;/app-nav\u0026gt; \u0026lt;app-view\u0026gt; \u0026lt;app-siderbar\u0026gt;\u0026lt;/app-sidebar\u0026gt; \u0026lt;app-content\u0026gt;\u0026lt;/app-content\u0026gt; \u0026lt;/app-view\u0026gt; \u0026lt;/div\u0026gt; 与自定义元素的关系 Vue 的组件非常类似于自定义元素——它是 Web 组件规范的一部分，因为 Vue 的组件语法部分参考了该规范，如 Vue 组件实现了Slot API与 is 特性\n但是，有几个关键差别：\nWeb 组件规范仍处于草案阶段，并未被所有浏览器原生实现。而 Vue 组件不需要任何 polyfill，且在所有支持的浏览器（IE9 及以上）中表现一致。必要时 Vue 组件也可包装于原生自定义元素之内\nVue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信和构建工具集成\n参考链接：\nhttps://cn.vuejs.org/v2/guide/ ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-22-vue-basic-01/","summary":"\u003cp\u003e初探 Vue.js\u003c/p\u003e","title":"Vue.js技术回顾——概述"},{"content":"关于 HTML5 中语义方面的改变\n使用 HTML 的 section 和 outline 重要点：现在不再有在图形浏览器或辅助技术用户代理的已知的提纲算法，虽然这个算法在其他软件，比如一致性检验器中被实现。所以提纲算法不能再被依赖于传递文档结构给用户。作者被建议去使用标题头秩(h1-h6)去传递文档结构\nHTML5 特征带来了许多新元素给 web 开发者，允许他们去描述一个 web 文档的结构以一种标准的语义。这个文档描述了这些元素和如何使用它们去定义所想要的任何文档内容的轮廓。\nHTML4 中的文档结构 一个文档的结构，比如，\u0026lt;body\u0026gt;和\u0026lt;/body\u0026gt;之间的语义结构，是呈现网页给用户的最基本。HTML4 使用一个文档的部分概念（notion of section）和子部分来描述它的结构。一个部分被一个\u0026lt;div\u0026gt;元素定义，伴随着其内的标题元素（\u0026lt;h1\u0026gt;,\u0026lt;h2\u0026gt;,\u0026lt;h3\u0026gt;,\u0026lt;h4\u0026gt;,\u0026lt;h5\u0026gt;或者\u0026lt;h6\u0026gt;）定义了它的标题。这些元素的关系引领了文档的结构和它的轮廓\n所以如下的标记：\n\u0026lt;div class=\u0026#34;section\u0026#34; id=\u0026#34;forest-elephants\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Forest elephants\u0026lt;h1\u0026gt; \u0026lt;p\u0026gt;In this section, we discuss the lesser known forest elephants. ...this section continues... \u0026lt;div class=\u0026#34;subsection\u0026#34; id=\u0026#34;forest-habitat\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Habitat\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Forest elephants do not live in trees but among them. ...this subsection continues... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 引导如下的轮廓：（不含隐式等级号展示）\n1. Forest elephants 1.1 Habitat 并非一定需要\u0026lt;div\u0026gt;元素去定义一个新的部分块。仅需存在一个标题元素就足以意味着一个新的部分块。所以：\n\u0026lt;h1\u0026gt;Forest elephants\u0026lt;h1\u0026gt; \u0026lt;p\u0026gt;In this section, we discuss the lesser known forest elephants. ...this section continues... \u0026lt;h2\u0026gt;Habitat\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Forest elephants do not live in trees but among them. ...this subsection continues... \u0026lt;h2\u0026gt;Diet\u0026lt;/h2\u0026gt; \u0026lt;h1\u0026gt;Mongolian gerbils\u0026lt;/h1\u0026gt; 引领出如下的轮廓：\n1. Forest elephants 1.1 Habitat 1.2 Diet 2. Mongolian gerbils HTML5 所解决的问题 HTML4 定义了文档的结构与其暗示轮廓算法非常粗糙并带来了大量的问题：\n对于定义语义块的\u0026lt;div\u0026gt;用法，未给 class 参数定义特定的值使轮廓算法自动化变得不可能（那个\u0026lt;div\u0026gt;部分究竟是页的轮廓，定义了一个块还是一个块？或是它只是呈现了一个\u0026lt;div\u0026gt;，仅用来编辑样式）。在其他方面，HTML4 规格在什么是一个部分块和它的域是如何定义上非常不准确。轮廓的自动生成是重要的，尤其对于辅助技术，可能会适应这种根据文档结构呈现信息给用户的方式。HTML5 移除了来自轮廓算法的\u0026lt;div\u0026gt;元素的需要，通过引入一个新的元素\u0026lt;section\u0026gt;。HTML Section Element\n合并多个文档是困难的：包含一个子文档进一个主文档意味着改变 HTML 头元素的等级，所以轮廓会保持。这在 HTML5 中被解决，以其新介绍的块元素(\u0026lt;article\u0026gt;,\u0026lt;section\u0026gt;,\u0026lt;nav\u0026gt;和\u0026lt;aside\u0026gt;)，总会是其相邻最近祖先块的子块，不管通过内部的头元素定义了什么块\n在 HTML4 中，每一个块都是文档轮廓的一部分。但文档通常不是那么线性。一个文档可以有特殊的部分，包含着不属于其一部分的信息，虽然和主线关联，比如一个广告块或者一个解释说明盒子。HTML5 介绍了\u0026lt;aside\u0026gt;元素允许这样的块元素不成为主轮廓的部分\n再一次的，在 HTML4 中，因为每一个部分都是文档轮廓的一部分，没可能会有块包含与文档无关的信息，除了对于整个站点的元素，比如图标、菜单、内容表格或是版权信息和合法通知。为了这个目的，HTML5 引入了三个新元素：\u0026lt;nav\u0026gt;用来表示链接集合，比如一个内容表格，\u0026lt;footer\u0026gt;和\u0026lt;header\u0026gt;用来表示站点相关信息。注意\u0026lt;header\u0026gt;和\u0026lt;footer\u0026gt;不是像\u0026lt;section\u0026gt;一样在为内容划分块，而是它们存在用来语义地标记块的部分（头部分和尾部分）\n更通常的，HTML5 带来了块和头部的预测特征，允许文档轮廓被预测，并被浏览器用来提高用户体验\nHTML5 轮廓算法 让我们考虑下潜藏在 HTML 处理部分和轮廓的方式下的算法\n定义部分 所有的内容都躺在\u0026lt;body\u0026gt;元素中的内容都是一个块部分。HTML5 中的块可以嵌套。除了主块，被\u0026lt;body\u0026gt;所定义的元素，块限定被定义地或明确或含蓄。明确定义的块部分是\u0026lt;body\u0026gt;,\u0026lt;section\u0026gt;,\u0026lt;article\u0026gt;,\u0026lt;aside\u0026gt;和\u0026lt;nav\u0026gt;标签内的内容\n每个部分可以有其自己的头层级。所以，甚至一个嵌套的部分也可以有一个\u0026lt;h1\u0026gt;，见后续实例\n让我们看一个例子——这里我们有一个拥有一个顶层部分和一个尾部定义的文档。在顶级部分我们有三个子块，以两个\u0026lt;section\u0026gt;和一个\u0026lt;aside\u0026gt;元素定义：\n\u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Forest elephants\u0026lt;/h1\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Introduction\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;In this section, we discuss the lesser known forest elephants.\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Habitat\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Forest elephants do not live in trees but among them.\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;aside\u0026gt; \u0026lt;p\u0026gt;advertising block\u0026lt;/p\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;(c) 2010 The Example company\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; 这导致了如下的轮廓：\n1. Forest elephants 1.1 Introduction 1.2 Habitat ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-16-html5-sementical/","summary":"\u003cp\u003e关于 HTML5 中语义方面的改变\u003c/p\u003e","title":"HTML5语义提升篇"},{"content":"HTML5 作为如今前端必备“新”技术，理应成为前端基础的必备技能之一\n背景 HTML5 是 HTML 的最新标准定义。这个术语展示了两个概念。它是 HTML 语言的最新版本，拥有着新的元素、参数和行为，还有一个大的集合，使得可以构建更加多样化和强大的 Web 网站和应用。这个集合有时候称作 HTML5\u0026amp;friends，常简写为 HTML5。\n语义上：允许描述你的内容更加精确\n连通性上：允许你和服务端的交流以革新的方式\n离线和存储：允许网页在本地客户端存储数据并更加高效地离线操作\n多媒体：使视频和音频在 Web 世界成为第一公民\n2D/3D 图形和效果：允许更加多样化范围的呈现选项\n性能和集成：提供更快的优化和更好的计算机硬件用法\n设备访问：允许多种输入输出设备的用法\n样式：让用户写更加复杂的主题\n提纲 语义 连通性 离线和存储 多媒体 3D 图形和效果 性能和集成 设备访问 样式 语义 使用 HTML5 音频和视频 表格提升 新的语义元素 iframe 提高 MathML 连通性 Web Sockets 服务端发送事件 WebRTC 离线和存储 离线资源：应用缓存 在线和离线事件 WHATWG 客户端会话和持久化存储（aka DOM 存储） IndexedDB 从 web 应用使用文件 多媒体 使用 HTML5 音频和视频 WebRTC 使用相机 API Track 和 WebVTT 3D 图形和效果 Canvas 用于 canvas 元素的 HTML5 文本 API WebGL SVG 性能和集成 Web Workers XMLHttpRequest 等级 2 即时编译 javascript 引擎 历史 API 可编辑内容的参数：将你的网站转变成 wiki 拖放 HTML 中的聚焦管理 基于 Web 协议的处理器 requestAnimationFrame 全屏 API 指针锁 API 线上和离线事件 事件访问 使用相机 API 触摸事件 使用地图定位 检测设备方向 指针锁 API 样式 CSS 企图渲染元素以一种更加复杂的方式。这通常指的是 CSS3，尽管 CSS 不再是一个单一的规范并且不同的模块不是都在 CSS3：有一些在 CSS1 和 CSS4，伴随着所有的中间水平。\n新的背景样式特征 更多奇特的边框 动画样式 排版提高 新的呈现布局 参考链接：\nhttps://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-16-html-basic/","summary":"\u003cp\u003eHTML5 作为如今前端必备“新”技术，理应成为前端基础的必备技能之一\u003c/p\u003e","title":"HTML5基础回顾"},{"content":"25 个最基本的 javascript 问题整理\n使用 typeof bar === \u0026ldquo;object\u0026quot;判定 bar 是否是对象的潜在陷阱是什么？如何避免该陷阱？ 虽然 typeof bar === \u0026ldquo;object\u0026quot;是检查 bar 是否为对象的可靠方法，但是 javascript 中null也被认为是对象\n要注意类似以下的 typeof 使用场景\nvar bar2; typeof bar2; (\u0026#34;undefined\u0026#34;); typeof undefined; (\u0026#34;undefined\u0026#34;); typeof \u0026#34;undefined\u0026#34;; (\u0026#34;string\u0026#34;); typeof null; (\u0026#34;object\u0026#34;); 要避免此类问题，可以同时检查 bar 是否为 null，如下：\nvar bar = null; console.log((bar !== null) \u0026amp;\u0026amp; (typeof bar === \u0026#34;object\u0026#34;)); VM489:2 false 当 bar 为函数时，大多数情况上述值返回 false 是期望行为（因为函数不同于对象），但如果想要对函数返回 true 的话，可以修改为：\nfunction bar() {}; console.log((typeof bar !== null) \u0026amp;\u0026amp; (typeof bar === \u0026#34;object\u0026#34;) || (typeof bar === \u0026#34;function\u0026#34;)); VM757:2 true 当 bar 为一个数组时，返回值为 true 为期望行为（因为数组也是对象）\nvar bar = []; console.log((typeof bar !== null) \u0026amp;\u0026amp; (typeof bar === \u0026#34;object\u0026#34;) || (typeof bar === \u0026#34;function\u0026#34;)); VM926:2 true 但如果想让数组返回 false，可修改为：\nvar bar = []; console.log((typeof bar !== null) \u0026amp;\u0026amp; (typeof bar === \u0026#34;object\u0026#34;) \u0026amp;\u0026amp; (toString.call(bar) !== \u0026#34;[object Array]\u0026#34;)); VM1133:2 false 如果使用 jQuery 可为：\nvar bar = []; console.log((typeof bar !== null) \u0026amp;\u0026amp; (typeof bar === \u0026#34;object\u0026#34;) \u0026amp;\u0026amp; (! $.isArray(bar))); 拓展：call 方法\n以下输出什么？为什么？ (function () { var a = (b = 3); })(); console.log(\u0026#34;a defined? \u0026#34; + (typeof a !== \u0026#34;undefined\u0026#34;)); console.log(\u0026#34;b defined? \u0026#34; + (typeof b !== \u0026#34;undefined\u0026#34;)); 由于 a 和 b 都定义在函数的封闭范围内，并且都始于 var 关键字，大多数情况期望上面结果都是 undefined，大多数情况上述的 var a = b = 3；等同于 var b = 3; var a = b；但实际上是 b = 3; var a = b；所以如果不使用严格模式，会输出如下：\n(function() { var a = b = 3; })(); console.log(\u0026#34;a defined? \u0026#34; + (typeof a !== \u0026#39;undefined\u0026#39;)); console.log(\u0026#34;b defined? \u0026#34; + (typeof b !== \u0026#39;undefined\u0026#39;)); VM1296:6 a defined? false VM1296:7 b defined? true 因为 var a = b = 3;相当于 b = 3; var a = b，b 没有使用 var 声明，所以变成全局变量\n以下输出什么？为什么 var myObject = { foo: \u0026#34;bar\u0026#34;, func: function () { var self = this; console.log(\u0026#34;outer func: this.foo = \u0026#34; + this.foo); console.log(\u0026#34;outer func: self.foo = \u0026#34; + self.foo); (function () { console.log(\u0026#34;inner func: this.foo = \u0026#34; + this.foo); console.log(\u0026#34;inner func: self.foo = \u0026#34; + self.foo); })(); }, }; myObject.func(); outer func: this.foo = bar VM1353:6 outer func: self.foo = bar VM1353:8 inner func: this.foo = undefined VM1353:9 inner func: self.foo = bar 在外部函数中，this 和 self 都指向了 myObject，所以两者都能正确地引用和访问 foo；内部函数中，this 不再指向 myObject，所以此时 this.foo 未在内部函数中定义，相反指向到本地的变量 self 保持在范围内，且可以访问（ES5 以前，内部函数中的 this 将指向全局的window对象，ES5内部函数中的this是未定义的）\n封装 javascript 源文件的全部内容到一个函数块有什么意义及理由？ 这是越来越普遍的做法，被许多流行 js 库所采用（例如 jQuery、Node.js）。这种技术创建了一个围绕文件全部内容的闭包，并且很重要的是创建了一个私有的命名空间，从而避免不同 javascript 模块和库之间潜在的名称冲突。\n这种技术的另一个特点是允许一个易于引用的别名用于全局变量\n例如 jQuery 插件中允许使用 jQuery.noConflict()来禁用$引用到jQuery命名空间，在此之后仍可使用$利用这种闭包技术，如下：\n(function ($) { /* jQuery plugin code referencing $ */ })(jQuery); javascript 源文件开头包含 use strict 有什么意义和好处？ 严格模式的一些优点：\n使调试更加容易——那些被忽略或默默失败的代码错误会产生错误或抛出异常\n防止意外的全局变量——非严格模式下将值分配一个未声明的变量会自动创建该名称的全局变量，但严格模式下会报错\n消除 this 强制——非严格模式下，引用null或未定义的值到this 值会自动强制到全局变量\n不允许重复的属性名称或参数值——当检测到对象中重复命名属性（var object = {foo: \u0026lsquo;bar\u0026rsquo;, foo: \u0026lsquo;baz\u0026rsquo;};）或函数中重复命名参数（function foo(val1, val2, val1) {}）会报错，因此可捕获代码中的 bug 以避免大量的跟踪时间\n使用 eval()更安全——严格模式下，变量和声明在 eval()语句内部的函数不会在包含范围内创建，而会在非严格模式下创建\n在 delete 使用无效时报错——delete 不能用在对象不可配置的属性上，非严格模式时会静默失败，严格模式下会报错\n以下两个函数会返回相同的东西吗？为什么相同或不同？ function foo1() { return { bar: \u0026#34;hello\u0026#34;, }; } function foo2() { return; { bar: \u0026#34;hello\u0026#34;; } } function foo1() { return { bar: \u0026#34;hello\u0026#34; }; } console.log(foo1()); VM1405:5 {bar: \u0026#34;hello\u0026#34;} undefined function foo2() { return { bar: \u0026#34;hello\u0026#34; }; } console.log(foo2()); VM1441:6 undefined 原因在于 javascript 中的分号是一个可选项，但省略其将会是非常糟糕的形式。当碰到 foo2()中包含 return 语句的代码行（代码行上没有任何代码），分号会立即自动插入到返回语句后。但不会报错，因为后面的代码是有效的，相当于是一个未使用的代码块，定义了等同于字符串\u0026quot;hello\u0026quot;的属性 bar\nNaN 是什么？它的类型是什么？如何可靠地测试一个值是否等于 NaN？ NaN 表示一个“不是数字”的值，因为运算不能执行而得。运算不能执行的原因有：其中的运算对象之一不是数字或运算结果不是数字。\n虽然 NaN 表示“不是数字”，但是其类型是 Number\ntypeof NaN; (\u0026#34;number\u0026#34;); NaN 和任何东西（包括其自身）都是 false\nNaN == NaN; false; NaN === NaN; false; NaN === \u0026#34;hello\u0026#34;; false; NaN == \u0026#34;hello\u0026#34;; false; 一种比较好的测试一个数字是否等于 NaN 的方式是使用内建函数 isNaN()，但不是最好的方案\n更好的解决方案是使用 value !== value\n4 !== 4; false; 4 !== \u0026#34;4\u0026#34;; true; 但如果 value 就是 NaN，那么仍然遵守“NaN 和任何东西比较都是 false”\n1 / \u0026#34;s\u0026#34; !== 1 / \u0026#34;s\u0026#34;; true; ES6 提供一个新的 Number.isNaN()函数，比 isNaN()更可靠\n下列输出什么？为什么？ console.log(0.1 + 0.2); console.log(0.1 + 0.2 == 0.3); console.log(0.1 + 0.2); console.log(0.1 + 0.2 == 0.3); VM1624:1 0.30000000000000004 VM1624:2 false JavaScript 中的数字和浮点精度的处理相同，因此可能不会总是产生预期的结果\n讨论写函数 isInteger(x)的可能方法，用于确定 x 是否是整数 ES6 中提供了解决方案：Number.isInteger()\n但 ES 规格说明中，整数只是概念上存在，即：数字值总是存储为浮点值\nES6 之前的做法：\nfunction isInteger(x) { return (x ^ 0) === x; } ^为位运算符中的 XOR 异或运算，二者（二进制形式）不同则为真，二者相同则为假，任何值和 0 求异或都是其本身，但浮点数例外，浮点数只会求其整数部分\n0 ^ 0; 0; 12 ^ 0; 12; 0 ^ 12; 12; 1.1 ^ 0; 1; 1.5 ^ 0; 1; 1.9 ^ 0; 1; 这种方式可以当输入非数字值，例如 null 或字符串时稳健地返回 false\n或者没有上面方法优雅的方案：\nfunction isInteger(x) { return Math.round(x) === x; } Math.round()为四舍五入，相当于 Math.ceil()进一法，Math.floor()退一法的集合\nMath.round(3.2); 3; Math.round(3.5); 4; Math.round(3.9); 4; Math.ceil(3.2); 4; Math.floor(3.9); 3; 或者\nfunction isInteger(x) { return typeof x === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; x % 1 === 0; } 是数字的同时模 1 为 0\n3 % 1; 0; 3.1 % 1; 0.10000000000000009; NaN % 1; NaN; 不正确的一个方案是：\nfunction isInteger(x) { return parseInt(x, 10) === x; } 这种方案在大多数情况不暴露问题，但当 x 相当大的时候无法正常工作，因为 parseInt 在解析数字之前强制其第一个参数到字符串，所以当数字十分大时，其字符串表达形式为指数形式（1e+21），此时 parseInt 去解析 1e+21，当达到 e 时则停止，会只返回 1\nString(10000000000000000000000000); parseInt(10000000000000000000000000); 1; ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-15-js-exercise/","summary":"\u003cp\u003e25 个最基本的 javascript 问题整理\u003c/p\u003e","title":"javascript常见问题整理"},{"content":"关于一次莫名失眠的研究和总结\n睡眠障碍分类 失眠——该睡的时候睡不着\n嗜睡——该醒的时候非要睡\n梦游——睡着了还到处溜达\n日夜颠倒——白天睡觉晚上嗨\n失眠属于睡眠障碍的一种\n失眠人口现状 10%-30%\n医学定义 失眠就是睡眠启动和维持障碍，导致睡眠质量不能满足个体需要，并影响日常社会功能的一种状况。\n关键词 睡眠启动：进入睡眠状态 睡眠维持：持续多久不醒 睡眠质量：睡醒后感受如何 不能满足个体需求：睡眠时间和质量都不足 影响日间社会功能：正常生活受影响 失眠影响 记忆力差 免疫力降低 性功能减退 长期失眠可能导致焦虑、抑郁 糖尿病、高血压、冠心病等心血管、代谢类疾病 严重可能致中风、猝死 睡眠解析 睡眠过程 睡眠启动：一般 30 分钟完成\n浅睡眠——脑电波不活跃、眼动少——非快动眼睡眠，持续 80-120 分钟——体力恢复阶段\n深睡眠——大脑活跃、眼睛时不时出现快速转动——快动眼睡眠，持续 5-30 分钟——精力恢复阶段\n上述二者共 2 小时左右，整个晚上重复 3-5 个周期\n睡眠组成 8 小时组成：6 小时非快动眼睡眠+2 小时快动眼睡眠\n若快动眼睡眠质量差，则影响精力恢复\n什么偷走了睡眠 生物钟紊乱\n从古至今，日出而作，日落而息的规律被写进基因，就是生物钟\n表现 到吃饭时间会饿 到睡眠时间会困 到起床时间会醒 生物钟对睡眠影响的核心——褪黑素 褪黑素由大脑中松果体分泌，当褪黑素增多，人会变困睡觉；该起床时，生物钟提前通知松果体减少褪黑素的分泌，褪黑素减少，人会醒来。\n如果人在夜晚该睡觉的时候做其他事，就会打破生物钟，长此以往，就会导致生物钟紊乱\n生物钟紊乱表现 长痘 口腔溃疡 上火 大脑皮层过度兴奋 大脑启动睡眠，先是进入脑电波不活跃的浅睡期，所以大脑皮层的过度兴奋会导致进入睡眠受影响\n腺苷作用被阻断 细胞代谢、人体运动都需要能量\n细胞相当于汽车，进入细胞的糖相当于原油\n汽车需要提纯后的汽油，细胞需要糖分解后的 ATP\n汽油燃烧后产生排放物，ATP 利用后的产物为腺苷，腺苷可以被再次利用合成 ATP\n腺苷对睡眠的影响 腺苷在人体堆积越多，人越想睡觉\n实例：白天运动多、体力活多，腺苷堆积多，晚上容易睡眠\n特殊影响 咖啡、茶等含有咖啡因的东西能阻断腺苷催眠的作用，使腺苷对睡眠失去意义\n导致失眠因素 疾病因素：感冒、发炎导致身体不适 精神因素：挫折、压力、恐惧、无奈、焦虑、愤怒、忧伤等情绪导致大脑皮层活跃 不良生活习惯：咖啡因、太饱、太饿、肠胃不适、刺激性活动 环境因素：环境嘈杂、房间拥挤、光线过强、床不适、温度不适 失眠治疗 医学定义的失眠：\n每次入睡超过半小时，晚上醒来不止一次，醒后超过 30 分钟不能接着睡、多梦 白天头晕没力气，疲劳想睡觉、注意力不集中、工作能力下降 每周失眠 3 次以上，至少持续一个月 若都符合则需求助医疗治疗\n治疗手段 药物治疗\n安眠药 褪黑素 非药物治疗\n刺激控制疗法：建立睡觉和床的关联性\n只在有睡意时上床 不在床上做与睡觉无关的东西 无论睡眠如何，固定时间起床 松弛疗法：放松身心，缓解焦虑、紧张等不良因素\n练气功 做瑜伽 听舒缓音乐 芳香疗法：\n茉莉花 薰衣草 迷迭香 香薰灯、香薰炉、香薰包、薰衣草枕头 食疗法：\n莲子 百合 红枣 桂圆 中医：养心安神\n中药调理 针灸 推拿 穴位贴敷 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-14-insomnia/","summary":"\u003cp\u003e关于一次莫名失眠的研究和总结\u003c/p\u003e","title":"记一次失眠"},{"content":"前一段时间换域名，发现博客的访问次数不显示了。一开始没时间关注，最近闲了，研究一下到底是怎么回事，发现原来当初这里不是基于本地配置，而是使用 leancloud 进行统计，查阅到一篇很易懂的教程，顺便整理了一下 PV 和 UV 的统计\n核心原理 hexo 很多配置基于配置文件和第三方插件，而配置文件的格式又是类似大多数模板语言的格式，比如 javaweb 中的 jsp 标签，还有 basic 中的 if 和 endif，仔细研究其中的一些配置，其实都可以很好的定制化和 hackable\n参考链接 http://www.jeyzhang.com/hexo-next-add-post-views.html\nhttps://leancloud.cn/\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-13-hexo-reading-count/","summary":"\u003cp\u003e前一段时间换域名，发现博客的访问次数不显示了。一开始没时间关注，最近闲了，研究一下到底是怎么回事，发现原来当初这里不是基于本地配置，而是使用 leancloud 进行统计，查阅到一篇很易懂的教程，顺便整理了一下 PV 和 UV 的统计\u003c/p\u003e","title":"关于hexo阅读次数统计及访问次数插件使用"},{"content":"关于微信公众号平台使用相关\n公众号分类 个人（订阅号） 企业（服务号） 前期准备 服务器域名备案 官网推荐腾讯云服务器 开发者限少于等于 15 人 流程参考 https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html\n技术准备 html css javascript python json api ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-13-wechat-miniprogram/","summary":"\u003cp\u003e关于微信公众号平台使用相关\u003c/p\u003e","title":"微信公众号和小程序开发"},{"content":"探析 javascript 中的严格模式\n背景 出现于 ES5\n消除 js 语言一些不合理、不严谨的地方，减少一些怪异行为 消除代码运行不安全之处 提高编译效率，提高运行速度 未新版本 js 做铺垫 本质 第二种运行模式：严格模式\n严格模式 转换严格模式 ES5 中引入了严格模式，现已被所有的主流浏览器实现（包括 IE10）\n如果想要浏览器按照严格模式解释代码只需要在代码前（代码顶部）加上‘use strict’\n如果想将已存在的代码转换为严格模式需要多做一点工作\n逐步转换 严格模式被设计来可以逐步转换，可以独立地改变每一个文件，甚至可以逐步地将函数转换为严格模式\n对比严格模式和非严格模式 实例：\n如下代码在添加了‘use strict’后抛出语言错误\n八进制语法：var n = 023;\nwith 语句\n在变量名中使用 delete：delete myVariable;\n使用 eval 或者 arguments 作为变量或者函数的参数名\n使用新版本的保留字：implements、interface、let、package、private、protected、public、static 和 yield\n在块级域内声明函数：if (a \u0026lt; b) { function f() {} }\n明显的错误：\n在一个对象字内对一个属性声明两次相同的名称：{a: 1. b: 3. a: 7}，这已经不再是 ES2015 中的情况（bug） 使用相同的名称声明两个函数参数：function f(a, b, b) {} 这些错误还算好，因为它们能够明显地暴露出错误或者糟糕的实践，它们会在代码运行前发生\n新的运行时错误 javascript 过去常在代码发生错误的地方静默地运行失败，严格模式会在这种情况抛出异常。如果你的代码包含这种情况，测试会变得很有必要以确保没有东西坏掉。然而再一次，会在函数粒度级别再一次发生\n实例：给一个未定义的变量赋值\nfunction f(x) { var a = 12; b = a + x * 35; } f(42); undefined function f(x) { \u0026#39;use strict\u0026#39;; var a = 12; b = a + x * 35;\t// 报错 } f(42); 这可能会改变一个全局对象的值，这常常并不是所期望的。如果真的想给一个全局对象设置值，将其作为参数传给它并明确地将其声明为一个属性\nfunction f(x) { \u0026#34;use strict\u0026#34;; var a = 12; b = a + x * 35; } f(42); 实例：尝试删除一个非可配置属性\n这种操作会在非严格模式静默地失败，与用户所期望所违背\ndelete Object.prototype; false \u0026#39;use strict\u0026#39;; delete Object.prototype; VM361:2 Uncaught TypeError: Cannot delete property \u0026#39;prototype\u0026#39; of function Object() { [native code] } at \u0026lt;anonymous\u0026gt;:2:1 实例：有毒害的参数和函数属性\n访问 arguments.callee、arguments.caller、anyFunction.caller 或者 anyFunction.arguments 都会在严格模式中抛出异常错误\n唯一合法的用例会是重用一个函数如下：\nvar s = document.getElementById(\u0026#34;thing\u0026#34;).style; s.opacity = 1; (function () { if ((s.opacity -= 0.1) \u0026lt; 0) s.display = \u0026#34;none\u0026#34;; else setTimeout(arguments.callee, 40); })(); 上述实例见http://vanilla-js.com/\n如果在严格模式中，可以将上述函数重写为如下：\n\u0026#34;use strict\u0026#34;; var s = document.getElementById(\u0026#34;thing\u0026#34;).style; s.opacity = 1; (function fadeOut() { // name the function if ((s.opacity -= 0.1) \u0026lt; 0) s.display = \u0026#34;none\u0026#34;; else setTimeout(fadeOut, 40); // use the name of the function })(); 语义上的不同 这些都是很微妙的不同，可能测试用例不会捕获这种微妙的不同。仔细回看你的代码可能显得必要以确保这些不同不会影响你代码的语义。幸运的是，这种仔细的回看可以变成逐步地应用于函数粒度级别的回看\n函数调用中的 this 在函数调用中，例如 f()，this 值是全局对象。在严格模式中，现在是 undefined。\n当一个函数被使用 call 或者 apply 调用时，如果值是原始值，这个值会被装配进一个对象（或者对于 undefined 或者 null 的对象）。\n在严格模式中，这个值会被直接传递而不被转换或替换。\narguments 没有被函数参数命名别名 在非严格模式中，修改 arguments 对象中的一个值会修改相应的命名参数\n这使得对于 javascript 引擎的优化变得复杂，同时令代码更难阅读或理解\n在严格模式中，arguments 对象被创建并被初始化为同名值而非命名参数，但是对于 arguments 对象或是命名参数的改变不会彼此影响\n更改为 eval 在严格模式中，eval 不会在它被调用的域内创建一个新的变量。当然，在严格模式中，字符串也会被按照严格模式的规则进行评估\n测试需要被彻底地执行以确保一切正常（nothing breaks）\n不要使用 eval，除非你真的需要它，这会是一个更务实的解决方案\n严格中立（strictness-neutral）代码 移动严格代码到严格模式的一个潜在的弊端是可能在那些没有实现严格模式的传统浏览器中语义上存在不同\n在某些稀有场合（比如糟糕的联结或者缩小），你的代码也可能不能运行在你编写和测试的模式中，以下一些规则可以使得你的代码变得严格中立：\n以严格模式书写代码并确保没有在严格模式下会抛出的错误\n原理语义不同\neval：只有在你明白你在做什么的情况下使用它 arguments：永远通过名称访问函数的参数或执行一份参数对象的拷贝，比如如下，将这样的声明添加在你函数的第一行 var args = Array.prototype.slice.call(arguments) this：仅在涉及到你创建的对象时使用 this 参考链接：\nhttp://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-12-js-use-strict/","summary":"\u003cp\u003e探析 javascript 中的严格模式\u003c/p\u003e","title":"关于javascript的严格模式（use strict）"},{"content":"关于 2017 年个人博客点滴的年终总结\n提纲 以下按掌握顺序倒叙整理（即博客浏览顺序），也是博客内容的一个大致归类\nReact node\u0026amp;npm javascript 浏览器缓存 mysql 网络基础 maven linux 虚拟机 tensorflow 设计模式 区块链 webpack API markdown git 负载均衡\u0026amp;反向代理 java python es6 以上条目一眼望去有些多，也显得很杂。整体上学习轨迹从后端向前端转移，知识虽杂，但定位于“宽度优先”的学习计划，其实“面儿宽”其实是为了能够对于整个计算机行业技术栈融会贯通，相互影响，以窥全貌。\n接下来将逐一按照上述提纲盘点 2017 年的 58 篇博客总结\n详述 React 对于 React 的学习介于前端方面的需求，React 目前是前端主流框架之一，因其“小模块组成大应用”的思想，广为大多数公司使用，成为前端开发的必备技能之一。\n关于 React 的学习共整理两篇——安装篇和快速上手篇，源于学习 React 官网时的学习总结（基本上是对 React 官方教程做了一遍个人翻译），初步掌握 React 主要思想和上手方法，后续将尝试使用 React 进行项目实际开发，并学习另外主流前端框架以做对比，比如 Vue、Angular 等。\nnode\u0026amp;npm npm 相比 node 只能算的上工具，而非技术，但如今介于软件工程的“复用”思想和实际生产的快速迭代要求，“用轮子”的思想是职场必备技能，技术固然可以深入研究，但生产最关注的是产出，在这样的背景下，npm 这样的“大社区”为众多前端开发者提供了便利而有力（powerful）的帮助。\n讲到 node，便会提到“全栈”这样的字眼，node 的诞生意味着 javascript 这样的脚本语言可以挑战“沉重”的 java 而成为 web 开发主要语言成为可能。然而 Node 的威力却不仅仅如此，关于 node 生态的学习才刚刚开始，而它的出现及魅力竟足以让我学习 java 转而投奔 node 大家族的怀抱。\njavascript 这是一门易懂难精的语言，也是一门未来的语言（因为 Node 的出现），在学习的过程中，一句 MDN 的话印象很深刻“它是一门松散的语言，同时也因为其松散而长期被认为是上不了台面的语言，但如今它却有可能因为其松散的特性而变得十分强大”。尤其是伴随着 2015 发布的 ES6 的出现，其实是对 javascript 的“松散”打了“补丁”，简单来说，就是曾经的 js 的确有很多方面的缺陷而很难成为值得人信赖的 web 开发语言，但是 ES 出现的块级域、类概念使得其仅有的缺点从此结束，继而变得优秀。\n浏览器缓存 缓存技术是前端性能中的关键技术点，软件的实现是第一步，而从软件使用体验的角度，“性能问题”不可忽视，尤其是如今网络应用的访问流量越来越大，高并发的场景随处可见（微博被鹿晗搞炸）。所以相比十年前，五年前的 web 仅仅需要完成内容展示即可，如今的 web 更强调“用户体验”。\nmysql 这是后端技术栈的核心部分，不过前端也需要懂些数据库知识，因为毕竟内容的展示依赖数据的流转，而且如今的 chrome 浏览器也会有 websql、localstorage 这样的技术存在，所以互联网行业内几乎没有什么可以单独讨论而与其他技术无关联的技术。\n网络基础 网络传输相当于 web 的“硬件”载体，因为 web 只是软件，说白了就是指令集合，而 web 被人们所使用，总要基于网络的传输，无论是通过浏览器还是本地客户端，如果没有网络知识的 web 应用就像是一个没有血肉的骨架\nmaven 这可以算是纯后端的技术，maven 相当于前端中的 NPM，之所以写 maven 相关的总结，是因为工作需要。工作中要对父子工程进行重构，涉及到父子工程的包依赖问题，遂整理此文以对其原理有更深入的理解，从而不止是简单地做一枚“搬运工”。\nlinux 这个技术算不上前端，也算不上后端，因为它是系统级的技术，作为一名开发工作者，相比离不开与服务器打交道，从而对于 linux 的学习以不至于面对服务器操作时显得手忙脚乱，因为长期的 Windows 用户级系统的使用。\n虚拟机 对于虚拟机的折腾主要是为了在本地搭建 linux 环境及熟悉 MacOS 的使用，都算是工具级别的学习，没什么含量。\ntensorflow 2017 年是人工智能火热的一年，作为技术爱好者，难以仅拘泥于工作所用技术，本着天下技术是一家的想法，新东西也想摸摸，指不定就是未来的主流，对于新技术保持敏锐的嗅觉，总比永远比时代慢一拍要强。\n设计模式 这个东西我原本认为属于后端技术栈，但学习以后（阅读《大话设计模式》一书），觉得设计模式其实就是生活，就是生活中总结出的规律，以避免做重复的事情或是低效的事情。设计模式就是编程中的模板，俗话讲的“套路”，编程诞生这么多年，如此之多的优秀 coder 写了无数代码后整理出的一套经久可用的“代码块”，或说代码结构，对于提高编程效率和编程思想有着很大的帮助。\n区块链 和 tensorflow 一样，这也算是一门很潮的“骚”技术，为了不食剩食，永远不被新技术碾压，学习技术之余，对于这门可能改变未来的技术也有所涉猎，翻译了一篇国外关于区块链研究很早（2011 年），但今天开来仍旧参考价值相当之大的文章，目前翻译尚未完成，应该完成了近 2/5 的进度。\nwebpack 这同样是一项工具技术，相当于后端中的 jar，或者 Jenkins，我不知道该如何准确地形容它，总之它是一个打包器，但是为什么需要打包器，因为随着前端技术的发展，前端代码的规模量也变得不少于后端代码，而数量大，就需要软件工程式的科学化的整理方式，而将不同的代码块按照特定分类，打成不同的包，即一个个模块，这样一来，整个前端方面的代码的可维护性和可复用性便会得到质的飞跃。\nAPI 这是前端和后端的枢纽，优秀的 API 设计需要丰富的软件整体性思想和远见，良好的 API 设计可以使得后续开发变得高效可控，所以 API 设计其实是合理的软件开发的第一步。\nmarkdown 这门标记语言，其实也称不上一门语言，因为它并不用来编程，而只是一种用于排版和呈现内容的低门槛 HTML，由于建立个人博客而结识这个遍历的工具，作为新一代文本格式，它使得良好可观的排版可以简单快速地生成。\ngit 这既是一门版本管理艺术的技术，又是一项近乎必备的团队协作工具，因其优异于 SVN 的设计理念，而成为新一代无可匹敌的版本管理工具，同时与其完美配合的最大开源社区 github 是众多开源爱好开发者思维碰撞的乌托邦\n负载均衡\u0026amp;反向代理 一开始认为这仅仅属于后端技术，但现在这应该分类于 web 技术，因为前端开发并不应该“两耳不闻后端事，一心只习前端术”，而应该站在整个 web 生态的角度，纵观互联网应用的整个生命。尤其是伴随着 node 的出现，可能带来的一门语言贯穿 web，而不分前后端、只有全栈的可能。\njava 这是我入门编程在学院习得的技术，也是我打开 web 世界的入口。何况作为如今难逃整个国内仍使用它作为后端基石的现状，毕竟 node 还尚未撼动其成为主流，鉴于对于 web 历史的尊重，掌握 java 也是理解其他语言的前置条件之一。\npython 这本是我区别于 java 准备主修的第二门语言，但鉴于 javascript 的持续火热和前端在国内快速地发展，它便成为我业余编程作为工具的备用语言，我在 Coursera 完成了 python 一个学期的学习，并以满分获得在线认证证书，也算是作为 python 学习的一次考核。\nes6 这其实应该算是前端开发的核心技术，如果说在 2017 年，它还算是一门新技术的话，那么站在 2018 年再看，它其实已经广泛应用于众多前端开发之中，因为有类似 Babel 这样的东西的存在，es6 投入生产的使用变得不再难以接受。\n总结 纵观 2017 年的学习，不多不少，完成了从后端转为前端的技术栈学习。2018 年的计划将是对于某几个前端核心技术进行更加深度地学习，对于前端的技术栈进行更进一步的完善和更多的实践。\nTo be learned Items:\nVue angular es6 html5\u0026amp;css3 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-09-review-of-2017/","summary":"\u003cp\u003e关于 2017 年个人博客点滴的年终总结\u003c/p\u003e","title":"2017年个人技术盘点"},{"content":"记录一下常用到的 linux 命令（包含相应 Windows 中的操作）\nwget tar curl yes python 安装 web.py 方式一 下载 python 文件\nwget http://webpy.org/static/web.py-0.37.tar.gz 最新开发版:https://github.com/webpy/webpy/tarball/master\n解压\ntar -zxvf web.py-0.37.tar.gz 安装\npython setup.py install 参考链接：\nhttp://man.linuxde.net http://www.shouce.ren/api/linux https://github.com/jaywcjlove/linux-command https://www.linuxdaxue.com/linux-commands-manual http://webpy.org/install.zh-cn ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-07-linux-basic-commands/","summary":"\u003cp\u003e记录一下常用到的 linux 命令（包含相应 Windows 中的操作）\u003c/p\u003e","title":"linux常用命令(长期更新)"},{"content":"React 官网教程系列之前期准备\n初尝 React 在线尝试 React 或在本地开发环境安装 React\n在线版 如果你对 React 的乐趣在于只是随便玩玩，那你可以使用在线编程环境。在CodePen或CodeSandbox尝试 Hello World 模板\n最小 HTML 模板 如果你更想使用你自己的文本编辑器，你也可以用下载这个HTML 文件，编辑它并从你本地浏览器中的文件系统打开它。它会有一个缓慢的代码转换，所以不要在生产中使用它。\n快速上手 前往快速上手部分来一步一步按照指引学习 React 的概念\n尝试教程作为一个动手实践机会\n完整开发环境 如果你初次接触 React 或者仅仅用于实验，上面的轻量解决方案很适合你\n当你准备好使用 React 去构建你第一个程序时，查阅下面的安装指引。这些安装被设计用来帮助你并获得良好的开发体验，并且可用于生产。它们包括代码检验（linting）、测试和最佳构建（optimizations built-in)；然而它们需要更多的时间和空间来安装\n使用 React创建一个新的应用：使用一个包含完整特性的开始工具套件创建一个新的应用\n将 React添加进一个已存在的应用：将 React 添加进一个构建系统或一个更大的应用\n将 React 添加一个新的应用 在一个新的应用上使用 React 启动的最简单方式就是使用一个开始工具套件（strater kit）\n这页描述了创建一个你所需要的单页应用，以提供一个舒服的工作流，包含代码检查（linting）、测试和最佳生产以及更多。\n全特性工具需要一些时间和空间来安装。如果你想要一个轻量环境来用 React 做实验，查看上面的初尝 React 方式，一个单一的 HTML 文件足够开始。\n最后，如果你不是构建单页应用，你可以将 React添加进已存在的构建管道或者从CDN使用它而无需构建\n创建 React 应用 Create React App是开始构建一个新的 React 单页应用最好的方式。它建立了你的开发环境，这样你就可以使用到最新的 JavaScript 特性，提供你一个良好的开发体验，为你最佳化你的生产应用。你将需要机器上安装大于版本 6 的 Node\nnpm install -g create-react-app时 create-react-app my-app cd my-app npm start 如果你安装了 5.2.0 以上版本的 npm，你可能使用 mnpx代替\nnpx create-react-app my-app cd my-app npm start 创建 React 应用不会处理后端逻辑和数据库；它只是创建了一个前端构建管道，所以你可以把它用作任何后端。它底层使用比如Babel和Webpack的构建工具，但是只需要零配置就能工作。\n当你准备好部署你的产品，运行 npm run build 将会在 build 目录为你的应用创建一个最佳构建。你可以通过它的README和用户手册学习更多关于 Create React App\n其他启动工具 我们创建了一份官方推荐的第三方启动工具列表\n它们在各自侧重点有些细微不同，但都是生产就绪的、良好维护的并且不需要任何配置就能开始的。\n你也可以查看一个由社区贡献的其他工具列表\n高级使用 如果你倾向于手动配置一个工程，查阅下一部分的安装 React\n将 React 添加进一个已存在的应用 你无需重写你的应用以开始使用 React\n我们推荐添加 React 进你应用的一块小的部分，比如一个独立的组件，这样你可以在你的用例中看到它是否工作\n虽然 React 可以被使用于没有构建管道的情况，但我们推荐建立构建管道，这样你可以提高生产。一个现代的构建管道通常组成：\n一个包管理器，比如Yarn或者npm。这使你能够利用第三方包的浩瀚生态，并轻易地安装或者更新它们\n一个打包器，比如webpack或者Browserify。这让你书写模块化的代码并把它们打包到一起成小的包，以使得加载时最优\n一个编译器，例如Babel。它让你书写现代化化 JavaScript 代码，却仍能工作在旧的浏览器\n安装 React 一旦安装，我们强烈推荐建立一个生产构建进程以确保你在生产中使用 React 的快速版本\n我们推荐使用 Yarn 或者 npm 来管理前端依赖。如果你初次接触包管理器，Yarn 文档是一个良好开始的地方。\n使用 Yarn 安装 React 并运行：\nyarn init yarn add react react-dom 使用 npm 安装 React 并运行：\nnpm init npm install --save react react-dom Yarn 和 npm 都是从 npm 注册中心下载\n为避免潜在的不兼容问题，所有的 react 包应该使用相同的版本。（这包括：react、react-dom、react-test-renderer 等等）\n使 ES6 和 JSX 生效 我们推荐使用伴随 Babel 的 React 以使得你使用 ES6 和 JSX 在你的 JavaScript 代码中。ES6 是一个现代 JavaScript 代码的集合，使得开发更简单，JSX 是一个使得 JavaScript 语言和 React 一起良好工作的拓展\nBabel 安装指引解释了如何配置 Babel 在许多不同的构建环境。确保你安装babel-preset-react和babel-preset-env并确保它们在你的.babelrc配置中，你就可以良好工作了。\n使用 ES6 和 JSX 的 Hello World 我们推荐使用像 webpack 或 Browserify 这样的打包器，这样你可以书写模块化代码并它们打包到一起进小的包裹以在加载时最优化\n最小的 React 例子：\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; ReactDOM.render( \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 这份代码将 id 为 root 的元素渲染成一个 DOM 元素，所以你需要在你的 HTML 文件的某处有\n类似的，你可以将你使用任何其他 JavaScriptUI 库写的已存在的应用中某处的 DOM 元素内渲染一个 React 组件\n了解更多关于集成 React 和已存在代码\n开发和生产版本 默认的，React 包含许多有帮助的警告。这些警告在开发中非常有用。\n然而，它使得开发版本变得更大更慢，所以你应该当你部署你的应用时使用生产版本。\n学习 https://reactjs.org/docs/optimizing-performance.html#use-the-production-build 如何辨别你的网站是否正在服务正确版本的React，还有如何最高效地配置生产构建进程：\n使用 Create React App 创建一个生产构建 使用单文件构建创建一个生产构建 使用 Brunch 创建一个生产构建 使用 Browserify 创建一个生产构建 使用 Rollup 创建一个生产构建 使用 webpack 创建一个生产构建 使用 CDN 如果你不想用 npm 管理客户端包，react 和 react-dom 的 npm 包也提供了单文件版本在 umd 目录。详情见CDN 页\nCDN 链接 React 的 UMD 构建和 ReactDOM 在 CDN 之间可用\n\u0026lt;script crossorigin src=\u0026#34;https://unpkg.com/react@16/umd/react.development.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script crossorigin src=\u0026#34;https://unpkg.com/react-dom@16/umd/react-dom.development.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 上面的版本仅对开发而言，对于生产不适用。简化和优化生产版本如下：\n\u0026lt;script crossorigin src=\u0026#34;https://unpkg.com/react@16/umd/react.production.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script crossorigin src=\u0026#34;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 加载 react 和 react-dom 一个特定的版本，用版本号替换 16 即可\n为什么有 crossorigin 这个属性 如果你从 CDN 提供 React 服务，我们推荐你保持 crossorigin 这个属性：\n\u0026lt;script crossorigin src=\u0026#34;...\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 我们也推荐去确认你正在使用的 CDN 集的 Access-Control-Allow-Origin: *的 HTTP 头（在 HTTP 相应头包含）。这使得一个更好的错误处理体验在 React16 和以后的版本\n参考链接：https://reactjs.org/docs/try-react.html\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-07-react-install/","summary":"\u003cp\u003eReact 官网教程系列之前期准备\u003c/p\u003e","title":"React教程——安装篇"},{"content":"管理 node 和 npm 的更新\n今天安装 react 开发工具，在使用 npm 安装 create-react-app 时，被提示更新 npm 和 node 的版本以获得更好的体验，瞬间感觉惨遭嫌弃，遂整理一波 node 和 npm 管理更新的方式\n先查看 node 和 npm 的版本\nnode --version npm --version 安装 nvm\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash 这种方式用于类 Unix 系统\n不过要注意安装后要重新打开终端，否则识别不到 nvm，而且其实在安装结束的时候，是有提示文案的（这其实和 Windows 下在 cmd 中安装东西后需要重新打开 cmd 一样）\nnvm 主要用于安装 node 的不同版本，使用如下：\nnvm install 8.5.0 这样直接安装指定的 node 版本，还可以\nnvm install latest 安装最新版本（但不是最稳定版本，会有新的测试特性），还可以安装稳定版本\nnvm install stable Windows 的 nvm 还可以下载 node 多个版本并进行选择使用哪个版本（和 linux 不同，安装新的版本必须替换掉旧的版本，同时只能存在一个版本）\nwindows-nvm下载地址\n同样，下载某个你需要的版本\nnvm install 8.5.0 结束后会提示你可以通过命来切换刚下载的版本，此时你也可以在 nvm 的目录下看到不同版本的 node 文件夹\n如果不切换，仍会是当前安装的 node 版本\n可查看当前本地有哪些版本\n切换命令如提示：\nnvm use 8.5.0 相应，删除某个版本\nnvm uninstall 4.4.3 另外对于 Windows 下更新 npm 到最新版本，如下：\nnpm install npm@latest -g 参考链接：https://segmentfault.com/a/1190000007612011\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-07-nodejs-and-npm-update/","summary":"\u003cp\u003e管理 node 和 npm 的更新\u003c/p\u003e","title":"工具篇——如何管理node和npm的更新"},{"content":"如何解决 VMware 安装 VMware Tools 后仍不能全屏显示的问题\n原因 macOS10.11 上启动了一个 SIP(System Integrity Protection，系统集成保护)\n它防止/library/perferences/systemconfiguration/com.apple.Boot.plist 文件被修改\n解决 启动 macOS 过程中进入 recovery console（启动系统时按住 command+R，windows 系统则按住开始键+R，直至看到苹果标志即可松手）\n选择实用工具，打开终端\n关闭 SIP，重启\nBingo！\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-07-vmware-macos-max-window/","summary":"\u003cp\u003e如何解决 VMware 安装 VMware Tools 后仍不能全屏显示的问题\u003c/p\u003e","title":"VMware使用macOS如何全屏"},{"content":"探讨浏览器缓存相关\n相关概念 cookie 浏览器缓存 localStorage sessionStorage 使用场景 提高前端访问性能——优秀的缓存策略\n好处：\n缩短网页请求资源的距离 减少延迟 缓存文件重复使用 减少带宽 降低网络负荷 web 缓存分类 数据库缓存 代理服务器缓存 CDN 缓存 浏览器缓存 实例：\n浏览器向代理服务器发起 web 请求，代理服务器将请求转发到源服务器，此处使用共享缓存，使得多处地方可以使用相同的缓存，节省流量\n浏览器缓存 实例：\n浏览器缓存是将文件保存在客户端，同一个会话过程中检查缓存副本是否足够新，在后退网页时，访问过的资源可从缓存中取。\n性能提升点：通过减少服务器请求的数量，获得更快的访问体验\n缓存决定因素 页面的缓存状态由 header 决定，重要参数如下：\nCache-Control Expires Last-modified ETag 1.Cache-Control 可配置选项如下：\nmax-age s-maxage public private no-cache no-store must-revalidate \u0026hellip; 总体关联 max-age 单位：s\n含义：缓存最大有效时间\n特点：会覆盖掉 Expires，并且在缓存有效时间内，即使服务器上资源发生变更，浏览器也不会得到通知\ns-maxage 同 max-age，但仅用于共享缓存（例如 CDN 缓存）\n实例：s-maxage=60，则 60s 内即使 CDN 内容更新，浏览器也不会再次请求\n对比 max-age：\nmax-age 用于普通缓存，s-maxage 用于代理缓存\n特点：s-maxage 会覆盖掉 max-age 和 Expires\npublic 响应会被缓存，且在多用户间共享\n若未指定 public 还是 private，默认为 public\nprivate 相应会被缓存，且不在用户间共享\n实例：要求 HTTP 认证，相应会自动设置为 private\nno-cache 指定响应资源不进行缓存\n注意：仅设置 no-cache 不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否变更\n实例：若想防止缓存，可设置 no-cache private 过期时间设置为已过去的时间（不会到达）\n-no-store\n绝对禁止缓存，每次请求资源都从服务器重新获取\nmust-revalidate 若页面过期，则需重新去服务器获取\n2.Expires 缓存过期时间（指定资源到期时间，在此时间前浏览器可从浏览器缓存取资源，而无需再次请求），是服务器端具体时间点\nExpires = max-age + 请求时间\n需结合 Last-modified 结合使用\n优先级：Cache-Control \u0026gt; Expires\n3.Last-Modified 服务器端文件最后修改时间，需和 Cache-Control 共同使用\n可检查服务器端资源是否变更\n浏览器再次发出请求时，会向服务器发送 If-Modified-Since 报头，以询问 Last-Modified 时间点后该资源是否变更，若未变更，则返回 304，使用缓存；若变更，则重新向服务器请求资源，返回 200\n4.ETag 根据资源文件内容生成hash，用于标识资源状态，服务器端产生\n浏览器再次访问服务端时会带上 ETag，以验证资源是否变更\n优势：解决 Last-modified 存在的问题\n某些服务器不能精确得到资源的最后修改时间，因此无法根据最后修改时间判断资源是否变更 资源修改频繁，在秒级下的修改，无法被 Last-modified 识别到（Last-Modified 为秒级） 资源最后修改时间改变，但内容未变更，ETag 识别为资源未变更（实际上资源的最后修改时间发生变更） 参考链接：\nhttps://segmentfault.com/a/1190000008377508 HTTP 权威指南 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-02-02-browser-cache/","summary":"\u003cp\u003e探讨浏览器缓存相关\u003c/p\u003e","title":"关于浏览器缓存"},{"content":"Refresh your JavaScript Knowledge\nJavaScript 知识巩固 诞生 JavaScript 于 1995 年被网景的一名工程师 Brendan Eich 所创造\n第一次发布于 1996 年早期的 Netscape 2\n最初叫 LiveScript\n但由于不幸的营销决策，为了利用 Java 的热度，而改名为 JavaScript（但与 Java 毫无联系）\n发展历程 几个月后，微软在 IE 3 中发布了 JScript\n几个月后，网景向 ECMA（欧洲标准组织）国际组织提交了 JavaScript\n于是在那一年诞生了 ECMAScript 标准的第一个版本\n这个标准在 1999 年收到了一个具有象征意义的更新，定为 ECMAScript 第三版本，从那以后版本趋于稳定\n由于有关语言复杂性的政治分歧，第四个版本被废弃掉\n随后第四版本的许多部分成为了第五个版本的基础，发版于 2009 年 12 月\n第六版发布于 2015 年 6 月\n应用场景 不像大多数语言，JavaScript 没有输入和输出的概念\n它被设计用来在宿主环境作为一种脚本语言运行，并且由宿主环境决定其与外部世界沟通的机制\n最普遍的宿主环境是浏览器\n但 JavaScript 解释器还能在以下地方找到：\nAdobe Acrobat Adobe Photoshop SVG images（矢量图） Yahoo\u0026rsquo;s Widget engine（雅虎组件引擎） 服务端环境，例如 Node.js 非关系型数据库，例如开源的 Apache CouchDB 嵌入式计算机 复杂的桌面环境，例如 GNOME（GNU/Linux 操作系统最著名的图形界面系统之一） 其他 概述 JavaScript 是一种多范式、动态语言，拥有类型、操作符、标准内建对象和方法\n它的语法基于 Java 和 C（许多这二者语言的结构都被应用于 JavaScript）\nJavaScript 支持面向对象编程通过使用对象原型（object prototypes）取代类（更多见**原型继承和 ES2015类**概念）\nJavaScript 也支持函数式编程——函数是对象，给予函数容纳可执行代码的能力并将像其他对象一样进行传递\nJavaScript 类型 Number String Boolean Function Object Symbol（ES2015 新加） 技术上更严谨的分类如下：\nNumber\nString\nBoolean\nSymbol（ES2015 新加）\nObject\nFunction Array Date RegExp Math null\nundefined\n还有一些内建的 Error 类型\nNumber JavaScript 的 Numbers 是 double-precision 64-bit format IEEE 754 values\n由于这个特点，JavaScript 中没有整型，所以在 C 或 Java 中使用到的算数运算要在 JavaScript 中留意\n比如：\n0.1+0.2 0.30000000000000004 实践中，整型值会被当做 32 位整数，并且甚至有些实现以这种方式存储，直到被要求去执行一条在 Number 上有效但在 32 位整型上无效的指令，这对于位运算来说很重要\n原文：In practice, integer values are treated as 32-bit ints, and some implementations even store it that way until they are asked to perform an instruction that\u0026rsquo;s valid on a Number but not on a 32-bit integer. This can be important for bit-wise operations.\n标准的算数运算符被支持，包括加、减、取模、取余等等\n内建对象 Math 提供了高级数学运算函数和常量\nMath.sin(3.5); -0.35078322768961984 r = 2; var circumference = 2 * Math.PI * r; console.log(circumference) 使用内建函数 parseInt()可以将一个字符串转换为整型数，但是要注意给该函数指定第二个参数（要转换的进制），如果不填会得到意想不到的结果\nparseInt(\u0026#39;010\u0026#39;) 10 parseInt(\u0026#39;0x10\u0026#39;) 16 parseInt(\u0026#39;010\u0026#39;, 8) 8 parseInt(\u0026#39;0x10\u0026#39;, 16) 16 parseInt(\u0026#39;11\u0026#39;,2) 3 转换为八进制省略第二个参数的方式在 2013 年后被废除，但十六进制忽略第二个参数的用法仍存在，因为可以识别到十六进制前缀0x\n还有内建函数 parseFloat 用于将字符串转换为浮点数，但不同于 parseInt()，它总是默认以十进制方式转换\n另外，还可以通过一元运算符+将值转换为数值\nparseFloat(\u0026#39;12.34\u0026#39;) 12.34 + \u0026#39;56.78\u0026#39;; 56.78 + \u0026#39;0x10\u0026#39; 16 + \u0026#39;42\u0026#39; 42 如果字符串是非数值，转换会返回一个特殊值 NaN（Not a Number）\nparseInt(\u0026#39;hello\u0026#39;, 10) NaN 如果将 NaN 作为输入，做任何算数运算所得都是 NaN\nparseInt(\u0026#39;hello\u0026#39;, 10) + 5 NaN 可通过内建函数 isNaN()判定是否为 NaN\nisNaN(parseInt(\u0026#39;hello\u0026#39;, 10) + 5) true JavaScript 还提供了特殊值：Infinity 和-Infinity\n1 / 0; Infinity -1 / 0; -Infinity 可以使用内建函数 isFinite()判断 Infinity、-Infinity 和 NaN\nisFinite(1 / 0); false isFinite(-1 / 0); false isFinite(NaN); false parseInt()、parseFloat()和+的区别：前两者会将字符串转换，直到遇到不是有效的数字止，而+会直接将字符串转换为 NaN 如果字符串内包含无效字符\nparseInt(\u0026#39;10.2abc\u0026#39;); 10 + \u0026#39;10.2abc\u0026#39; NaN String JavaScript 中的字符串是 Unicode 字符序列，这对于处理国家化问题来说很方便，更准确地讲，是 sequences of UTF-16 code units，每一个码单元通过一个 16 位数字呈现，每一个 Unicode 字符通过 1 个或 2 个码单元呈现\n如果想呈现一个单字符，只需要使用一个包含单个字符的字符串\n如果想知道一个（码单元中的）字符串的长度，访问其 length 属性\n\u0026#39;hello\u0026#39;.length 5 字符串也可当做对象，并通过方法来操作字符串的信息\n\u0026#39;hello\u0026#39;.charAt(0); \u0026#34;h\u0026#34; \u0026#39;hello, world\u0026#39;.replace(\u0026#39;hello\u0026#39;, \u0026#39;hola\u0026#39;); \u0026#34;hola, world\u0026#34; \u0026#39;hello\u0026#39;.toUpperCase(); \u0026#34;HELLO\u0026#34; 其他类型 JavaScript 用 null 表示 non-value（并且也仅能通过null访问）\n还有 undefined 表示一个尚未初始化的值（表示一个还未被赋值的变量）\n如果你声明一个变量，但没对其赋值（assign），这个变量的类型就是 undefined，但 undefined 实际上是一个常量\nJavaScript 还有一个布尔类型，只有两个值，true 和 false\n任何值都能被转换成一个布尔值通过以下方式：\nfalse、0、空字符串（\u0026quot;\u0026quot;）、NaN、null 和 undefined\n所以其他都被判定为布尔中的 true\n使用 Boolean()函数来具体实现\nBoolean(\u0026#39;\u0026#39;); false Boolean(234); true 这很少情况需要这样处理，当 JavaScript 期望一个布尔值时，会静默执行布尔转换，例如ifstatement\n布尔操作符，例如\u0026amp;\u0026amp;（逻辑与）、||（逻辑或）和！（逻辑非）都被支持\n变量 JavaScript 通过三个关键字声明新的变量：let、const 和 var\nlet 允许声明块级变量，其声明的变量仅在封闭块中有效\nfor (let i = 1; i \u0026lt; 5; i++) { console.log(i); } console.log(i); VM959:2 1 VM959:2 2 VM959:2 3 VM959:2 4 VM959:4 Uncaught ReferenceError: i is not defined at \u0026lt;anonymous\u0026gt;:4:13 const 允许声明永远不会企图改变的变量，并且也仅在所声明的块范围内有效\nfor (const j = 2; j \u0026lt; 4; j++) { console.log(j); } console.log(j); VM1175:2 2 VM1175:1 Uncaught TypeError: Assignment to constant variable. at \u0026lt;anonymous\u0026gt;:1:27 var 是最通用的声明关键字，它没有 let 和 const 的限制\n它是传统 JavaScript 唯一的声明变量的关键字\nfor (var k = 3; k \u0026lt; 7; k ++) { console.log(k); } console.log(k); VM1257:2 3 VM1257:2 4 VM1257:2 5 VM1257:2 6 VM1257:4 7 JavaScript 和其他语言（比如 Java）很重要的一个区别是代码块并没有域，只有函数才有域\n所以如果在一个 compound statement（例如在 if 控制结构范围内）内使用 var 声明的变量在整个函数范围内都可见，如上例\n然而，从 ES2015 开始，let 和 const 的声明允许创建块级域变量\n运算符 JavaScript 数值运算符有+、-、*、/和%\n通过=赋值\n还有一些复合赋值操作，例如+=和-=，这相当于 x = x + y 或 x = x - y\n你可以使用++和--分别表示递增和递减，这些都可以被用作运算符前缀或后缀\n+运算符还可用作字符串连接符\n\u0026#39;hello\u0026#39; + \u0026#39;world\u0026#39;; \u0026#34;helloworld\u0026#34; 如果你把一个字符串追加于一个数字或其他值，都会首先被转化为一个字符串\n\u0026#34;3\u0026#34; + 4 + 5; (\u0026#34;345\u0026#34;); 3 + 4 + \u0026#34;5\u0026#34;; (\u0026#34;75\u0026#34;); 为某个值追加一个空字符串是一个将其转换为字符串的方式\nJavaScript 使用\u0026lt;、\u0026gt;、\u0026lt;=和\u0026gt;=进行比较操作\n这些既对字符串有效，也对数字有效\n判断两个值相等并不是那么直接，如果给双等运算符==两个不同类型的值，会表现出类型约制\n123 == \u0026#34;123\u0026#34;; true; 1 == true; true; 为避免约制，使用三等运算符\n123 === \u0026#34;123\u0026#34;; false; 1 === true; false; 还有!=和!==\nJavaScript 还有**位运算符**\n控制结构 JavaScript 有一套类似 C 语言家族的控制结构\n条件语句通过 if 和 else 支持\nvar name = \u0026#34;hello\u0026#34;; if (name == \u0026#34;test\u0026#34;) { name += \u0026#34;test\u0026#34;; } else if (name == \u0026#34;hello\u0026#34;) { name += \u0026#34;world\u0026#34;; } else { name += \u0026#34;!\u0026#34;; } name == \u0026#34;helloworld\u0026#34;; true; JavaScript 拥有 while 循环和 do-while 循环，前者用于基本循环，后者用于你想确保循环至少执行一次\nwhile (true) { // an infinite loop! } var input; do { input = get_input(); } while (inputIsNotValid(input)); JavaScript 的 for 循环和 C 还有 Java 的一样，使你能够在一行内提供控制信息\nfor (var i = 0; i \u0026lt; 5; i++) { // Will execute 5 times } JavaScript 还有两个高级 for 循环\nfor of for (let value of array) { // do something with value } for in for (let property in object) { // do something with object property } \u0026amp;\u0026amp;和||运算符有短路逻辑，意味着第二个运算值的是否执行决定于第一个运算值\n这有助于检查空对象在访问其属性之前\no = null; var name = o \u0026amp;\u0026amp; o.getName(); null; 或进行缓存值（当假值无效时）??\nvar name = cachedName || (cachedName = getName()); JavaScript 对条件语句拥有一个三元运算符\nage = 19; var allowed = (age \u0026gt; 18) ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39;; console.log(allowed); VM1682:3 yes switch语句可被用于基于一个数字或字符串的多分支判断\nswitch (action) { case \u0026#34;draw\u0026#34;: drawIt(); break; case \u0026#34;eat\u0026#34;: eatIt(); break; default: doNothing(); } 如果你没有添加 break 语句，将会在该条件下的内容执行后继续向下执行，这可能并不是你想要的，如果你的确想这么做用于调试，请添加注释表明\nswitch (a) { case 1: // fallthrough case 2: eatIt(); break; default: doNothing(); } 默认条款是可选的，你在 switch 部分和 case 部分都可以有表达式，比较会在二者使用了===运算符时发生\nswitch (1 + 3) { case 2 + 2: console.log(\u0026#39;execute 4\u0026#39;); break; default: neverhappens(); } VM1831:3 execute 4 对象 JavaScript 的对象可以理解为一个键值对集合，类似于：\nPython 中的字典\nPerl 和 Ruby 中的 Hashes\nC 和 C++中的哈希表\nJava 中的 HashMap\nPHP 中的关联数组\n事实上这个数据结构被如此广泛的使用，是其多才多艺的一个佐证\n因为 JavaScript 中的一切都是对象\n任何 JavaScript 程序自然包含着一个强大的哈希表查找，这是个好事，因为很快\nJavaScript 对象的“键”部分是一个字符串，“值”部分可以是任何值\n这允许你可以构造任意复杂的数据结构\n有两种基本的创建对象的方法：\nvar obj = new Object(); 和\nvar obj = {}; 这二者语义上相等，后者称为 object literal syntax，并且更方便\n这种语法也是 JSON 格式的核心并总被偏爱\n文字对象语法可以用来完整初始化一个对象：\nvar obj = { name: \u0026#39;test\u0026#39;, _for: \u0026#39;max\u0026#39;, details: { color: \u0026#39;orange\u0026#39;, size: 12 } }; obj {name: \u0026#34;test\u0026#34;, _for: \u0026#34;max\u0026#34;, details: {…}} 属性可被链接到一起\nobj.details.color; (\u0026#34;orange\u0026#34;); obj[\u0026#34;details\u0026#34;][\u0026#34;color\u0026#34;]; (\u0026#34;orange\u0026#34;); 下面的例子创建了一个对象原型 Person 和一个原型实例 You\nfunction Person(name, age) { this.name = name; this.age = age; } var you = new Person(\u0026#39;You\u0026#39;, 24); console.log(you); VM2069:7 Person {name: \u0026#34;You\u0026#34;, age: 24} 一经创建，一个对象的属性可被再次访问用以下两种方式：\nobj.name = \u0026#34;magi\u0026#34;; var name = obj.name; (\u0026#34;magi\u0026#34;); obj[\u0026#34;name\u0026#34;] = \u0026#34;igma\u0026#34;; var name = obj[\u0026#34;name\u0026#34;]; (\u0026#34;igma\u0026#34;); var user = prompt(\u0026#34;what is your key?\u0026#34;); obj[user] = prompt(\u0026#34;what is your value?\u0026#34;); (\u0026#34;111\u0026#34;); 这些也语义上相等，后者优势在于 name 属性作为一个字符串被提供，意味着可以在运行时被计算\n然而，使用这种方式可以防止了有些 JavaScript 引擎和优化器被应用\n另外，也因此可以使用关键字来设置和获得属性\nobj.for = \u0026#34;Simon\u0026#34;; // Syntax error, because \u0026#39;for\u0026#39; is a reserved word obj[\u0026#34;for\u0026#34;] = \u0026#34;Simon\u0026#34;; // works fine 从 ECMAScript 5 开始，保留字可以用作对象属性名 in the buff。这意味着定义对象时不再需要引号来包裹，详情见the ES5 Spec\n更多关于对象和原型，见Object.prototype\n关于对象原型和对象原型链，见继承和原型链\n从 ECMAScript2015 开始，对象的键可以被使用括号符的变量定义\nvar userPhone = {[\u0026#39;phoneType\u0026#39;]: 12345}; console.log(userPhone); VM2470:2 {phoneType: 12345} 可以代替\nvar userPhone = {}; userPhone[\u0026#39;phoneType\u0026#39;] = 12345; console.log(userPhone); VM2505:3 {phoneType: 12345} 数组 JavaScript 中的数组其实一种特殊类型的对象\n和常规的对象非常像（数值属性只能使用[]语法访问）\n但有一个神奇的属性叫做“length”\n其总是比数组最大索引值多一位\n创建数组的方式如下：\nvar a = new Array(); a[0] = \u0026#34;dog\u0026#34;; a[1] = \u0026#34;cat\u0026#34;; a[2] = \u0026#34;hen\u0026#34;; a.length; 3; 一个更方便的表示方式是使用数组文字（array literal）\nvar a = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;hen\u0026#34;]; a.length; 3; 注意 array.length 不必是数组项目的个数，考虑下面一种情况\nvar a = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;hen\u0026#34;]; a[100] = \u0026#34;fox\u0026#34;; a.length; 101; 谨记：数组的长度总比数组索引最大值大一位\n如果访问一个不存在的数组索引，会得到一个值为 undefined 的返回值\ntypeof a[90]; (\u0026#34;undefined\u0026#34;); 如果把上面的[]和 length 纳入考虑，你可以使用 for 循环迭代一个数组\nfor (var i = 0; i \u0026lt; a.length; i++) { console.log(a[i]); } VM302:2 dog VM302:2 cat VM302:2 hen 97VM302:2 undefined VM302:2 fox ECMAScript 介绍了一种更加简明的循环 for of，用来迭代对象，比如数组：\nfor (const currentValue of a) { console.log(currentValue); } VM394:2 dog VM394:2 cat VM394:2 hen 97VM394:2 undefined VM394:2 fox 你也可以使用 for in 循环来迭代一个数组，但如果有人向 Array.prototype 添加了新的属性，它（新加的属性）在本次循环也会被迭代。所以这种循环类型不被推荐用于数组迭代\n另一种在 ECMAScript5 中添加的用来迭代数组的方式是 forEach()\n[\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;hen\u0026#39;].forEach(function(currentValue, index, array) { console.log(\u0026#39;currentIndex: \u0026#39; + index + \u0026#39; currentValue: \u0026#39; + currentValue + \u0026#39; array: \u0026#39; + array); }); VM486:2 currentIndex: 0 currentValue: dog array: dog,cat,hen VM486:2 currentIndex: 1 currentValue: cat array: dog,cat,hen VM486:2 currentIndex: 2 currentValue: hen array: dog,cat,hen 如果想要为一个数组追加元素，只需要简单地：\na.push(item); 数组方法列表如下：\nMethod name Description Example a.toString 返回数组的每一个元素以逗号分隔的字符串 dog,cat,hen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,fox a.toLocaleString() 同 toString，不过先判断指定语言环境，没指定则使用默认语言环境，主要用于 Date 类型 - a.concat(item1[, item2[, \u0026hellip;[,itemN]]]) 返回一个追加于其后的一个新的数组 a.concat(\u0026lsquo;panda\u0026rsquo;,\u0026lsquo;seal\u0026rsquo;)-\u0026gt; [empty × 97, \u0026ldquo;hen\u0026rdquo;, \u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;panda\u0026rdquo;, \u0026ldquo;seal\u0026rdquo;] a.join(sep) 转换数组为一个字符串，伴随着以 sep 参数分隔的值 dog-cat-hen\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;fox a.pop 移除并返回最后一项 \u0026ldquo;fox\u0026rdquo; a.push(item1, \u0026hellip;, itemN) 向数组末端追加元素，并返回追加后的数组长度 101 a.reverse() 倒置数组 (101) [\u0026ldquo;fox\u0026rdquo;, empty × 97, \u0026ldquo;hen\u0026rdquo;, \u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;] a.shift 移除并返回第一个元素 \u0026ldquo;fox\u0026rdquo; a.slice(start[, end]) 返回子数组 a.slice(98,100) -\u0026gt; [\u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;] a.sort([cmpfn]) 采用可选比较函数进行排序 a.sort()-\u0026gt;[\u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;hen\u0026rdquo;, empty × 97] a.splice(start, delcount[, item1[, \u0026hellip;[, itemN]]]) 让你修改一个数组，通过删除一部分并使用更多条目替换之 a.splice(0, 2, \u0026lsquo;another cat\u0026rsquo;, \u0026lsquo;another dog\u0026rsquo;)-\u0026gt;[\u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;]-\u0026gt;a-\u0026gt;[\u0026ldquo;another cat\u0026rdquo;, \u0026ldquo;another dog\u0026rdquo;, \u0026ldquo;hen\u0026rdquo;, empty × 97] a.unshift(item1[, item2[, \u0026hellip;[, itemN]]]) 预先考虑数组开头的条目 a.unshift(\u0026lsquo;prepand item1\u0026rsquo;, \u0026lsquo;prepand item2\u0026rsquo;)-\u0026gt;102-\u0026gt;a-\u0026gt;[\u0026ldquo;prepand item1\u0026rdquo;, \u0026ldquo;prepand item2\u0026rdquo;, \u0026ldquo;another cat\u0026rdquo;, \u0026ldquo;another dog\u0026rdquo;, \u0026ldquo;hen\u0026rdquo;, empty × 97] 更多详见array methods \u0026amp; toLocaleString\n函数 同对象一起，函数也是理解 JavaScript 的核心组件\n最基本的函数不能再简单\nfunction add(x, y) { var total = x + y; return tatal; } 这演示了一个基本的函数\n一个 JavaScript 函数可以有 0 个或更多的命名参数\n函数体可以包含任意多你想要的语句并且可以声明它对于它本身，自己的变量\nreturn 语句可以被用来在任何时候返回一个值，中断函数\n如果没有返回语句（或者一个空的 return 而不包含任何值），JavaScript 会返回 undefined\n命名参数比起其他任何事物更像是指导方针，只要你想，你可以调用一个函数而不用传递任何参数，这种情况它会传递 undefined 作为参数\n所以直接运行上面定义的函数，会报错，因为你给函数传递了参数 undefined\nfunction add(x, y) { var total = x + y; return total; } add(); NaN 你也可以传递函数期望的更多参数\nfunction add(x, y) { var total = x + y; return total; } add(2, 3, 4); 5 参数“4”会被忽略\n这可能会看起来有点蠢，但函数会访问其函数体内部的附加名为 arguments 的变量，它是一个类数组对象，承载了所有传递给函数的参数\n让我们重写这个 add 函数来取到和我们想要的参数一样多的参数\nfunction add() { var sum = 0; for (var i = 0, j = arguments.length; i \u0026lt; j; i++) { sum += arguments[i]; } return sum; } add(2, 3, 4, 5); 14 再写一个平均值函数\nfunction avg() { var sum = 0; for (var i = 0, j = arguments.length; i \u0026lt; j; i++) { sum += arguments[i]; } return sum / arguments.length; } avg(2, 3, 4, 5); 3.5 这非常有用，但有一点啰嗦。要再减少一点这份代码，我们可以考虑参数数组作取代，通过Rest parameter syntax\n用这种方式，我们可以保持代码最小化的同时传递任意数量的参数给函数\nrest 参数运算符用于函数参数列表使用\u0026quot;\u0026hellip;variable\u0026quot;格式，它会包含进调用函数时整个未捕获参数列表\n我们也可以使用 for\u0026hellip;of 循环取代 for 循环来返回变量中的值\nfunction avg(...args) { var sum = 0; for (let value of args) { sum += value; } return sum / args.length; } avg(2, 3, 4, 5); 3.5; 在上述的代码中，args 变量拥有我们传递进函数的所有函数\n很重要需要注意无论何时 rest 参数运算符被放置在一个函数声明，它都会在它声明后存储所有的参数，但不会在声明之前（存储参数），例如：function avg(firstValue, \u0026hellip;args)将存储被传递进函数的第一个值 在 firstValue 中，剩余参数存储在 args 中。另一个有用的函数但也的确给我们带来一个新问题。avg()函数接收一个逗号分隔的参数列表——但是要是你想要得到一个数组的平均值？你只能重写这个函数如下：\nfunction avgArray(arr) { var sum = 0; for (var i = 0, j = arr.length; i \u0026lt; j; i++) { sum += arr[i]; } return sum / arr.length; } avgArray([2, 3, 4, 5]); 3.5; 但使得这个我们创建的函数可被重用会更好。\n幸运的是，JavaScript 可以让你使用一个任意的参数数组来调用一个函数，通过使用任何函数对象的 apply()方法\navg.apply(null, [2, 3, 4, 5]); 3.5; apply()的第二个参数是用作参数的数组；第一个参数后面再讨论，这强调了一个事实——函数也是对象\n你可以在函数调用中使用 spread 操作符达到相同的结果，例如 avg(\u0026hellip;numbers)\nJavaScript 让你可以创建匿名函数\nvar arg = function() { var sum = 0; for (var i = 0, j = arguments.length; i \u0026lt; j; i++) { sum += arguments[i]; } return sum / arguments.length; }; 这在语义上等同于 function avg()形式\n这非常强大，因为它可以让你把一个函数定义放在任何你通常放置表达式的地方\n这使得所有种类的聪明的诀窍\n这是一种“隐藏”一些本地变量的方式——像 C 语言中的块级域\nvar a = 1; var b = 2; (function() { var b = 3; a += b; })(); console.log(a); console.log(b); VM2347:9 4 VM2347:10 2 JavaScript 允许你递归调用函数。\n这对于处理树结构尤其有用，比如那些浏览器中的 DOM\nfunction countChars(elm) { if (elm.nodeType == 3) { // TEXT_NODE return elm.nodeValue.length; } var count = 0; for (var i = 0, child; (child = elm.childNodes[i]); i++) { count += countChars(child); } return count; } 这强调了匿名函数的一个潜在问题：如果它没有名字，你怎么递归地调用它？\nJavaScript 对于此让你可以给函数表达式命名\n你可以使用命名了的 IIFEs（Immediately Invoked Function Expression）如下面所示：\nvar charsInBody = (function counter(elm) { if (elm.nodeType == 3) { // TEXT_NODE return elm.nodeValue.length; } var count = 0; for (var i = 0, child; child = elm.childNodes[i]; i++) { count += counter(child); } return count; })(document.body); undefined charsInBody 58670 如上提供给一个函数表达式的名字仅对这个函数自己的域内可用\n这允许更多的引擎优化并给出更多的可读代码\n这个名称也出现在调试器和一些堆栈信息中，这会让你在调试时节省更多时间\n注意 JavaScript 函数本身就是对象——像 JavaScript 中其他的一切一样——并且你可以添加或改变他们的属性，就像我们在对象部分所见过的\n自定义对象 更多 JavaScript 面向对象编程见Object-Oriented JavaScript\n在传统的面向对象语言编程中，对象是运算在数据上的数据和方法的集合\nJavaScript 是基于原型的语言，没有像是在 C++或 Java 中的类语句（这有时会使得习惯于使用类语句的语言的编程者感到困惑）\n取而代之，JavaScript 使用函数作为类\n让我们考虑一个有名有姓的人作为对象\n姓名可能会以两种方式展示：如“名 姓”或“姓 名”\n使用我们前面讨论的函数和对象，我们就能展示数据如下：\nfunction makePerson(first, last) { return { first: first, last: last }; } function personFullName(person) { return person.first + \u0026#39; \u0026#39; + person.last; } function personFullNameReversed(person) { return person.last + \u0026#39;, \u0026#39; + person.first; } s = makePerson(\u0026#39;Simon\u0026#39;, \u0026#39;Willison\u0026#39;); console.log(personFullName(s)); console.log(personFullNameReversed(s)); VM1137:15 Simon Willison VM1137:16 Willison, Simon 这有效，但很丑\n这样最后你会在全局域有很多函数\n我们真正需要的是一种把一个函数依附于一个对象的方式\n因为函数也是对象，所以这很容易：\nfunction makePerson(first, last) { return { first: first, last: last, fullName: function() { return this.first + \u0026#39; \u0026#39; + this.last; }, fullNameReversed: function() { return this.last + \u0026#39;, \u0026#39; + this.first; } }; } s = makePerson(\u0026#39;Simon\u0026#39;, \u0026#39;Willison\u0026#39;); console.log(s.fullName()); console.log(s.fullNameReversed()); VM1572:15 Simon Willison VM1572:16 Willison, Simon 这里有一些我们前面没见过的东西：this 关键字\n使用内部函数，this 指向当前对象\n这实际上意味着你调用函数的方式来指定\n如果你使用一个对象上的点符或括号符来调用，那么那个对象就是 this\n如果调用没用点符，this 指向全局对象\n注意 this 是一个频繁导致错误的东西，例如：\ns = makePerson(\u0026#34;Simon\u0026#34;, \u0026#34;Willison\u0026#34;); var fullName = s.fullName; fullName(); (\u0026#34;undefined undefined\u0026#34;); 当我们单独调用 fullName()，而不用 s.fullName()，this 被绑定在全局对象\n因为没有全局变量叫 first 或者 last，所以我们对于二者都得到了 undefined\n我们可以利用 this 关键字来提高我们的 makePerson 函数\nfunction Person(first, last) { this.first = first; this.last = last; this.fullName = function () { return this.first + \u0026#34; \u0026#34; + this.last; }; this.fullNameReversed = function () { return this.last + \u0026#34; \u0026#34; + this.first; }; } var s = new Person(\u0026#34;Simon\u0026#34;, \u0026#34;Willison\u0026#34;); 我们介绍了另一个关键字 new\nnew 和 this 强度关联\n它创造一个新的空对象，然后调用指定的函数，并使用 this 设置给那个新建的对象\n注意通过 this 指定的那个函数不返回一个值，但很少修改 this 对象\n是 new 返回了 this 对象到调用的地方\n被设计为通过 new 调用的函数称为构造函数\n常见的做法是利用这些函数作为一个使用 new 调用它们的提醒\n提高后的函数仍有和单独调用 fullName 相同的陷阱\n我们的 person 对象变得更好了，但对于它们仍有一些丑陋边缘\n每次我们创建一个 person 对象，我们都创建了其内的两个崭新的函数对象——如果这代码被分享不会变得更好吗？\nfunction personFullName() { return this.first + \u0026#34; \u0026#34; + this.last; } function personFullNameReversed() { return this.last + \u0026#34;, \u0026#34; + this.first; } function Person(first, last) { this.first = first; this.last = last; this.fullName = personFullName; this.fullNameReversed = personFullNameReversed; } 这变得更好了，我们只创建了函数一次，并且在构造器里给它们的引用赋值\n我们能做的更好吗？答案是可以：\nfunction Person(first, last) { this.first = first; this.last = last; } Person.prototype.fullName = function() { return this.first + \u0026#39; \u0026#39; + this.last; }; Person.prototype.fullNameReversed = function() { return this.last + \u0026#39;, \u0026#39; + this.first; }; ƒ () { return this.last + \u0026#39;, \u0026#39; + this.first; } Person.prototype 是一个分享自 Person 所有实例的对象\n它形成一个查找链的一部分（有一个特殊的名字，原型链）：当任何时候你尝试去访问 Person 的一个属性时，JavaScript 会检查 Person.prototype 去看是否那个属性存在。\n然后任何赋值给 Person.prototype 的东西对于构造器的所有实例经 this 对象变得可用\n这是一个令人难以置信的强大工具\nJavaScript 让你可以修改某个东西的原型在任何时候，在你的程序里，意味着你可以在运行时对已存在的对象添加额外的方法\ns = new Person(\u0026#39;Simon\u0026#39;, \u0026#39;Willison\u0026#39;); console.log(s.firstNameCaps()); VM587:2 Uncaught TypeError: s.firstNameCaps is not a function Person.prototype.firstNameCaps = function() { return this.first.toUpperCase(); }; console.log(s.firstNameCaps()); VM588:4 SIMON 有趣的是，你也可以向 JavaScript 内建对象添加东西\n让我们给 String 添加一个方法以返回字符串的倒转字符串：\nvar s = \u0026#39;Simon\u0026#39;; s.reversed(); VM620:2 Uncaught TypeError: s.reversed is not a function String.prototype.reversed = function () { var r = \u0026#34;\u0026#34;; for (var i = this.length - 1; i \u0026gt;= 0; i--) { r += this[i]; } return r; }; s.reversed(); (\u0026#34;nomiS\u0026#34;); 我们的新方法甚至在字符串文字上有效！\n\u0026#34;This can now be reversed.\u0026#34;.reversed(); (\u0026#34;.desrever eb won nac sihT\u0026#34;); 像之前提到的，原型形成链的一部分\n链根是 Object.prototype，它的方法包括 toString()——是这个方法被调用当你试图呈现一个对象为一个字符串时\n这对于调试我们的 Person 对象很有用\nvar s = new Person(\u0026#34;Simon\u0026#34;, \u0026#34;Willison\u0026#34;); s.toString(); [object, object]; Person.prototype.toString = function () { return \u0026#34;\u0026lt;Person: \u0026#34; + this.fullName() + \u0026#34;\u0026gt;\u0026#34;; }; s.toString(); (\u0026#34;\u0026lt;Person: Simon Willison\u0026gt;\u0026#34;); 记得 avg.apply 是如何获得一个 null 作为第一个参数的吗？\n我们可以现在回看\napply()的第一个参数是应该被视为 this 的对象\n例如：这里有一个粗糙的 new 实现\nfunction trivialNew(constructor, ...args) { var o = {}; constructor.apply(o, args); return o; } 这不是一个准确的 new 的复制品，因为没有建立原型链（很难说明这一点）\n这不是你经常使用的东西，但知道这很有用\n在这个片段，\u0026hellip;args（包括省略号）被称为 rest 参数——正如其名暗示，这包含了参数余下的部分\nvar bill = trivialNew(Person, \u0026#39;William\u0026#39;, \u0026#39;Orange\u0026#39;); undefined bill {first: \u0026#34;William\u0026#34;, last: \u0026#34;Orange\u0026#34;} 所以这几乎等同于\nvar bill = new Person(\u0026#34;William\u0026#34;, \u0026#34;Orange\u0026#34;); apply()有一个姐妹叫做 call，再一次让你设置 this，但用一个不同于数组的拓展参数列表\nfunction lastNameCaps() { return this.last.toUpperCase(); } var s = new Person(\u0026#34;Simon\u0026#34;, \u0026#34;Willison\u0026#34;); lastNameCaps.call(s); (\u0026#34;WILLISON\u0026#34;); 这等同于：\ns.lastNameCaps = lastNameCaps; s.lastNameCaps(); (\u0026#34;WILLISON\u0026#34;); 内部函数：\nJavaScript 函数声明允许在其他函数内部\n我们之前见过一次，一个更早版本的 makePerson()函数\nJavaScript 的嵌套函数的一个重要细节是他们可以访问它们父函数域的变量\nfunction parentFunc() { var a = 1; function nestedFunc() { var b = 4; return a + b; } return nestedFunc(); } 这为写可维护代码提供了一个强大的处理工具\n如果一个函数依赖一个或两个对你代码其他部分没有用的其他函数，你可以嵌套那些工具函数在函数内部，以被其他任何地方调用\n这保持了全局域范围内的函数数量，总会是件好事\n这也是一个强大的全局变量诱饵的计数器（原文：This is also a great counter to the lure of global variables.）\n当写复杂代码时，经常尝试使用全局变量去在多个函数间分享——导致难以维护的代码\n嵌套函数可以在它们的父内分享，所以你可以将那种机制用于对函数，当不污染你的全局命名空间讲得通时——“本地全局变量”\n这个技术应当被小心使用，但它的确是一个有用能力\n闭包 这带领我们走向 JavaScript 提供的最强大的抽象——但也是最潜在令人迷惑的\n这是什么呢？\nfunction makeAdder(a) { return function(b) { return a + b; }; } var x = makeAdder(5); var y = makeAdder(20); console.log(x(6)); console.log(y(7)); VM1955:8 11 VM1955:9 27 makeAdder 函数的名字应该放弃：它创造新的 adder 函数，每一个伴随着一个参数调用的函数，都将其添加到创建它的参数（原文：it creates new \u0026lsquo;adder\u0026rsquo; functions, each of which, when called with one argument, adds it to the argument that it was created with.）\n这里发生的事和内部函数非常相同：一个定义在另一个函数内部的函数访问了外部函数的变量\n这里唯一不同的是外部函数有返回值，因此常识似乎指明它的局部变量不再存在\n但它们仍存在——否则 adder 函数将无法工作\n更重要的是，有 makeAdder()本地变量的两份不同的“拷贝”——一个在 a 中是 5，另一个 a 是 20\n所以函数调用的结果是 11 和 27\n这是真实正在发生的\n无论何时 JavaScript 执行一个函数，“域”对象被创建来承载那个函数内部创建的本地变量\n任何被传递进函数作为函数参数的变量将其初始化\n这和承载全局变量和函数的全局对象类似，但一组不同的地方是：首先，一个崭新的域对象每次函数开始执行时被创建，其次，不像全局对象（类似通过 this 访问或浏览器中的 window），这些域对象在你的 JavaScript 代码中不能直接被访问到，比如没有机制被用来迭代当前域对象属性\n所以当 makeAdder()被调用，一个域对象被创建，伴随一个属性 a，也就是被传给 makeAdder()的参数\nmakeAdder()然后返回一个新创建的函数\n通常 JavaScript 的垃圾回收器会在这个点清除掉 makeAdder()创建的域对象，但返回的函数维护了一个引用到域对象\n结果，域对象不会被垃圾回收器回收直到不再有 makeAdder()返回的函数对象的引用\n域对象形成一个叫做域链的链，和 JavaScript 对象系统使用的原型链类似\n闭包就是一个函数和其创造的域对象的集合体\n闭包使你保持状态——如此，你会发现它们被用在对象的地方\nsee more closure@ closures\n参考链接：\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript http://crockford.com/javascript/ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Unicode ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-js-refresh/","summary":"\u003cp\u003eRefresh your JavaScript Knowledge\u003c/p\u003e","title":"JavaScript知识巩固"},{"content":"React 官方教程系列之快速上手篇\nHello World React 官网的 Quick Start 提供了一个在线编辑器 CodePen，里面提供了一个 react 的最小配置示例，即\nReactDOM.render( \u0026lt;h1\u0026gt;Hello, World\u0026lt;/h1\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 这个 js 文件将会把 html 文件渲染出 Hello，World 这个标题\nhtml 文件结构如下\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 接下来将探析 React 应用的构建块部分：元素、组件\n一旦掌握，便可通过碎小的可复用块创造复杂的应用\n关于 React 于 JavaScript 的关系 React 是一个 JavaScript 库（library）\n官网给出的建议是在学习 React 前确保自己的 JavaScript 有所理解，参照另一篇博文Refresh your JavaScript Knowledge\n我们在例子里也用到了一些 ES6 语法。我们试图保守地用它，因为它还近乎崭新，但我们鼓励你熟悉一下箭头函数、类、模板字、let 和 const 语句。你可以使用Babel REPL来检查 ES6 代码编译成什么样\nJSX 介绍 考虑这个变量声明：\nconst element = \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;; 这个搞笑的标签语法既不是一个字符串也不是 HTML\n它叫做 JSX，并且它是 JavaScript 的一种语法拓展。我们推荐你在 React 使用它来描述 UI 看上去应该的样子。JSX 可能使你想起模板语言，但它完全来自 JavaScript 的强大\nJSX 生产 React“元素”。我们将在下一部分探索把它们渲染成 DOM。在下面你会发现 JSX 必备基础来使你开始\n为什么用 JSX React 拥抱渲染逻辑本质上是加上其他的 UI 逻辑这样的事实：事件如何处理，状态如何改变，还有数据如何被准备好用作展示\n不是通过把标记和逻辑放在不同的文件中这样人为的分离技术，取而代之 React 分离聚焦在两个称作组件的松耦合单元（原文：React separates concerns with loosely coupled units called “components” that contain both.）我们会在后面的部分回到组件，但如果你还对于把标记放进 JavaScript 感到不舒服，这段谈话可能会使你信服。\nReact 并不一定要使用 JSX，但大多数人发现这在他们处理 JavaScript 代码中的 UI 时，JSX 像一个可视化目标一样帮到他们。它也允许 React 去展示更多有用的错误和警告信息\n有了这些方法，让我们开始吧！\n在 JSX 中嵌入表达式 你可以在 JSX 中嵌入任何 JavaScript 表达式，通过包裹在大括号内\n例如：2 + 2、user.firstName 和 formatName(user)都是有效的表达式：\nfunction formatName(user) { return user.firstName + \u0026#34; \u0026#34; + user.lastName; } const user = { firstName: \u0026#34;Harper\u0026#34;, lastName: \u0026#34;Perez\u0026#34;, }; const element = \u0026lt;h1\u0026gt;Hello, {formatName(user)}!\u0026lt;/h1\u0026gt;; ReactDOM.render(element, document.getElementById(\u0026#34;root\u0026#34;)); 我们为了可读性把 JSX 拆分成多行。虽然不是必须的，当这样做时，我们还是建议用括号包裹起来以避免自动分号的陷阱\nJSX 也是表达式 在编译之后，JSX 表达式成为常规的 JavaScript 函数调用和评估\n这意味着你可以在 if 语句和 for 循环内使用 JSX，把它赋值给变量，接受它作为参数，还有从函数返回它\nfunction getGreeting(user) { if (user) { return \u0026lt;h1\u0026gt;Hello, {formatName(user)}!\u0026lt;/h1\u0026gt;; } return \u0026lt;h1\u0026gt;Hello, Stranger.\u0026lt;/h1\u0026gt;; } 为 JSX 指定属性 你可能使用引号来指定字符串文字作为属性：\nconst element = \u0026lt;div tabIndex=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;; 你也可能使用花括号来在属性内嵌入 JavaScript 表达式\nconst element = \u0026lt;img src={user.avatarUrl}\u0026gt;\u0026lt;/img\u0026gt;; 当向一个属性内嵌入 JavaScript 表达式时，不要在花括号外加引号。你应该使用引号（对字符串值）或花括号（对表达式），但不应该二者都用于属性\n警告：因为 JSX 比起 HTML 更像 JavaScript，React DOM 使用驼峰属性命名法取代 HTML 属性名称。例如，在 JSX 中，class 变成 className，tabindex 变成 tabIndex\n为 JSX 指定子 如果一个标签是空的，你可能会立即用一个/\u0026gt;关上它，像 XML：\nconst element = \u0026lt;img src={user.avatarUrl} /\u0026gt;; JSX 标签可能包含子：\nconst element = ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello!\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Good to see you here.\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); JSX 避免注入攻击 在 JSX 中嵌入用户输入是安全的\nconst title = response.potentiallyMaliciousInput; const element \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt;; 默认的，React DOM 会在渲染之前转义嵌在 JSX 中的值。从而确保你永远不会注入任何写在你程序里不明确的东西。任何东西都会在渲染之前被转换为字符串。这避免了 XSS 攻击\nJSX 表示对象 Babel 编译 JSX 为 React.createElement()调用\n下面两个例子完全相同：\nconst element = \u0026lt;h1 className=\u0026#34;greeting\u0026#34;\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;; const element = React.createElement( \u0026#34;h1\u0026#34;, { className: \u0026#34;greeting\u0026#34; }, \u0026#34;Hello world\u0026#34; ); React.createElement()实施了一些检查以帮助你写出无缺陷的代码，但会潜在创造一个如下的对象：\nconst element = { type: \u0026#34;h1\u0026#34;, props: { className: \u0026#34;greeting\u0026#34;, children: \u0026#34;Hello, world\u0026#34;, }, }; 这些对象称为 React 元素。你可以把它们当作你想在屏幕上看到的东西的描述。React 读取这些对象并使用它们去构造 DOM 并保持它们为最新的\n我们将会在下个部分探索渲染 React 元素为 DOM\nTip: 我们推荐你为你的编辑器选择使用Babel 语言定义，这样 ES6 和 JSX 就可以正确地高亮显示。（原文此处使用Oceanic Next颜色主题）\n渲染元素 元素是 React 应用最小的构建块\n元素描述了你想在屏幕上看到的东西：\nconst element = \u0026lt;h1\u0026gt;Hello, world\u0026lt;/h1\u0026gt;; 不像浏览器 DOM 元素，React 元素是纯文本对象，并且容易创建。React DOM 关心更新 DOM 以匹配 React 元素\n有人可能会混淆元素一个更广为人知的概念——“组件”。我们将会介绍组件在下一部分。元素是组件的组成部分并且我们鼓励你跳读前阅读组件这个部分\n把元素渲染为 DOM 让我们假设在你的 HTML 文件中的某个地方有一个\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 我们称其为 DOM“根”节点，因为所以其内的节点都受管于 React DOM\n仅用 React 构建的程序经常只有一个唯一的根 DOM 节点。如果你将 React 集成进一个已存在的应用，你可以有尽可能多的孤立的根 DOM\n渲染一个 React 元素为一个根 DOM 节点，通过 ReactDOM.render()：\nconst element = \u0026lt;h1\u0026gt;Hello, world\u0026lt;/h1\u0026gt;; ReactDOM.render(element, document.getElementById(\u0026#34;root\u0026#34;)); 更新渲染的元素 React 元素是一成不变的。一旦你创建一个元素，你无法改变它的子或者属性。元素就像电影中的一帧：它展现了在以一个特定时间点的 UI\n就我们现在所知，更新 UI 的唯一方式是创建一个新的元素，并把它传递给 ReactDOM.render()\n考虑一下这个钟表滴答例子：\nfunction tick() { const element = ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt; It is{\u0026#39; \u0026#39;} {hew Date().toLocaleTimeString()}. \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); ReactDOM.render( element, document.getElementById(\u0026#39;root\u0026#39;) ); } setInterval(tick, 1000); 它从setInterval()的回调函数每秒调用一次 ReactDOM.render()\n实际上，大多数 React 应用只调用一次 ReactDOM.render()。在下一个部分我们将学习怎样把这样的代码装进状态组件。我们推荐你不要跳过话题，因为它们依赖于彼此。\nReact 只更新必要的东西 React DOM 会比较元素及其子元素与前一个状态的对比，只把必要的 DOM 更新为适用于所需的状态\n你可通过使用浏览器工具检查上一个例子来确认\n即使我们每一秒创建一个元素来描述整个 UI 树，但只有内容改变的文本节点通过 React DOM 获得更新\n在我们的实验中，思考 UI 如何根据给出的时刻而不是随着时间的推移进行改变，消除整个类的错误\n组件和 props 组件使你将 UI 分离成独立的部分、可重用的碎片并隔离的考虑每一个碎片\n概念上讲，组件像是 JavaScript 的函数。它们接收任意的输入（称作 props）并返回 React 元素来描述屏幕上发生了什么\n功能组件和类组件 定义一个组件最简单的方式就是写一个 JavaScript 函数：\nfunction Welcome(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}\u0026lt;/h1\u0026gt;; } 这个函数是一个有效的 React 组件，因为它接收了一个伴有数据的单一的 props（表示属性）对象参数并返回了一个 React 元素。我们称这样的组件为函数组件，因为它们字面上是 JavaScript 函数\n你也可以使用一个 ES6 的类来定义一个组件\nclass Welcome extends React.Comoponent { render() { return \u0026lt;h1\u0026gt;Hello, {this.props.name}\u0026lt;/h1\u0026gt; } } 以上两个组件从 React 的角度等价\n类有一些额外特性我们将在接下来的部分讨论。到那时，我们将因其简明性而使用函数组件\n渲染一个组件 先前，我们只遇到 React 元素呈现 DOM 标签：\nconst element = \u0026lt;div /\u0026gt;; 然而，元素也可以呈现用户定义的组件：\nconst element = \u0026lt;Welcome name=\u0026#34;Sara\u0026#34; /\u0026gt;; 当 React 看到一个元素展现一个用户定义的组件时，它作为一个单独的对象传递 JSX 参数给这个组件。我们称这个对象为“props”\n比如，这个代码渲染“你好，Sara”在页面上：\nfunction Welcome(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}\u0026lt;/h1\u0026gt;; } 参考链接：\nhttps://reactjs.org/docs/ https://codepen.io/pen?\u0026amp;editors=0010 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-react-quick-start/","summary":"\u003cp\u003eReact 官方教程系列之快速上手篇\u003c/p\u003e","title":"React教程之快速上手篇"},{"content":"对于 MySQL 误删数据，如何通过二进制日志进行数据查找和恢复\n数据恢复（MySQL 传统方式） 前置条件 MySQL 数据恢复的大前提基于 MySQL 核心配置文件（Linux 下的 my.cnf、Windows 下的 my.ini）中开启了 Binary log——MySQL 四种日志类型（Error log、General Query log、Binary log 和 Slow Query log）之一\n可通过以下命令查看二进制日志相关配置情况\nmysql\u0026gt; show variables like \u0026#39;%log_bin%\u0026#39; 开启方式为在 MySQL 配置文件中的[mysqld]组中添加\nlog-bin[=name] 或者在启动 MySQL 服务时添加启动参数\u0026ndash;log-bin[=name]\n此处 name 为自定义日志文件名，有以下特点：\n是可选项\n即使添加了后缀名，也会被忽略\n可以设置绝对路径\n若不设置，默认项会是 datadir/log-basename-bin 或 datadir/mysql-bin 或者 datadir/mariadb-bin（后两者出现在你未设置 log-basename，然后具体是 mysql-bin 还是 mariadb-bin 决定于你使用的 MySQL 服务器版本），datadir 为你在 MySQL 核心配置文件中设置的数据目录\n官方推荐配置方式：指定 log-basename 或指定 log-bin 的 name 选项，这么做是为了确保当计算机主机名改变时复制（replication）不会受影响而停止（比如发生于主从备份）\n存储二进制日志的目录将会包含一个二进制日志索引文件（包含所有二进制日志文件的有序列表）和二进制日志\n二进制索引文件若不指定名称，会和二进制日志文件使用相同的 name，后缀为 index，也可手动指定其名称，通过\nlog-bin-index[=filename] 进行配置，这也是可选项\n二进制日志文件可通过\nmysql\u0026gt; show binary logs; 进行查看，也可直接进入存储二进制日志文件的目录查看，序号越大的是越新产生的，序号越小的是越老的日志文件\n二进制日志文件的产生于以下三种情况：\nMySQL 每次启动时产生一个新的二进制日志文件\n或者日志被 flush\n或者当前日志文件达到文件设定的容量最大值（max_binlog_size）\nmax_binlog_size 范围为 4K-1G，默认为 1G（但不限于此），当事务比较小时，binlog 在接近 1G 时会 flush，并生成新的 binlog，但同个事务不能跨 binlog 存储，所以当接近 1G 时如果有一个大事务，则产生的日志记录会记录在当前 binlog，并产生大于 1G 的 binlog，当事务执行完之后，才会切换 binlog\n拥有 SUPER 权限的客户端可以停用或者重新启用当前会话的二进制日志文件，通过\nSET sql_log_bin = 0; SET sql_log_bin = 1; 二进制文件主要目的：\n用于复制：二进制文件一般存在于复制宿主机上，作为操作的记录，用于发送给从机（二进制日志很多细节内容都旨在为此服务）。主机向从机发送二进制日志中的操作事件，以使得从机能够执行这些事件保证拥有与主机相同的数据变更\n数据恢复：备份文件恢复后，可通过二进制日志文件找到备份的任一个时间点的数据\n二进制日志文件共有三种格式\nstatement-based（默认）\nrow-based\nmix\n无论日志文件哪种格式，二进制日志都存储以二进制数据而非纯文本，所以一般的文本编辑器无法直接查看（不过 MariaDB 有一个命令行工具 mysqlbinlog 可以将二进制日志处理成纯文本）\n二进制日志通过系统变量binlog_format决定\n可在运行 MySQL 服务时通过添加以下一种参数进行设置\n--binlog-format=STATEMENT --binlog-format=ROW --binlog-format=MIXED 或进行全局配置（需要 SUPER 权限）或进行会话级配置，方式如下：\nSET GLOBAL binlog_format=ROW; SET SESSION binlog_format=MIXED; SET binlog_format=STATEMENT; 查找二进制日志文件 使用以下命令进行相应查找和查看\n查看当前正在写入的 binlog mysql\u0026gt; show master status; 查看 binlog 日志文件列表（所有二进制日志文件） mysql\u0026gt; show binary logs; 查看指定 binlog 文件 mysql\u0026gt; show binlog events in \u0026#39;binlog_name\u0026#39;; 查看第一个 binlog mysql\u0026gt; show binlog events 使用 mysqlbinlog 工具 注意点：\n不要查看正在写入的 binlog\n不要使用\u0026ndash;force 参数强制访问\n若 binlog 格式为行模式，需要加-vv 参数（行模式下 DML 加密存储，使用-v 参数进行解析）\nmysqlbinlog 使用 使用 mysqlbinlog 的方式如下：\nshell\u0026gt; mysqlbinlog [options] log_file 当使用 mysqlbinlog 时，可能会遇到一种情况会提示“unknown variable \u0026lsquo;default-character-set=utf8\u0026rsquo;”，原因是 MySQL 配置文件中[client]组中配置了 default-character-set=utf8，这种情况可通过为 mysqlbinlog 添加\u0026ndash;no-defaults 参数解决\n如果 binlog 格式为 statement（statement 指类似 CREATE、ALTER、INSERT、UPDATE、DELETE 这样的操作，SELECT 和 SHOW 这样的操作将不会被记录），则 mysqlbinlog 看到的日志包括 SQL statament、执行这条 statement 的 severID、时间戳（timestamp）以及执行这个 statement 花费了多少时间\n如果 binlog 格式为 row，则 mysqlbinlog 不会包含 SQL 的 statement，取而代之的是显示每一行数据是如何改变的\nmysqlbinlog 的输出可直接作为对于 mysql 客户端的输入，以重新执行二进制日志中的 statements（用于 MySQL 服务器宕机时作恢复），操作如下：\nshell\u0026gt; mysqlbinlog binlog-file | mysql -u root -p 也可使用如下命令将 mysqlbinlog 的输出重定向（redirect）当其他文件中，进行编辑和修改\nshell\u0026gt; mysqlbinlog -r filename binlog-filename 然后将修改后的文件再向 MySQL 客户端进行输入\nshell\u0026gt; mysql -u root -p \u0026lt; filename 可使用一个数据库连接执行多个日志文件\nshell\u0026gt; mysqlbinlog file1 file2 ... | mssql -u root -p 当同时给一个连接执行多个日志文件时，如果多个日志中包含 CREATE TEMPORARY TABLE 这样的 statement，临时表会在 MySQL 客户端连接终止（terminate）时删掉（drop），所以如果在同一时刻处理多个日志文件，并且其中一个日志文件创建了一个临时表，随后的日志文件连到（refer to）了这个临时表，则会得到“unknown table”错误\n如果需要将多个文件合并为一个文件进行编辑，然后，可如下操作：\nshell\u0026gt; mysqlbinlog master-bin.000001 \u0026gt; /tmp/file.sql shell\u0026gt; mysqlbinlog master-bin.000002 \u0026gt;\u0026gt; /tmp/file.sql shell\u0026gt; mysql -u root -p -e \u0026#34;source /tmp/file.sql\u0026#34; 直接在命令行通过show binlog events查看的 binlog 结构如下\nLog_name Pos Event_type Server_id End_log_pos Info master-bin.000001 4 Format_desc 1 120 Server ver: 5.6.31-log, Binlog ver: 4 master-bin.000001 120 Query 1 209 BEGIN master-bin.000001 209 Query 1 354 use wms_biz_2; DELETE FROM trade_wave_policy WHERE (POLICY_ID=\u0026lsquo;8700007\u0026rsquo;) master-bin.000001 354 Xid 1 385 COMMIT /_ xid=45 _/ master-bin.000001 385 Stop 1 408 \u0026ndash; 而使用 mysqlbinlog 导出的文件结构类似：\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/; /*!40019 SET @@session.max_insert_delayed_threads=0*/; /*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/; DELIMITER /*!*/; # at 4 #180130 19:13:59 server id 1 end_log_pos 120 CRC32 0x870729d1 Start: binlog v 4, server v 5.6.31-log created 180130 19:13:59 at startup ROLLBACK/*!*/; BINLOG \u0026#39; d1NwWg8BAAAAdAAAAHgAAAAAAAQANS42LjMxLWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAB3U3BaEzgNAAgAEgAEBAQEEgAAXAAEGggAAAAICAgCAAAACgoKGRkAAdEp B4c= \u0026#39;/*!*/; # at 120 #180130 19:30:27 server id 1 end_log_pos 209 CRC32 0xad90bdf5 Query\tthread_id=8\texec_time=0\terror_code=0 SET TIMESTAMP=1517311827/*!*/; SET @@session.pseudo_thread_id=8/*!*/; SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/; SET @@session.sql_mode=1075838976/*!*/; SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/; /*!\\C utf8mb4 *//*!*/; SET @@session.character_set_client=45,@@session.collation_connection=45,@@session.collation_server=33/*!*/; SET @@session.lc_time_names=0/*!*/; SET @@session.collation_database=DEFAULT/*!*/; BEGIN /*!*/; # at 209 #180130 19:30:27 server id 1 end_log_pos 354 CRC32 0xa8518d8a Query\tthread_id=8\texec_time=0\terror_code=0 use `wms_biz_2`/*!*/; SET TIMESTAMP=1517311827/*!*/; DELETE FROM `trade_wave_policy` WHERE (`POLICY_ID`=\u0026#39;8700008\u0026#39;) /*!*/; # at 354 #180130 19:30:27 server id 1 end_log_pos 385 CRC32 0xc49f56b6 Xid = 28 COMMIT/*!*/; # at 385 #180130 19:46:24 server id 1 end_log_pos 474 CRC32 0x6b652f60 Query\tthread_id=11\texec_time=0\terror_code=0 SET TIMESTAMP=1517312784/*!*/; BEGIN /*!*/; 数据恢复（ali-RDS） （类似于 Git 或 SVN 的分支管理，只不过这里是对数据库实例进行克隆分支，进行修改，再合并主干）\n进入 RDS 控制台，选择【备份恢复】，点击克隆实例\n选择按时间点进行还原（克隆一份截止到所填时间点的拷贝，即做删除操作之前的时间点）\n克隆出一个新实例，找到误删之前的数据，并恢复到主实例上\n或通过 ali-RDS 的 DMS 进行数据追踪（按条件查询 binlog），找到误删操作的 SQL 进行相应恢复\n参考链接 官方推荐 binlog 启用配置 MySQL 二进制文件格式 MySQL 官方文档 binlog 章节 https://dev.mysql.com/doc/internals/en/binary-log.html mysqlbinlog 可选参数 mysqlbinlog 输出的文件结构 source 命令 http://blog.csdn.net/zdy0_2004/article/details/65629247 阿里云 RDS 怎样恢复误删除的数据 https://xcoder.in/2015/08/10/mysql-binlog-try/ ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-02-01-mysql-data-recovery/","summary":"\u003cp\u003e对于 MySQL 误删数据，如何通过二进制日志进行数据查找和恢复\u003c/p\u003e","title":"mysql误删数据恢复"},{"content":"从理解 pom.xml 探析 Maven\npom 是什么 POM 表示“Project Object Model(工程对象模型)”，同其他对象模型一样，pom 用于表示一个工程的结构。\n在 Maven 工程中以 xml 文件形式呈现，核心文件 pom.xml\n官网的形容是：pom 是关乎工程的“一站式商店（one-stop-store）”，所以对工程的配置仅需一个 pom.xml 文件\n概览 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- The Basics --\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;...\u0026lt;/packaging\u0026gt; \u0026lt;dependencies\u0026gt;...\u0026lt;/dependencies\u0026gt; \u0026lt;parent\u0026gt;...\u0026lt;/parent\u0026gt; \u0026lt;dependencyManagement\u0026gt;...\u0026lt;/dependencyManagement\u0026gt; \u0026lt;modules\u0026gt;...\u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt;...\u0026lt;/properties\u0026gt; \u0026lt;!-- Build Settings --\u0026gt; \u0026lt;build\u0026gt;...\u0026lt;/build\u0026gt; \u0026lt;reporting\u0026gt;...\u0026lt;/reporting\u0026gt; \u0026lt;!-- More Project Information --\u0026gt; \u0026lt;name\u0026gt;...\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;...\u0026lt;/description\u0026gt; \u0026lt;url\u0026gt;...\u0026lt;/url\u0026gt; \u0026lt;inceptionYear\u0026gt;...\u0026lt;/inceptionYear\u0026gt; \u0026lt;licenses\u0026gt;...\u0026lt;/licenses\u0026gt; \u0026lt;organization\u0026gt;...\u0026lt;/organization\u0026gt; \u0026lt;developers\u0026gt;...\u0026lt;/developers\u0026gt; \u0026lt;contributors\u0026gt;...\u0026lt;/contributors\u0026gt; \u0026lt;!-- Environment Settings --\u0026gt; \u0026lt;issueManagement\u0026gt;...\u0026lt;/issueManagement\u0026gt; \u0026lt;ciManagement\u0026gt;...\u0026lt;/ciManagement\u0026gt; \u0026lt;mailingLists\u0026gt;...\u0026lt;/mailingLists\u0026gt; \u0026lt;scm\u0026gt;...\u0026lt;/scm\u0026gt; \u0026lt;prerequisites\u0026gt;...\u0026lt;/prerequisites\u0026gt; \u0026lt;repositories\u0026gt;...\u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt;...\u0026lt;/pluginRepositories\u0026gt; \u0026lt;distributionManagement\u0026gt;...\u0026lt;/distributionManagement\u0026gt; \u0026lt;profiles\u0026gt;...\u0026lt;/profiles\u0026gt; \u0026lt;/project\u0026gt; modelVersion 是必填参数，4.0.0 当前仅支持 Maven2 及 Maven3 版本\n通览整个 pom 文件，分为一下几部分配置：\n基本配置（The Basics）\n构建配置（Build Settings）\n关于工程的更多信息（More Project Information）\n环境配置（Environment Settings）\n基本配置 pom 包含了关于工程的所有必要信息，包括构建过程中所用的插件配置。\n它有效地声明了“who”、“what”和“where”（谁在哪里做了什么）\n与此同时，构建生命周期是“when”和“how”（何时做以及怎么做）\n特别之处 上述的构建生命周期去决定“何时以及如何去做”并不意味着 pom 不能**干涉（影响）**生命周期流\n取而代之的是，它可以\n例如：通过配置 maven-antrun-plugin，可以在 pom 中有效地嵌入 ant 任务\n这最终是一个声明，然而正如 build.xml 在运行时告诉 ant（流程上）准确去做什么，pom 陈述了它（声明上）的配置\n但如果某种外部力量迫使生命周期跳过 ant 插件的执行，Maven 的魔法使得它并不会停止被执行的插件\n这不像 build.xml 的任务几乎总是依赖于执行流上前一个任务的执行\nMaven 坐标 示例：\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/project\u0026gt; 以上是 Maven2 和 Maven3 允许的最小配置\ngroupId:artifactId:version 是都被要求配置的参数（如果继承自父 pom 时，groupId 和 version 则不需要准确定义）\n这三个域对于一个工程扮演了地址和时间戳的角色，这在仓库中标记出一个特定的位置，像是扮演了 Maven 工程中的坐标系统这一角色\ngroupId 这通常对于一个组织或者一个工程是唯一的。例如 Maven 所有的核心组件都存在于 org.apache.maven 这一 groupId 下\ngroupId 不是必须添加“.”符号，比如 junit 工程\n包含“.”符的 groupId 不必和工程所包含的包结构保持一致，但这二者保持一致是一种推荐遵守的最佳实践\n但存储在仓库时，组扮演了操作系统中 java 包结构的角色，“.”符将被操作系统替换为特定的目录分隔符（例如 Unix 中的斜杠符“/”），从而变成一个相对于仓库根目录的相对目录结构。\n在所给例子中，org.codehaus.mojo 组存在于$M2_REPO/org/codehaus/mojo 中\nartifactId artifactId 通常是工程所被知晓的名称\n虽然 groupId 很重要，但是人们在组（group）内的讨论很少提及 groupId（通常都是在相同 ID 的组内，例如 Codehaus Mojo 工程的 groupId:org.codehaus.mojo）\nartifactId 在 groupId 之下对于将这个工程区别于所有其他工程创建了一个键，完整定义了组件在仓库中的住所\n在上例中，即是 my-project 居住在$M2_REPO/org/codehaus/mojo/my-project\nversion 这是命名谜题中的最后一块\ngroupId:artifactId 声明了一个单一的工程，但它没有描述清我们讨论的那个工程是哪一个化身\n我们讨论的是今天的 junit:junit，还是四年前的 junit:junit（第二版）\n简而言之，代码改变了，那些改动应该被版本化\nversion 这个元素在组件线上定义了那些版本改动\n上述这三个元素指出了一个特定的工程版本，使得 Maven 知晓我们在处理哪一个工程，还有何时我们需要它们\npackaging 知道了地址结构 groupId:artifactId:version 之后，还有一个标准标签提供真正完整的地址，那就是工程的组件类型\n上述示例 pom 中定义的 org.codehaus.mojo:my-project:1.0 将被以 jar 格式打包\n当没有 packaging 被声明时，Maven 的默认处理方式是以 jar 包形式打包\n有效类型有：\npom jar maven-plugin ejb war ear rar par 对于一个指定的包结构，这些定义了和构建声明周期阶段所一致的某个默认目标列表 （这句话稍显晦涩，原文：These define the default list of goals which execute to each corresponding build lifecycle stage for a particular package structure）\n你有时会看到 Maven 打印出如下的工程坐标：\ngroupId:artifactId:packaging:version\nclassfier 你可能会在坐标中碰巧发现第五个元素，那就是 classifier\nPOM 关系 Maven 强大的一个方面在于它对工程关系的处理，包括依赖和可传递依赖、继承、聚合（多模块工程）\nMaven 在处理依赖管理这一老生常谈的问题上通过一个本地公共仓库正确处理工程联系及版本问题\n依赖 POM 的基石是其依赖列表，几乎每一个工程都依赖于其他包或工程去正确地实现构建和运行\n当你需要时，Maven 会为你复杂的目标任务下载并关联依赖\ngroupId,artifactId,version 你会经常看到这些元素，这个三元组合用来及时计算针对某个特定工程的 Maven 坐标\n计算的目的是为了选择一个匹配所有依赖声明的版本（由于可传递依赖的存在，对于相同的 artifactId 可以有多依赖声明）\ngroupId,artifactId：直接对应的坐标的依赖\nversion：一个被特指的依赖版本，将被用来计算依赖的有效版本\n因为依赖由 Maven 坐标所描述，你可能会想“这意味着我的工程只能依靠 artifacts”，答案是“当然，但那是好事”，这迫使你去依靠于 Maven 可管理的依赖\n有时可能很不幸，当一个工程不能从中央仓库下载到。比如一个工程依赖于一个遵守闭源协议的 jar 文件，使得你无法从中央仓库下载所得。下面三种方法可以处理：\n使用安装插件进行本地安装这个依赖，这个方法是最简单的推荐方法 mvn install:install-file -Dfile=non-maven-proj.jar -DgroupId=some.group -DartifactId=non-maven-proj -Dversion=1 -Dpackaging=jar 注意这仍需要一个地址，只有这个时候你使用命令行和安装插件会通过你给出的地址创建一个 POM\n创建你自己的仓库并把包部署上去。这对于公司在内部网络是一个令人喜欢的方法，并且需要保持每一个人同步。有一个 Maven 目标叫做 deploy:deploy-file，和 install:install-file 类似\n设置依赖域为 system 并定义一个 systemPath。这不被推荐，然而引出了接下来要解释的元素。\nclassfier classfier 用来区分由相同 POM 构建，但内容不同的 artifacts。这是可选项，并且是任意的字符串，当它呈现时，它附加于 artfact 名称的版本后面\n这个元素的动机是考虑到例如一个工程提供了一个针对 JRE1.5 的 artifact，但与此同时另一个 artifact 仍支持 JRE1.4。这样第一个 artifact 可以用 classfier“jdk15”装配，第二个 artifact 用“jdk14”装配，这样客户端便可以使用哪一个\n另一个 classfiers 的通用用例是对于工程主 artifact 所附加的第二 artifacts。如果你浏览 Maven 中央仓库，会注意到在打包的文件中 sources 分类器和 javadoc 分类器被用于部署工程源码和 API 文档\ntype 和所依赖的 artifact 的 packaging 类型保持一致。默认是 jar。\n它常常展示于依赖文件的名称后缀，但并不总是这样\n类型可以被映射到一个不同的拓展名和分类器\n类型经常和打包所用方式一致，虽然这也不总是这样\n可以通过插件定义新的类型，设置 extensions 为 true，所以这不是一个完整的列表\nscope 这个元素涉及到即将到来的（编译时、运行时、测试时）任务的类路径（classpath），同时也涉及如何限制可传递依赖，共有一下五个域变量：\ncompile：默认域，如果没特别指定，则使用 compile。compile 依赖将在所有的类路径可用，更甚，那些依赖会被传播到从属工程（compile、runtime、test）\nprovided：和 compile 很像，但指明了你想用的 JDK 或者在运行时所提供的容器。仅在编译和测试的类路径可用，并且不可传递（compile、test）\nruntime：这个域指明了这个依赖在编译时不被需要，但被需要于执行时。它存在于运行时和测试的类路径中，不存在与编译类路径（runtime、test）\ntest：这个域指明了依赖在应用的常规使用时不被需要，而仅在测试编译和执行时可用。不可传递（test-compile、test-runtime）\nsystem：这个域和 provided 类似，除非你不得不明确提供所包含的 JAR\nsystemPath 仅被用来当 scope 是 system 时，否则如果这个设置被配置，构建将会失败\n路径必须是绝对路径，所以推荐使用一个 property 去设置指定机器的路径，例如${java.home}/lib\n假定系统域依赖安装一个 priori，Maven 不会为这个工程从仓库检查，取而代之的是去检查那个文件是否存在。如果不存在，，Maven 将会构建失败并建议你手动下载并安装它\noptional 当工程本身是一个依赖时标记可选配置为一个依赖。这困惑吗？举个例子，想象一个工程 A 依赖于工程 B 去编译一部分在运行时不会被使用的代码，然后我们可能没必要对于所有工程都需要工程 B。所以如果工程 X 添加了工程 A 作为它自己的依赖，然后 Maven 将根本不必安装工程 B。用象征性的符号表示，如果=\u0026gt;表示一个需要的依赖，\u0026ndash;\u0026gt;表示可选，虽然情况是 A=\u0026gt;B 可能当构建 A 时，但情况是 X=\u0026gt;A\u0026ndash;\u0026gt;B 当构建 X 时\n简言之，optional 让其他工程知道这样一点，就是当你使用这个工程，你不必需要这个依赖以正确工作\n依赖版本需求指定 依赖的版本元素定义了版本的需求，用来计算有效的依赖版本\n版本需求有如下的语法：\n1.0：软需求，需要 1.0 版本（仅是推荐，如果它匹配了所有其他的范围也可以，例如 1.1 或 0.9） [1.0]：硬需求，指定 1.0 版本 (,1.0)：x \u0026lt;= 1.0 [1.2,1.3]：1.2 \u0026lt;= x \u0026lt;= 1.3 [1.0,2.0)：1.0 \u0026lt;= x \u0026lt; 2.0 [1.5,)：x \u0026gt;= 1.5 (,1.0],[1.2,)：x \u0026lt;= 1.0 or x \u0026gt;= 1.2（多个范围以逗号隔开） (,1.1),(1.1,)：这排除了 1.1（例如知道 1.1 这个版本不能正常工作） 版本顺序指定 Maven 坐标在符号之间以点符(.)和连线符(-)分割，在数字和字符之间以\n分隔符会被记录下来并对顺序产生影响\n数字和字符之间的等同于连字符\n空字符会被替换为 0\n这通过.和-前缀给版本号（数值符）和版本限定符（非数值符号）一个顺序\n实例：\n1-1.foo-bar1baz-.1 -\u0026gt; 1-1.foo-bar-1-baz-0.1\n排除项 exclusions 明确告诉 Maven 你在某个特定工程中某个依赖中不想包含的依赖（换言之，它的传递依赖）\n举个例子，maven-embedder 需要 maven-core，并且我们不想使用它或者它的依赖，随后我们添加一个 exclusion 配置\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; ... \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-embedder\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-core\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; ... \u0026lt;/project\u0026gt; 这有时对于修剪依赖的传递依赖有帮助\n一个依赖可能在某些特定域范围中不正确，或者依赖会与你工程中的其他依赖冲突\n使用通配符排除法可以使得排除一个依赖的所有传递依赖变得简单\n在下面的示例中你可能需要 maven-embedder，并且你想自己管理依赖，所以你修剪了所有的传递依赖\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; ... \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-embedder\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;*\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;*\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; ... \u0026lt;/project\u0026gt; exclusions 包含了一个或多个 exclusion 元素，每一个都包含 groupId 和 artifactId 来指明一个排除的依赖\n不像 optional 会可能或者可能不需要安装和使用，exclusions 将其完全移除出依赖树\n继承 Maven 为构建管理带来的另一个强大力量是工程继承概念\n虽然在构建系统例如 Ant，继承当然可以模拟，Maven 在使得工程继承对于工程对象模型明确上移除了额外的步骤\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;/project\u0026gt; 对父工程和聚合工程（多模块）来说，packaging 类型需要设为 pom\n这些类型定义了绑定到一系列生命周期阶段的目标\n例如，如果 packaging 是 jar，那么 package 将会执行 jar:jar 目标\n如果 packaging 是 pom，被执行的目标将会是 site:attach-descriptor\n现在我们可以向父 pom 中添加值，这些会被其子对象继承，大多数元素会从父 pom 继承到子，包括：\ngroupId version description url inceptionYear organization licenses developers contributors mailingLists scm issueManagement ciManagement properties dependencyManagement dependencies repositories pluginRepositories build plugin executions with matching ids plugin configuration etc. reporting profiles 特别注意一下元素不被继承：\nartifactId name prerequisites \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../my-parent\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;my-project\u0026lt;/artifactId\u0026gt; \u0026lt;/project\u0026gt; 注意 relativePath 元素，是不必须的，但可能会用来作为提供给 Maven 搜索父工程路径的信号，在搜索本地仓库然后远程仓库之前（relativePath -\u0026gt; local repository -\u0026gt; remote repository）\n超类 POM 和面向编程中对象都继承自跟对象类似，POMs 都继承自一个根 POM，此外正如 java 对象最终都继承自 java.lang.Object，所有工程对象模型都继承自一个基类 POM，下面的片段这 Maven3.0.4 的超类 POM\n\u0026lt;project\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;central\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Central Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.maven.apache.org/maven2\u0026lt;/url\u0026gt; \u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;central\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Central Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.maven.apache.org/maven2\u0026lt;/url\u0026gt; \u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;updatePolicy\u0026gt;never\u0026lt;/updatePolicy\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;build\u0026gt; \u0026lt;directory\u0026gt;${project.basedir}/target\u0026lt;/directory\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/classes\u0026lt;/outputDirectory\u0026gt; \u0026lt;finalName\u0026gt;${project.artifactId}-${project.version}\u0026lt;/finalName\u0026gt; \u0026lt;testOutputDirectory\u0026gt;${project.build.directory}/test-classes\u0026lt;/testOutputDirectory\u0026gt; \u0026lt;sourceDirectory\u0026gt;${project.basedir}/src/main/java\u0026lt;/sourceDirectory\u0026gt; \u0026lt;scriptSourceDirectory\u0026gt;src/main/scripts\u0026lt;/scriptSourceDirectory\u0026gt; \u0026lt;testSourceDirectory\u0026gt;${project.basedir}/src/test/java\u0026lt;/testSourceDirectory\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;${project.basedir}/src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;directory\u0026gt;${project.basedir}/src/test/resources\u0026lt;/directory\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;!-- NOTE: These plugins will be removed from future versions of the super POM --\u0026gt; \u0026lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-antrun-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2-beta-5\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-release-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;reporting\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/site\u0026lt;/outputDirectory\u0026gt; \u0026lt;/reporting\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;!-- NOTE: The release profile will be removed from future versions of the super POM --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;release-profile\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;performRelease\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;inherited\u0026gt;true\u0026lt;/inherited\u0026gt; \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;inherited\u0026gt;true\u0026lt;/inherited\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;inherited\u0026gt;true\u0026lt;/inherited\u0026gt; \u0026lt;artifactId\u0026gt;maven-deploy-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;updateReleaseInfo\u0026gt;true\u0026lt;/updateReleaseInfo\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/project\u0026gt; 你可以创建一个最小 pom.xml 来看一下超类 POM 是如何影响你的工程对象模型，并且通过在命令行执行 mvn help:effective-pom\n依赖管理 除了对于顶级元素的继承，父 pom 还有一些元素配置用于子 POMs 和可传递依赖，其中之一是 dependenceManagement\ndependencyManagement dependencyManagement 被 POMs 用来管理贯穿其所有子 pom 的依赖信息\n如果 my-parent 工程使用 dependenceManagement 来定义一个依赖 junit:junit:4.0，然后 POMs 继承自这个 pom，可以设置它们的依赖，仅设置 groupId=junit，artifactId=junit，随后 Maven 会通过父工程为其填充 version 配置。这个方法的收益是显然的。依赖细节可以被设置在一个中央位置，会传播到继承其的 POMs\n注意 artifact 的 version 和 scope 是从传递依赖而组成的，这也被依赖管理部分控制着版本，这会带来意想不到的结果。考虑一个情况，在你的工程中使用两个依赖，dep1 和 dep2。dep2 反过来又使用到 dep1，并需要一个特定的最小版本去运作。如果你使用 dependenceManagement 去指定一个旧版本，dep2 将会被迫使使用旧版本，并失败。\n所以你必须小心检查整个依赖树去避免这种问题\nmvn:dependence:tree 会派上用场\n聚合（或说多模块） 一个包含模块的工程被认为是一个多模块，或说聚合工程。\n模块是这个 POM 列出的工程，同时会被以组的形式执行。一个以 pom 方式进行打包的工程可能聚合构建一组工程清单作为模块，这是相对路径或者那些工程的 POM 文件（原文： An pom packaged project may aggregate the build of a set of projects by listing them as modules, which are relative paths to the directories or the POM files of those projects.）\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;my-project\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;another-project\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;third-project/pom-example.xml\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;/project\u0026gt; 当列出模式时，你不必亲自考虑内部模块的依赖，例如 POM 给出的模块次序是不重要的。Maven 会拓扑地排序模块以使依赖模块总会在依赖其的模块之前被构建（被依赖者总会先构建）\n最后需要注意关于继承和聚合的一点 继承和聚合创造了一个良好的动态操作去控制构建一个单一的、高级的 POM。你将经常看到工程既是父工程，又是聚合工程。例如，整个 Maven 核心运行于一个简单的基 POM——org.apache.maven:maven，所以构建 Maven 工程可以通过一个简单的命令 mvn compile 去执行。\n然而虽然 POM 工程、聚合工程还有父工程都不同并且不应该令人困惑。一个 POM 工程可能会被继承——但不必需要——任何它聚合的模块。相反，一个 POM 工程可能聚合工程而并没有继承自它的工程\n属性 属性是理解 POM 基本元素的最后一块。Maven 属性是占位值，像 Ant 中的属性。它们的值可以被 POM 中任何位置通过${X}所获取到，X 是属性值。或者它们可被用于作为插件默认值，例如：\n\u0026lt;project\u0026gt; ... \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.7\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.7\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;/properties\u0026gt; ... \u0026lt;/project\u0026gt; 它们以五种方式表示：\nenv.X：伴随 env 前缀变量会返回 shell 的环境变量。例如${env.PATH}包含了 PATH 环境变量 注意：Windows 本身环境变量大小写不敏感，但属性是大小写敏感的。换句话说，当在 Windows 的 shell 对于%PATH%和%Path%返回相同的值时，Maven 会区分${env.PATH}和${env.Path}。谈及 Maven2.1.0，环境变量名称被规范化为全大写以保证可靠性\nproject.x：POM 中点符表示的路径会包含和元素值一致的值。例如：1.0可通过${project.version}达到\nsetting.x：setting.xml 中的点符表示的路径包含和元素值相一致的值。例如：false可通过${settings.offline}达到\njava 系统属性：所有的属性可通过 java.lang.System.getProperties()达到作为 POM 属性的变量，例如${java.home}\nx：通过在 POM 中设置的元素。value的值可通过${someVar}获得\n构建设置 在上述给出的 Maven 基本设置之上，有两个元素必须在声明完整的 POM 之前被理解。它们就是 build 元素，就是像声明你工程目录结构和管理插件一样的处理器。还有 reporting 元素，能最大化反映构建元素的报告\n构建 根据 POM 4.0.0 XSD，build 元素被概念上拆分成两部分：一个 BaseBuild 类型包含了 build 元素（project 层级下的顶级构建元素和 profiles 下的构建元素）的通用元素集；还有一个 Build 类型，包含了 BaseBuild 集同时还有更多用于顶级定义的元素。让我们开始分析这二者的通用元素\n注意：这些不同的 build 元素会被以 project build 和 profile build 指明\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; ... \u0026lt;!-- \u0026#34;Project Build\u0026#34; contains more elements than just the BaseBuild set --\u0026gt; \u0026lt;build\u0026gt;...\u0026lt;/build\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!-- \u0026#34;Profile Build\u0026#34; contains a subset of \u0026#34;Project Build\u0026#34;s elements --\u0026gt; \u0026lt;build\u0026gt;...\u0026lt;/build\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/project\u0026gt; BaseBuild 元素集 BaseBuild 恰如其名：在 POM 文件中两个 build 元素之间的基本元素集\n\u0026lt;build\u0026gt; \u0026lt;defaultGoal\u0026gt;install\u0026lt;/defaultGoal\u0026gt; \u0026lt;directory\u0026gt;${basedir}/target\u0026lt;/directory\u0026gt; \u0026lt;finalName\u0026gt;${artifactId}-${version}\u0026lt;/finalName\u0026gt; \u0026lt;filters\u0026gt; \u0026lt;filter\u0026gt;filters/filter1.properties\u0026lt;/filter\u0026gt; \u0026lt;/filters\u0026gt; ... \u0026lt;/build\u0026gt; defaultGoal：如果未给定，则执行的默认目标或时期。如果 goal 被给定，那应该被定义如命令行中的样子（例如 jar:jar）。如果时期被定义也如此（例如 install）\ndirectory：这是构建将会输出其文件的目录，或者 Maven 的说法——构建目标物，这适当地默认设置为${basedir}/target\nfinalName：这是捆绑项目的名称当其最终构建（无文件拓展名，例如 my-project-1.0.jar，此时 finalName 就是 my-project-1.0）。默认是${artifactId}-${version}\nfinalName 这个术语有点用词不当，然而，正如插件构建捆绑项目拥有每一个权利去忽略或修改这个名称（但它们通常不会这么做）。例如：如果 maven-jar-plugins 被配置用于生成一个 jar 并添加一个 test 的 classifier，然后上述定义的实际 jar 将会被构建为 my-project-1.0-test.jar\nfilter：定义*.properties 文件，该文件包含一个属性列表，这个属性列表是用于作为其他接受设置的资源。换句话说，在 filter 文件中被定义的“键值对”在构建时会用实际资源替换掉${name}字符串。上述例子定义了filter/目录下的filter1.properties文件。Maven的默认过滤器目录是${basedir}/src/main/filters/ 资源 build 元素的另一个特征是指定资源存在于你工程的哪里。资源不是代码。它们不被编译，但也是要被绑定进你项目的项或被用作其他理由，比如代码生成\n举个例子：一个 Plexus 工程需要伴随一个存在于 META-INF/plexus 下的 configuration.xml 文件（用来指定对于容器的组件配置信息）去存在。虽然我们仅需要简单地放置这个文件在 src/main/resources/META-INF/plexus，但我们想取而代之的是给予 Plexus 一个它自己的目录 src/main/plexus。为了 JAR 插件能够正确地绑定资源，你需要指定资源类似如下：\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;build\u0026gt; ... \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;targetPath\u0026gt;META-INF/plexus\u0026lt;/targetPath\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;directory\u0026gt;${basedir}/src/main/plexus\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;configuration.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;**/*.properties\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;testResources\u0026gt; ... \u0026lt;/testResources\u0026gt; ... \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; resources：是一个资源元素列表，其中每一个元素描述了去包含什么文件和去哪获得这个文件关联进这个工程\ntargetPath：指定放置构建出的资源所处目录结构。目标路径默认是根目录。对于将被打包进一个 JAR 的资源，一个通常指定的目标路径是 META-INF\nfiltering：值是 true 或者 false，指示出对于这个资源是否使用过滤器。注意，*.properties 过滤器文件不必被定义去过滤——资源也可以使用在 POM 中被默认定义的属性（例如${project.version}），被传递到命令行，通过使用-D 标识（例如-Dname=value）或者通过属性元素准确定义。\ndirectory：这个元素的值定义了资源从哪里找。默认用于构建的目录是${basedir}/src/main/resources\nincludes：一组用于指定在特定目录下被包含进作为资源的文件模式，使用*作为通配符\nexcludes：和 includes 一样的结构，但指定哪些文件被忽略。当 include 和 exclude 产生矛盾时，exclude 生效\ntestResources：这个元素块包含了 testResource 元素。它们的定义类似 resource 元素，但只在 test 时期使用。有一点不同的是一个工程的默认（超 POM 所定义的）测试资源目录是${basedir}/src/test/resources。测试资源不会被部署\n插件 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;build\u0026gt; ... \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;extensions\u0026gt;false\u0026lt;/extensions\u0026gt; \u0026lt;inherited\u0026gt;true\u0026lt;/inherited\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;classifier\u0026gt;test\u0026lt;/classifier\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;dependencies\u0026gt;...\u0026lt;/dependencies\u0026gt; \u0026lt;executions\u0026gt;...\u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 总结 本文源自 apache 官网 Maven 项目的官方文档，本人初读此文档时感觉晦涩难度，难以完整通读。但苦于找不到其他关于 Maven 学习的高质有效资料，遂决定再次“品味”官方文档并作翻译，并借此对官方文档逐行理解，并做此译文，以便后人。部分字句由于鄙人才疏学浅，无法做到准确翻译，伴有原文。翻译不当之处还请指正。\n参考链接：\nhttps://maven.apache.org/pom.html\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-29-about-maven-translation/","summary":"\u003cp\u003e从理解 pom.xml 探析 Maven\u003c/p\u003e","title":"Apache项目Maven官方文档学习及翻译（译）"},{"content":"探析域名\n概念 域名（简称“网域”），与互联网上的一个物理 IP 关联\n是电子邮件地址中@符号之后和网址中 www.之后的唯一名称\n子域名 子域名也是域名，隶属于较大的网域\n例如：mail.google.com、www.google.com和docs.google.com都是域名google.com的子域名\n域名所有者可以创建子域名，为顶级域名下的网页或服务提供简单好记的地址\n裸网域 就是不含“www”前缀的网域地址。例如 google.com，而不是www.google.com\n主域名 所注册的域名，可在账号中添加其他域名\n辅助域名 主域名之外，可为账号添加其他域名，让相应网域中的用户可使用其他服务\n网域别名 可用作其他网域的别名的域名\n可为账号添加一个域名作为网域别名，从而为网域中每位用户提供一个采用该域名别名的电子邮件地址\n发送至用户任一地址的邮件均会递送到用户的同一个电子邮件收件箱\nIP 地址 一个域名可能有一个或多个关联的 IP 地址\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-25-domain/","summary":"探析域名\n概念 域名（简称“网域”），与互联网上的一个物理 IP 关联\n是电子邮件地址中@符号之后和网址中 www.之后的唯一名称\n子域名 子域名也是域名，隶属于较大的网域\n例如：mail.google.com、www.google.com和docs.google.com都是域名google.com的子域名\n域名所有者可以创建子域名，为顶级域名下的网页或服务提供简单好记的地址\n裸网域 就是不含“www”前缀的网域地址。例如 google.com，而不是www.google.com\n主域名 所注册的域名，可在账号中添加其他域名\n辅助域名 主域名之外，可为账号添加其他域名，让相应网域中的用户可使用其他服务\n网域别名 可用作其他网域的别名的域名\n可为账号添加一个域名作为网域别名，从而为网域中每位用户提供一个采用该域名别名的电子邮件地址\n发送至用户任一地址的邮件均会递送到用户的同一个电子邮件收件箱\nIP 地址 一个域名可能有一个或多个关联的 IP 地址","title":"关于域名"},{"content":"探析 DNS\nDNS 概念 Domain Name System，域名系统\n本质 整理和识别各个域名的网络电话簿\n将域名转换为托管该网站的计算机的物理 IP\nMX 记录 概念 Mail Exchange，邮件交换记录\n作用 将一个网域的电子邮件定向到托管该网域用户账号的服务器\n设置 一个网域可定义多条 MX 记录，每条记录有不同的优先级。\n如果邮件通过最高优先级记录无法递送，则采用第二优先级，以此类推\nTXT 记录 作用 为网域之外的来源提供文本信息的一种 DNS 记录\n文本类型 人工可读文本\n机器可读文本\nCNAME 记录 规范名称记录\n作用 将一个别名关联到另一个真正的或规范的域名\nA 记录 地址记录（主机记录），Address\n作用 将一个域名关联到托管该网域服务的计算机的物理 IP\nNS 记录 作用 用于确定哪些服务器为一个网域传达 DNS 信息\n网域通常有主要的和辅助的域名服务器记录\nTTL 生存时间，Time To Live\n作用 决定对该记录所做的后续更改需要多少秒才会生效\n推荐值 3600（即 1 个小时）\n让整个互联网中的服务器每小时检查一次该记录的更新情况\n原因 较短的 TTL 在之前的有效期到期后才会生效\n若想快速还原一项更改，则可设置较短的 TTL 值（如 300,5 分钟）\n合理配置 正确配置后，建议设置 TTL 为 86400，即让整个互联网中的服务器每 24 小时检查一次记录的更新情况\n注意 不要在 DNS 设置中使用实际域名，而是使用@符号表示域名\n参考链接\nhttps://support.google.com/a/answer/48090?hl=zh-Hans https://support.dnsimple.com/articles/differences-between-a-cname-alias-url/ ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-25-dns/","summary":"探析 DNS\nDNS 概念 Domain Name System，域名系统\n本质 整理和识别各个域名的网络电话簿\n将域名转换为托管该网站的计算机的物理 IP\nMX 记录 概念 Mail Exchange，邮件交换记录\n作用 将一个网域的电子邮件定向到托管该网域用户账号的服务器\n设置 一个网域可定义多条 MX 记录，每条记录有不同的优先级。\n如果邮件通过最高优先级记录无法递送，则采用第二优先级，以此类推\nTXT 记录 作用 为网域之外的来源提供文本信息的一种 DNS 记录\n文本类型 人工可读文本\n机器可读文本\nCNAME 记录 规范名称记录\n作用 将一个别名关联到另一个真正的或规范的域名\nA 记录 地址记录（主机记录），Address\n作用 将一个域名关联到托管该网域服务的计算机的物理 IP\nNS 记录 作用 用于确定哪些服务器为一个网域传达 DNS 信息\n网域通常有主要的和辅助的域名服务器记录\nTTL 生存时间，Time To Live\n作用 决定对该记录所做的后续更改需要多少秒才会生效\n推荐值 3600（即 1 个小时）\n让整个互联网中的服务器每小时检查一次该记录的更新情况\n原因 较短的 TTL 在之前的有效期到期后才会生效\n若想快速还原一项更改，则可设置较短的 TTL 值（如 300,5 分钟）","title":"关于DNS"},{"content":"linux 作为开源系统，有着众多的发行版本（毕竟有着庞大的社区和狂热的爱好者），不同的发行版本(Linux Distribution)随着发展，在使用方式上也有一些不同，例如各自的包管理器、已经适用场景等等。借此整理一下 linux 的不同发行版本，以便在使用不同版 linux 时不至混乱。\n大致分类 商业发行版\nUbuntu(Canonical 公司) Fedora(RedHat) openSUSE(Novell) Mandriva Linux 社区发行版\nDebian Gentoo 既不是商业发行版也不是社区发行版\nLinux Distrubutions\nLinux 桌面发行版组成 Linux 内核 GNU 工具\u0026amp;库 附加软件、文档 窗口系统 窗口管理器 桌面环境 开源软件包 二进制可执行文件 源代码发布方式（支持修改和重新编译） 定制发行版镜像 Gentoo Linux 内核 T2 Linux From Scratch 提供：\n所有软件的源代码 基本内核 编译器 定制工具 安装工具 软件包管理系统 发行版通常被分区成软件包，每个软件包包含一个特定的软件或服务\n软件包 软件包通常是已编译的机器码，由软件包管理器安装和卸载\n软件包组成 元数据：软件描述、版本、依赖（提供给软件包管理器以使用元数据进行搜索、自动更新到最新版本、自动解决依赖） 常见软件包格式 deb——Debian rpm——Fedora(Red Hat) 流行的发行版 基于 Dpkg(Debian 系) 商业发行版 Ubuntu（流行的桌面发行版，由 Canonical 维护） 社区发行版 Debian（强烈信奉自由软件，由志愿者维护） Kubuntu（使用 KDE 桌面的 Ubuntu） Linux Mint（由 Ubuntu 派生，与 Ubuntu 兼容） OpenGEU（Ubuntu 派生） Elementary OS（基于 Ubuntu，形似 Mac OS X） gOS 及其他 基于 RPM（Red Hat 系） 商业发行版 Red Hat Enterprise Linux（Fedora 的商业版，由 Red Hat 维护） Mandriva（最初派生自 Red Hat，现由法国同名公司维护） openSUSE（最初由 Slackware 分离出，现由 Novell 维护） 社区发行版 Fedora（Red Hat 社区版，会引入新特性测试） PCLinuxOS（Mandriva 派生版） CentOS（Red Hat 发展而来，由志愿者维护，旨在提供开源，与 Red Hat 完全兼容） 基于其他包格式 ArchLinux（基于 KISS——Keep It Simple and Stupid 的滚动更新的操作系统） Chakra（由 ArchLinux 派生，只是用 KDE 桌面的半滚动更新发行版） Gentoo（面向高级用户，所有软件源代码需自行编译） Slackware（最早发行版之一，1993 年创建，由Patrick Volkerding维护） 参考链接\nhttps://zh.wikipedia.org/wiki/Linux%E5%8F%91%E8%A1%8C%E7%89%88 distrowatch ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-25-linux-distributions/","summary":"linux 作为开源系统，有着众多的发行版本（毕竟有着庞大的社区和狂热的爱好者），不同的发行版本(Linux Distribution)随着发展，在使用方式上也有一些不同，例如各自的包管理器、已经适用场景等等。借此整理一下 linux 的不同发行版本，以便在使用不同版 linux 时不至混乱。\n大致分类 商业发行版\nUbuntu(Canonical 公司) Fedora(RedHat) openSUSE(Novell) Mandriva Linux 社区发行版\nDebian Gentoo 既不是商业发行版也不是社区发行版\nLinux Distrubutions\nLinux 桌面发行版组成 Linux 内核 GNU 工具\u0026amp;库 附加软件、文档 窗口系统 窗口管理器 桌面环境 开源软件包 二进制可执行文件 源代码发布方式（支持修改和重新编译） 定制发行版镜像 Gentoo Linux 内核 T2 Linux From Scratch 提供：\n所有软件的源代码 基本内核 编译器 定制工具 安装工具 软件包管理系统 发行版通常被分区成软件包，每个软件包包含一个特定的软件或服务\n软件包 软件包通常是已编译的机器码，由软件包管理器安装和卸载\n软件包组成 元数据：软件描述、版本、依赖（提供给软件包管理器以使用元数据进行搜索、自动更新到最新版本、自动解决依赖） 常见软件包格式 deb——Debian rpm——Fedora(Red Hat) 流行的发行版 基于 Dpkg(Debian 系) 商业发行版 Ubuntu（流行的桌面发行版，由 Canonical 维护） 社区发行版 Debian（强烈信奉自由软件，由志愿者维护） Kubuntu（使用 KDE 桌面的 Ubuntu） Linux Mint（由 Ubuntu 派生，与 Ubuntu 兼容） OpenGEU（Ubuntu 派生） Elementary OS（基于 Ubuntu，形似 Mac OS X） gOS 及其他 基于 RPM（Red Hat 系） 商业发行版 Red Hat Enterprise Linux（Fedora 的商业版，由 Red Hat 维护） Mandriva（最初派生自 Red Hat，现由法国同名公司维护） openSUSE（最初由 Slackware 分离出，现由 Novell 维护） 社区发行版 Fedora（Red Hat 社区版，会引入新特性测试） PCLinuxOS（Mandriva 派生版） CentOS（Red Hat 发展而来，由志愿者维护，旨在提供开源，与 Red Hat 完全兼容） 基于其他包格式 ArchLinux（基于 KISS——Keep It Simple and Stupid 的滚动更新的操作系统） Chakra（由 ArchLinux 派生，只是用 KDE 桌面的半滚动更新发行版） Gentoo（面向高级用户，所有软件源代码需自行编译） Slackware（最早发行版之一，1993 年创建，由Patrick Volkerding维护） 参考链接","title":"linux发行版理解"},{"content":"关于安装 TensorFlow 的一系列准备\n前期准备 tensorflow 官方推荐安装是通过 pip 安装的，先来看看 pip 是什么\npip 本质 包安装器\n类似工具 linux 的 rpm(RPM Package Manager，递归写法，类似于 GNU——GNU\u0026rsquo;s Not Unix) nodejs 的 npm(node package manager) java 的 Maven(严谨来说，PyPI 相当于 Maven，包社区) Conda(由 Python 编写，语言无关的跨平台包管理器) Anaconda(本身一个 python 数据科学平台，同时是一个平台无关的包管理器、环境管理器) 名称解释 pip 的解释应该是 Python Install Package 或者 Package Index for Python(个人猜测，暂未找到官方解释)\n因为通过 pip 为 python 安装包时的用法是\npip install some-package 具体行为 去 PyPI（Python Package Index）下载相关包\n安装 预安装情况 装有大于等于 2.7.9 或 3.4 版本的 python，已预装\n使用通过 virtualenv 或者 pyvenv 创建的虚拟环境，已预装\n手动安装 下载get-pip.py文件并如下安装\npython get-pip.py 这种方式需要注意和其他包管理器的冲突，导致不一致情况\n附加下载 get-pip.py 同时会安装 setuptools 和 wheel\n如果不需要这两者，可通过添加参数来跳过其安装\npython get-pip.py --no-index --no-wheel linux 包安装方式 Fedora Fedora21\nsudo yum install python-pip Fedora22\nsudo dnf install python-pip CentOS/RHEL EPEL 6 and EPEL 7\nsudo yum install python-pip openSUSE sudo zypper install python-pip Debian/Ubuntu sudo apt-get install python-pip Arch linux sudo pacman -S python2-pip sudo pacman -S python-pip 升级 linux or macOS pip install -U pip Windows python -m pip install -U pip 通过虚拟机安装运行 tensorflow 安装 pip install tf-nightly 运行 参考链接\nInstalling pip/setuptools/wheel with Linux Package Managers pip installation PyPI ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-25-tensorflow-install/","summary":"关于安装 TensorFlow 的一系列准备\n前期准备 tensorflow 官方推荐安装是通过 pip 安装的，先来看看 pip 是什么\npip 本质 包安装器\n类似工具 linux 的 rpm(RPM Package Manager，递归写法，类似于 GNU——GNU\u0026rsquo;s Not Unix) nodejs 的 npm(node package manager) java 的 Maven(严谨来说，PyPI 相当于 Maven，包社区) Conda(由 Python 编写，语言无关的跨平台包管理器) Anaconda(本身一个 python 数据科学平台，同时是一个平台无关的包管理器、环境管理器) 名称解释 pip 的解释应该是 Python Install Package 或者 Package Index for Python(个人猜测，暂未找到官方解释)\n因为通过 pip 为 python 安装包时的用法是\npip install some-package 具体行为 去 PyPI（Python Package Index）下载相关包\n安装 预安装情况 装有大于等于 2.7.9 或 3.4 版本的 python，已预装","title":"谷歌机器学习开源框架Tensorflow安装相关"},{"content":"每次安装虚拟机都忘记怎么安装 vmware tools，而不安装这个东西，用起来总是各种蹩脚，故做此整理。\n背景 虚拟机屏幕不能自适应大小，虽然 vmware 有相关设置，但貌似不能符合使用要求，因此仍需要安装 vmware tools（感觉甚至像一个补丁）来完善 vmware 的使用，比如与宿主机的文件传输等。\n安装前提 VMware Tools 使用 Perl 编写，所以需要装有 Perl\n操作步骤（以 Ubuntu 为例） 从 VMware 菜单栏中选择“安装 VMware Tools” 找到 VMware Tools 安装文件（后缀为 tar.gz 的压缩文件） 打开终端，切换至 root 用户 sudo su 检查是否自动装载 VMware Tools 虚拟 CD-ROM 映像 若已装载 CD-ROM 设备，则列出 CD-ROM 设备及其装载点\nmount df 若未装载，则需安装 CD-ROM 驱动器\n检查装载点目录 可能在/mnt/cdrom 或/media/VMware Tools(例如本例)\n若不存在装载点目录则创建 mkdir /mnt/cdrom 装载 CD-ROM 驱动器 mount /dev/cdrom /mnt/cdrom 某些 Linux 发行版使用不同的设备名称，或以不同的方式组织/dev 目录，若 CD-ROM 驱动器不是/dev/cdrom 或 CD-ROM 装载点不是/mnt/cdrom，则需根据实际情况进行装载\n转到工作目录，例如/tmp\n安装 VMware Tools 前，应删除以前的 vmware-tools-distrib 目录\n解压安装包（若直接解压可能会失败，因为这里解压会创建 vmware-tools-distrib 目录，而当前路径为只读，不允许 mkdir）\n所以需要将 VMware Tools 拷贝到其他目录再解压\n可看到成功解压\n进入解压后的软件目录并安装\n安装完成\nBingo! Well done！\n接下来就可以使用 VMware 一系列拓展功能了（可能需要重新启动虚拟机以使设置生效）\n如需要安装后卸载 CD-ROM 镜像，则执行以下命令（若 Linux 自动装载 CD-ROM 则无需卸载，在安装成功后会自动卸载） umount /dev/cdrom 参考链接：\nhttps://docs.vmware.com/cn/VMware-Workstation-Pro/12.0/com.vmware.ws.using.doc/GUID-08BB9465-D40A-4E16-9E15-8C016CC8166F.html ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-25-vmware-tools-install/","summary":"每次安装虚拟机都忘记怎么安装 vmware tools，而不安装这个东西，用起来总是各种蹩脚，故做此整理。\n背景 虚拟机屏幕不能自适应大小，虽然 vmware 有相关设置，但貌似不能符合使用要求，因此仍需要安装 vmware tools（感觉甚至像一个补丁）来完善 vmware 的使用，比如与宿主机的文件传输等。\n安装前提 VMware Tools 使用 Perl 编写，所以需要装有 Perl\n操作步骤（以 Ubuntu 为例） 从 VMware 菜单栏中选择“安装 VMware Tools” 找到 VMware Tools 安装文件（后缀为 tar.gz 的压缩文件） 打开终端，切换至 root 用户 sudo su 检查是否自动装载 VMware Tools 虚拟 CD-ROM 映像 若已装载 CD-ROM 设备，则列出 CD-ROM 设备及其装载点\nmount df 若未装载，则需安装 CD-ROM 驱动器\n检查装载点目录 可能在/mnt/cdrom 或/media/VMware Tools(例如本例)\n若不存在装载点目录则创建 mkdir /mnt/cdrom 装载 CD-ROM 驱动器 mount /dev/cdrom /mnt/cdrom 某些 Linux 发行版使用不同的设备名称，或以不同的方式组织/dev 目录，若 CD-ROM 驱动器不是/dev/cdrom 或 CD-ROM 装载点不是/mnt/cdrom，则需根据实际情况进行装载","title":"虚拟机vmware使用——安装vmware-tools"},{"content":"继设计模式学习笔记（上）\n15 抽象工厂模式 场景 不同数据库在 SQL 的具体实现上有差距，若存在系统中使用 SQL 语句上过多的使用专门的某种数据库的 SQL 语句，在迁移数据库时，会导致很多 SQL 在新的数据库中不能运行。\n解决 使用原生 SQL 语句\n实例 class User { private int _id; public int ID { get {\treturn _id;\t} set {\t_id = value; } } private string _name;; public string Name { get {\treturn _name; } set { _name = value; } } } 模式解释 工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类\n效果 由于多态的存在，声明 User 接口的对象事先不知道在访问哪个数据库，却可以在运行时正常，达到业务逻辑与数据访问解耦\n抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类\n实际使用步骤 先通过抽象工厂创建一个具体工厂，再通过具体工厂生产特定实现的产品对象\n即为创建不同的产品对象，应使用不同的具体工厂\n抽象工厂优缺点分析 优点：\n易于交换产品系列：具体工厂类在一个应用中只需要在初始化时出现一次，使得改变一个应用的具体工厂变得容易，只需要改变具体工厂即可使用不同的产品配置\n让具体的创建实例过程与客户端分离：客户端通过抽象接口操纵实例，产品的具体类名被具体工厂的实现分离，不会出现在客户端代码中\n缺点：\n增加一个表，需要增加三个类，并更改三个工厂类才能完全实现\n抽象工厂改进 使用简单工厂\n去除三个抽象工厂，使用一个简单工厂，根据条件判断工厂类型去实例不同的具体工厂\n反射+抽象工厂的数据访问程序 去某个地方找应该要实例化的类是哪一个——依赖注入（本需要专门的 IOC 容器提供，例如 Spring）\n常规写法：\nIUser result = new SqlserverUser(); 反射写法：\nIUser result = (IUser)Assembly.Load(\u0026#34;抽象工厂模式\u0026#34;).CreateInstance(\u0026#34;抽象工厂模式.SqlserverUser\u0026#34;); 差别：原来的实例化写死在程序里，而通过反射可以利用字符串实例化对象，变量可以更换（实例化由编译时转为运行时）\n反射+配置文件实现数据访问程序 使用读取配置文件的方式来决定要实例化的数据库访问类\n利用反射解决了数据库访问时的可维护、可拓展问题\n在使用简单工厂的地方，都可以考虑使用反射来去除条件判断，解除分支判断带来的耦合\n16 状态模式 背景 方法过长（Long Method）极有可能有坏味道\n面向对象设计希望做到代码的责任分解\n概念解释 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类\n应用场景 主要解决当控制一个对象状态转换的条件表达式过于复杂时，把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化\n优缺点分析 优点：\n将与特定状态相关的行为局部化，并将不同状态的行为分割开 将特定的状态相关的行为放入一个对象中，由于所有与状态相关的代码都存在于某个类中，所以通过定义新的子类可以容易地增加新的状态和转换\n目的 消除庞大的条件分支语句（大的分支判断会难以修改和拓展）\n状态模式通过把各种状态转移逻辑分部到 State 的子类之间，来减少相互间的依赖\n使用场景 当一个对象的行为取决于其状态，并且必须在运行时根据状态改变其行为\n17 适配器模式 概念 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\n实例 电源适配器：可以将任意伏的电转换成需要的电压\n软件应用场景 系统的数据和行为都正确，但接口不符时，考虑使用适配器。\n目的是使控制范围外的一个原有对象与某个接口匹配。\n主要应用于希望复用现存的类，但接口与复用环境要求不一致的情况\n类型（GoF 中的分类） 类适配器模式\n对象适配器模式\n类适配器通过多重继承对一个接口与另一个接口进行匹配，但 C#、VB.NET、Java 等不支持多重继承（C++支持），此处讲对象适配器\n使用时机 使用一个已存在的类，如果其接口（方法）和要求不符，则考虑使用适配器\n两个类所做事情相同或相似，但具有不同的接口要使用它时，客户端可以统一调用同一接口，这样更简单、直接、紧凑\n18 备忘录模式 概念解析 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态\n适用场景 用于功能比较复杂，但需维护或记录属性历史的类，或需要保存的属性只是众多属性中的一小部分时，Originator(发起者)可根据保存的 Memento(备忘录)信息还原到前一状态\n备忘录类 使用备忘录可以将复杂的对象内部信息对其他对象屏蔽起来，从而恰当地保持封装的边界\n使用注意点 角色状态需要完整存储到备忘录对象中，如果状态数据很大很多，在资源消耗上，备忘录对象会很耗内存\n19 组合模式 概念解析 将对象组合成树形结构以表示“部分——整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性\n方式 透明方式\n在 Component 中声明所有用来管理子对象的方法，其中包括 add、remove 等，这样实现 Component 接口的所有子类都具备了 add、remove。好处是叶节点和枝节点对于外界没有区别，完全具备一致的行为接口。缺点是 Leaf 类本身不具备 add、remove 方法的功能，实现其没有意义\n安全方式\n在 Component 接口中不声明 add、remove 方法，子类的 Leaf 不需要实现其，而在 Component 声明所有用来管理子类的对象，不过由于不够透明，所以叶和枝类将不具有相同接口，客户端调用需要做相应判断，带来不便\n适用场景 需求中体现部分与整体层次的结构时，及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象\n优势 基本对象可以被组合成更复杂的组合对象，而组合对象又可以被组合，不断递归，客户端代码任何用到基本对象的地方都可以使用组合对象\n用户不用关心到底是处理一个叶节点还是处理一个组合组件，不用为定义组合而写选择判断语句（可以一致地使用组合结构和单个对象）\n20 迭代器模式 概念解析 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示\n内部原理 迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据\n21 单例模式 实现关键点 构造方法私有化，使得外部不能通过 new 来获得实例对象 向外部提供静态（因为外部无法获得该类对象去调用其方法）公有方法获得实例，内部实现单例控制 声明静态类变量，用来存放实例化出的对象 概念解析 保证一个类只有一个实例，并提供一个访问它的全局访问点\n通常我们可以让一个全局变量使得一个对象被访问，但不能防止实例化多个对象。最好的方法是让类自身负责保存它的唯一实例，这个类可保证没有其他实例可以被创建，并且它提供一个访问该实例的方法\n优势分析 单例模式因为 Singleton 类封装它的唯一实例，这样它可以严格控制客户怎样访问它及何时访问它。对唯一实例的受控访问\n多线程时的单例 给进程一把锁，lock 是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（被阻止），直至该对象被释放\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-24-design-pattern-02/","summary":"继设计模式学习笔记（上）\n15 抽象工厂模式 场景 不同数据库在 SQL 的具体实现上有差距，若存在系统中使用 SQL 语句上过多的使用专门的某种数据库的 SQL 语句，在迁移数据库时，会导致很多 SQL 在新的数据库中不能运行。\n解决 使用原生 SQL 语句\n实例 class User { private int _id; public int ID { get {\treturn _id;\t} set {\t_id = value; } } private string _name;; public string Name { get {\treturn _name; } set { _name = value; } } } 模式解释 工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类\n效果 由于多态的存在，声明 User 接口的对象事先不知道在访问哪个数据库，却可以在运行时正常，达到业务逻辑与数据访问解耦\n抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类\n实际使用步骤 先通过抽象工厂创建一个具体工厂，再通过具体工厂生产特定实现的产品对象","title":"设计模式学习笔记（下）"},{"content":"关于 Java 设计模式的学习\n继承 两个类之间是 is-a 的关系可以考虑用继承 而两个类之间是 has-a，表示某个角色具有某一项责任，不适合用继承 例如：飞机场有飞机，但是飞机不能去继承飞机场\n多态 多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行\n特点：（子替父演戏实例）\n子类以父类身份出现 子类在工作时以自己的方式实现 子类以父类身份出现时，子类特有的属性和方法不可以使用 多态原理 当方法被调用时，无论对象是否被转换成其父类，都只有位于对象继承最末端的方法实现会被调用。 即父类的抽象方法是按照其运行时类型而非编译时类型进行动态绑定调用的\n抽象类 不能实例化 抽象方法必须被子类重写 若类包含抽象方法，则类必须定义为抽象类 总结：抽象类代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的。\n在一个继承关系树里，树叶节点应为具体类，树枝节点均应为抽象类。\n例如：动物是抽象类，猫是具体类，而当猫划分品种时，比如包含金丝猫和其他品种，那猫应该是树枝，也应是抽象类。\n接口 接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。\n一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。\n声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式（没有具体实现）\n所以接口不能实例化、不能有构造方法和字段、不能有修饰符、不能声明为抽象的或静态的\n实现接口的类必须实现接口中所有方法和属性\n区分抽象类和接口 抽象 类是对对象的抽象\n抽象类是对类的抽象\n接口是对行为的抽象\n对象是否有相似关联 若行为跨越不同类的对象，可使用接口\n对于相似的类对象，用继承抽象类\n设计角度 抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类\n接口根本不知道子类的存在，方法如何实现不确认，预先定义\n通过重构改善既有代码的设计 所有抽象类往往通过重构得来\n面向对象设计（OOD） 可维护\n可复用\n可拓展\n灵活性好\nUML 关联\n聚合（弱拥有）：A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分\n组合（强拥有）：严格的整体与部分的关系\n依赖\n简单工厂 用单独的类考虑创造实例的过程\n策略模式 官方定义 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。\n解释 所有的算法完成相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。\n优势 另外策略模式简化了单元测试，因为每个算法有独立的类，可以通过自己的接口单独测试。\n使用场景 当不同的行为堆砌在一个类中时，很难避免使用条件语句来选择合适的行为。将这些行为进行封装在一个个独立的 Strategy 类中，就可以在使用这些行为的类中消除条件语句。\n策略模式结合简单工厂模式 在基本策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的对象。\n当策略与简单工厂结合，选择的具体实现也可以由 Context 来承担，最大化减轻客户端职责。\n单一职责 官方定义 就一个类而言，应该仅有一个引起它变化的原因。\n背景 若一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。\n这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n实例 手机承担多职责\n谷歌将一切需求整合到一个文本框\n开放-封闭原则（The Open-Closed Principle,开闭原则 OCP） 实例\n不能修改，但可以扩展的一国两制\n特点 Open for extension 对扩展开放\nClosed for modification 对更改封闭\n实例\n早到早下班，晚到晚下班，对业绩成效修改关闭，对时间制度拓展开放的弹性工作制\n依赖-倒转原则 官方定义 抽象不应该依赖细节，细节应该依赖于抽象。\n解释 针对接口编程，不针对实现编程。\n原则 高层模块不应该依赖低层模块，两个都应该依赖抽象\n抽象不应该依赖细节，细节应该依赖抽象\n里氏代换原则 解释 一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。\n即把父类替换成其子类，程序的行为没有变化。\n简言之 子类型必须能够替换掉它们的父类型\n依赖倒转与面向对象 依赖倒转是面向对象设计的标志，若编写程序时考虑如何针对抽象编程而不是针对细节编程。\n即程序中所有依赖关系都终止于抽象类或者接口，即是面向对象设计，反之则是过程化设计。\n装饰模式（Decorator） 实例 Avatar 系统（个人形象系统）\n官方定义 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活\n使用场景 把每个要装饰的功能放在单独的类，并用这个类包装要修饰的对象。\n可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象。\n优势 把类中的装饰功能从类中移除，简化原有类\n有效把类的核心职责和装饰功能区分开，去除相关类中重复的装饰逻辑\n代理模式 GOF 解释 为其他对象提供一种代理以控制对这个对象的访问\n应用场景 远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。\n虚拟代理，根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。（达到性能最优化）\n安全代理，用来控制真实对象访问时的权限\n智能指引，当调用真实的对象时，代理处理另外一些事\n例如：\n计算真实对象的引用次数，当该对象没有引用时可以自动释放它\n当第一次引用一个持久化对象时，将它装入内存\n在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。\n以上都是通过代理在访问一个对象时附加一些内务处理\n工厂方法模式 定义 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工方法使一个类的实例化延迟到其子类。\n与简单工厂的关系 实现对修改关闭，对拓展开放，符合开闭原则 依赖倒置，依赖抽象而非依赖实现 实现特点 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类。\n工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。\n原型模式 定义 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象\n解释 从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节\n使用场景 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。\n既隐藏了对象创建的细节，又对性能大大提高（省去调用构造方法的时间）\n优势 不用重新初始化对象，而是动态地获得对象运行时的状态\n浅复制和深复制 浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有对其他对象的引用都仍然指向原来的对象。\n深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。\n模板方法 使用场景 既然使用继承，并且肯定这个继承有意义，就应该成为子类的模板，所有重复的代码都应该上升到父类，而非每个子类都去重复。\n当要完成在某一个细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，通常考虑用模板方法处理。\n官方定义 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n迪米特法则（最少知道原则） 官方定义 如果两个类不必彼此通信，那么这两个类就不应单发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。\n解释 迪米特法则首先强调的前提是类的结构设计上，每一个类都应当尽量降低成员的访问权限。\n即一个类包装好自己的私有状态，不需要让别的类知道的字段或行为就不要公开。\n类之间的耦合越弱，越有利于复用。一个处在若耦合的类被修改，不会对有关系的类造成波及。\n实例 公司办事找负责人\n外观模式 Facade（门面模式） 官方定义 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n特点 完美体现依赖倒转原则和迪米特法则\n使用场景 设计初期，有意识地将不同的两个层分离\n开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少它们之间的依赖\n在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了。为新系统开发一个外观 Facade 类，来提供设计粗糙或高度复杂的遗留代码的比较清晰的接口，让新系统与 Facade 对象交互，Facade 与遗留代码交互所有复杂的工作。\n建造者模式（生成器模式） 讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n使用场景 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方法时适用的模式。\n观察者模式(发布-订阅模式，Publish/Subscribe) 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n背景 将一个系统分隔成一系列相互协作的类有一个很不好的副作用，就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、拓展和重用都带来不便。\n使用场景 当一个对象的改变需要同时改变其他对象，而且不知道具体有多少对象有待改变。\n一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。\n委托方法 解释 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。\n委托方法的使用可以像其他任何方法一样，具有参数和返回值。\n委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-24-design-pattern-01/","summary":"关于 Java 设计模式的学习\n继承 两个类之间是 is-a 的关系可以考虑用继承 而两个类之间是 has-a，表示某个角色具有某一项责任，不适合用继承 例如：飞机场有飞机，但是飞机不能去继承飞机场\n多态 多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行\n特点：（子替父演戏实例）\n子类以父类身份出现 子类在工作时以自己的方式实现 子类以父类身份出现时，子类特有的属性和方法不可以使用 多态原理 当方法被调用时，无论对象是否被转换成其父类，都只有位于对象继承最末端的方法实现会被调用。 即父类的抽象方法是按照其运行时类型而非编译时类型进行动态绑定调用的\n抽象类 不能实例化 抽象方法必须被子类重写 若类包含抽象方法，则类必须定义为抽象类 总结：抽象类代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的。\n在一个继承关系树里，树叶节点应为具体类，树枝节点均应为抽象类。\n例如：动物是抽象类，猫是具体类，而当猫划分品种时，比如包含金丝猫和其他品种，那猫应该是树枝，也应是抽象类。\n接口 接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。\n一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。\n声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式（没有具体实现）\n所以接口不能实例化、不能有构造方法和字段、不能有修饰符、不能声明为抽象的或静态的\n实现接口的类必须实现接口中所有方法和属性\n区分抽象类和接口 抽象 类是对对象的抽象\n抽象类是对类的抽象\n接口是对行为的抽象\n对象是否有相似关联 若行为跨越不同类的对象，可使用接口\n对于相似的类对象，用继承抽象类\n设计角度 抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类\n接口根本不知道子类的存在，方法如何实现不确认，预先定义\n通过重构改善既有代码的设计 所有抽象类往往通过重构得来\n面向对象设计（OOD） 可维护\n可复用\n可拓展\n灵活性好\nUML 关联\n聚合（弱拥有）：A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分\n组合（强拥有）：严格的整体与部分的关系\n依赖\n简单工厂 用单独的类考虑创造实例的过程\n策略模式 官方定义 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。\n解释 所有的算法完成相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。\n优势 另外策略模式简化了单元测试，因为每个算法有独立的类，可以通过自己的接口单独测试。","title":"设计模式学习笔记（上）"},{"content":"探析浏览器访问站点这一行为背后的具体行为。\n浏览器地址栏输入网址www.coder.com\n浏览器发送一个 UDP 包给 DNS 服务器\nDNS 服务器返回 coder.com 的 IP\n（optional）浏览器将该 IP 缓存起来，以提高下次访问速度（Chrome 通过 chrome://net-internals/#dns 查看）\n浏览器利用获取到的 IP 发起 HTTP 请求，但是 HTTP Request/Response 必须在 TCP 这个“虚拟的连接”上发送和接收\n建立“虚拟的”TCP 连接需要本机 IP、本机端口、服务器 IP、服务器端口\n本机端口由操作系统给浏览器随机分配\n服务器端口使用相应服务的端口，例如 HTTP 服务：80\n三次握手后，客户端与服务器建立 TCP 连接\n一个 HTTP GET 请求经过多个路由器转发，达到服务器端（HTTP 数据包可能被下层分片传输）\nweb 服务器处理请求（三种方式）\n用一个线程处理所有请求，但同一时刻只能处理一个，性能问题严重\n为每个请求分配一个进程/线程，但当连接太多时，服务器端的进程/线程耗费大量内存资源，进程/线程切换导致 CPU 不堪重负\n复用 I/O：众多 Web 服务器采用复用结构，例如通过 epoll 方式监视所有连接，当连接状态发生变化（如有数据可读），才用一个进程/线程对该连接进行处理，处理完继续监视，等待下次变化。该方式可用少量进程/线程应对大量的连接请求\n以 Nginx 为例，对于 HTTP GET 请求，Nginx 利用 epoll 方式读取出来，Nginx 判断该请求是静态 or 动态\n若为静态（HTML、JavaScript、CSS、图片等），依赖于 Nginx 配置，可能转发到其他缓存服务器，可能读取本机硬盘上相关文件直接返回\n若为动态，需要后端服务器（如 Tomcat）处理后返回，则转发到 Tomcat，若后端 Tomcat 不止一个，则按策略选取一个，Nginx 选取方式\n轮询：按照次序依次向服务器转发\n权重：每个后端服务器指定一个权重，决定向每个服务器转发的几率\nip_hash：根据 IP 进行 hash，找到要转发的服务器，则同一个客户端 IP 总会被转发到同一个后端服务器\nfair：根据后端服务器相应时间分配请求，响应时间短的优先分配\n无论哪种策略，Nginx 需要将 HTTPRequest 转发给后端 Tomcat，并把 Tomcat 输出的 HttpResponse 转发给浏览器\nHttp Request 到达 Tomcat（由 Java 编写，可处理 Servlet/JSP 的容器），Tomcat 可能为每个请求分配一个线程进行处理，即 BIO 模式（Blocking I/O）或 I/O 多路复用模式或仅使用若干线程处理所有请求（NIO 模式）\nHttp Request 被交给某个 Servlet 处理，Servlet 将请求转换，变成后端框架所用参数格式，分发给某个 Controller(Spring)或 Action(Struts)\n后端处理，包括和缓存、数据库等组件交互，最终返回 Http Response，本例即为一个 HTML 页面\nNginx 将 Http Response 发送给浏览器，若使用 HTTP1.1，该 TCP 连接默认为 keep-alive，即不能关闭\n若 HTTP1.0，需根据 HTTP Request 中是否有 Connection:keep-alive 判断该 TCP 连接是否能关闭\n浏览器收到 Http Response，读取 HTML 页面\n该页面引用大量其他资源，例如 js、css、图片等，这些资源位于服务器端，并且在另一个域名 static.coder.com 下\n浏览器需要一一下载，从 DNS 获取 IP 开始，重复上述操作，除去 Tomcat 处理\n由于要下载的资源众多，浏览器会建立多个 TCP 连接，并行下载\n但同一时间对同一域名的请求数量不能太多，否则服务器访问量太大无法承受\n因此浏览器做限制，例如 Chrome 在 HTTP1.1 只能并行下载 6 个资源\n当服务器给浏览器发送静态文件，会声明过期时间（Cache-Control 或 Expire），浏览器可将文件缓存到本地，第二次请求相同文件时，若不过期则直接从本地读取\n若过期，浏览器询问服务器端，文件是否变更（根据上一次服务器回传的 Last-Modified 和 ETag），若未修改（304 Not Modified），则可使用本次缓存，否则服务器将最新的文件发回浏览器\n若按 Ctrl+F5 则强制发出 GET 请求，无视缓存（Chrome 使用 chrome://view-http-cache 查看缓存）\n浏览器得到 HTML（浏览器将其变成 DOM Tree）、CSS（浏览器将其变成 CSS Rule Tree）、JavaScript（可修改 DOM Tree）\n浏览器通过 DOM Tree 和 CSS Rule Tree 生成“Render Tree”，计算每个元素的位置和大小，进行布局，然后调用操作系统的 API 进行绘制\n参考：http://mp.weixin.qq.com/s/V1fUjSP3BwJ1CbEM0MC6pw\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-24-what-happens-about-url/","summary":"探析浏览器访问站点这一行为背后的具体行为。\n浏览器地址栏输入网址www.coder.com\n浏览器发送一个 UDP 包给 DNS 服务器\nDNS 服务器返回 coder.com 的 IP\n（optional）浏览器将该 IP 缓存起来，以提高下次访问速度（Chrome 通过 chrome://net-internals/#dns 查看）\n浏览器利用获取到的 IP 发起 HTTP 请求，但是 HTTP Request/Response 必须在 TCP 这个“虚拟的连接”上发送和接收\n建立“虚拟的”TCP 连接需要本机 IP、本机端口、服务器 IP、服务器端口\n本机端口由操作系统给浏览器随机分配\n服务器端口使用相应服务的端口，例如 HTTP 服务：80\n三次握手后，客户端与服务器建立 TCP 连接\n一个 HTTP GET 请求经过多个路由器转发，达到服务器端（HTTP 数据包可能被下层分片传输）\nweb 服务器处理请求（三种方式）\n用一个线程处理所有请求，但同一时刻只能处理一个，性能问题严重\n为每个请求分配一个进程/线程，但当连接太多时，服务器端的进程/线程耗费大量内存资源，进程/线程切换导致 CPU 不堪重负\n复用 I/O：众多 Web 服务器采用复用结构，例如通过 epoll 方式监视所有连接，当连接状态发生变化（如有数据可读），才用一个进程/线程对该连接进行处理，处理完继续监视，等待下次变化。该方式可用少量进程/线程应对大量的连接请求\n以 Nginx 为例，对于 HTTP GET 请求，Nginx 利用 epoll 方式读取出来，Nginx 判断该请求是静态 or 动态\n若为静态（HTML、JavaScript、CSS、图片等），依赖于 Nginx 配置，可能转发到其他缓存服务器，可能读取本机硬盘上相关文件直接返回","title":"从输入网址到浏览器呈现内容期间发生的事情"},{"content":"虽然类似这样的文章网上一搜一大把，但应 youngwa 邀，还是决定重新整理一下个人安装的详细流程及相关资源链接，以备后用。\n资源准备 macOS 系统镜像 8G 左右 cdr 后缀 点击下载\nvmware 推荐版本 12（自行安装）\nvmware 补丁（用于添加 macOS 类镜像）点击下载\n操作步骤 下载以上三个资源 安装 VMware 安装补丁，补充 VMware 关于镜像类型的选择（若不安装补丁，则没有 macOS 镜像的选项），安装 unlock，右击使用管理员权限打开 win-install.cmd 新建虚拟机，选择 macOS 类型镜像，并做相应配置 配置好后打开虚拟机的 vmx 文件，手动修改配置（搜索 smc）在 smc.present = \u0026ldquo;TRUE\u0026quot;后添加一行 smc.version = 0 启动虚拟机进行系统安装 完成即可（历时一个小时左右，视宿主机内存及硬盘配置而定） 注意事项 需要理解 linux 分区概念（不理解也可以将虚拟机分配的全部空间用作一个分区，在实用工具选项中选择磁盘工具，设置后关闭，进行系统安装）\n注意点 安装 macOS 和安装其他系统镜像类型的虚拟机没什么大的区别，主要在于以下几点：\n为 VMware 安装补丁，拓展镜像类型（实用 unlock） 修改 vmx，虚拟机配置文件，添加 smc.version = 0 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-23-install-macos-using-vmware/","summary":"虽然类似这样的文章网上一搜一大把，但应 youngwa 邀，还是决定重新整理一下个人安装的详细流程及相关资源链接，以备后用。\n资源准备 macOS 系统镜像 8G 左右 cdr 后缀 点击下载\nvmware 推荐版本 12（自行安装）\nvmware 补丁（用于添加 macOS 类镜像）点击下载\n操作步骤 下载以上三个资源 安装 VMware 安装补丁，补充 VMware 关于镜像类型的选择（若不安装补丁，则没有 macOS 镜像的选项），安装 unlock，右击使用管理员权限打开 win-install.cmd 新建虚拟机，选择 macOS 类型镜像，并做相应配置 配置好后打开虚拟机的 vmx 文件，手动修改配置（搜索 smc）在 smc.present = \u0026ldquo;TRUE\u0026quot;后添加一行 smc.version = 0 启动虚拟机进行系统安装 完成即可（历时一个小时左右，视宿主机内存及硬盘配置而定） 注意事项 需要理解 linux 分区概念（不理解也可以将虚拟机分配的全部空间用作一个分区，在实用工具选项中选择磁盘工具，设置后关闭，进行系统安装）\n注意点 安装 macOS 和安装其他系统镜像类型的虚拟机没什么大的区别，主要在于以下几点：\n为 VMware 安装补丁，拓展镜像类型（实用 unlock） 修改 vmx，虚拟机配置文件，添加 smc.version = 0 ","title":"使用vmware安装macOS"},{"content":"这算不上一篇博客，只是不想再重复在解决这个问题上花费时间。另外对于解决方案的原理有待深究。\n核心操作 进入GRUB修改 kernel 镜像启动参数\n具体步骤 启动系统时长按 shift，进入 GRUB 引导模式 进入高级模式 选择恢复模式（recovery mode）按 E 键（这里最容易错，是按 e 键编辑启动项，而不是按回车进入） 找到 recovery nomodeset 改为 quiet splash rw init=/bin/bash（挂载硬盘为可读写模式） 按 Ctrl+x 或 F10 进行引导 进入 root@(none):/# 输入 passwd 进行 root 的密码设置 重启 Tip：此方案用于解决 root 密码重置，但如果是 ubuntu，默认是以普通用户登录或游客访问，在登录界面是看不到 root 用户的入口，需要登录普通用户需要 sudo su 来切换 root，但如果普通用户忘记密码，就进不到这一步，这时解决方案则是在第 7 步为 passwd 加上参数，即要设置密码的用户名\n参考\nhttps://books.google.com/books?id=X3tZDgAAQBAJ\u0026amp;pg=PA191\u0026amp;lpg=PA191\u0026amp;dq=recovery+nomodeset\u0026amp;source=bl\u0026amp;ots=HOI9ga8YBl\u0026amp;sig=J8_HlXL2v9V9BnpNpvXKoPbW2MM\u0026amp;hl=zh-CN\u0026amp;sa=X\u0026amp;ved=0ahUKEwjh0MWQ--zYAhVBl5QKHSfvBd0Q6AEIVDAE#v=onepage\u0026amp;q=recovery%20nomodeset\u0026amp;f=false ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-23-linux-password-forget/","summary":"这算不上一篇博客，只是不想再重复在解决这个问题上花费时间。另外对于解决方案的原理有待深究。\n核心操作 进入GRUB修改 kernel 镜像启动参数\n具体步骤 启动系统时长按 shift，进入 GRUB 引导模式 进入高级模式 选择恢复模式（recovery mode）按 E 键（这里最容易错，是按 e 键编辑启动项，而不是按回车进入） 找到 recovery nomodeset 改为 quiet splash rw init=/bin/bash（挂载硬盘为可读写模式） 按 Ctrl+x 或 F10 进行引导 进入 root@(none):/# 输入 passwd 进行 root 的密码设置 重启 Tip：此方案用于解决 root 密码重置，但如果是 ubuntu，默认是以普通用户登录或游客访问，在登录界面是看不到 root 用户的入口，需要登录普通用户需要 sudo su 来切换 root，但如果普通用户忘记密码，就进不到这一步，这时解决方案则是在第 7 步为 passwd 加上参数，即要设置密码的用户名\n参考\nhttps://books.google.com/books?id=X3tZDgAAQBAJ\u0026amp;pg=PA191\u0026amp;lpg=PA191\u0026amp;dq=recovery+nomodeset\u0026amp;source=bl\u0026amp;ots=HOI9ga8YBl\u0026amp;sig=J8_HlXL2v9V9BnpNpvXKoPbW2MM\u0026amp;hl=zh-CN\u0026amp;sa=X\u0026amp;ved=0ahUKEwjh0MWQ--zYAhVBl5QKHSfvBd0Q6AEIVDAE#v=onepage\u0026amp;q=recovery%20nomodeset\u0026amp;f=false ","title":"linux忘记密码"},{"content":"MSDN 学习 js 高级教程 note\n构造函数 使用构造函数定义类型（type） 概念 构造函数是一个为 Object 初始化一个特定类型的函数\n使用 new 关键字调用构造函数\n这里有一些 js 内建对象和自定义对象的例子\nvar myObject = new Object(); var myBirthday = new Date(1993, 11, 12); var myCar = new Car(); 构造函数包含 this 关键字，它是对新创建的空对象的引用（reference）\n它通过创建属性并为他们赋初始值来初始化新对象\n构造函数将返回对所创建对象的引用\nfunction Circle(xPoint, yPoint, radius) { this.x = xPoint; this.y = yPoint; this.radius = radius; } var aCircle = new Circle(5, 11, 99); 使用自定义构造函数创建的所有对象的类型都是 object\njs 只有 6 中类型：object、function、string、number、boolean、undefined\ntypeof操作符以字符串形式返回类型信息\nvar index = 5; var result = typeof index === \u0026#34;number\u0026#34;; var description = \u0026#34;abc\u0026#34;; var result = typeof description === \u0026#34;string\u0026#34;; true true 为声明和未声明的变量测试 undefined 数据类型\nvar declared; var result1 = typeof declared === \u0026#34;undefined\u0026#34;; console.log(result1); var result2 = typeof notDeclared === \u0026#34;undefined\u0026#34;; console.log(result2); var obj = {}; var result3 = typeof obj.propNotDeclared === \u0026#34;undefined\u0026#34;; console.log(result3); true true true var result = notDeclared === \u0026#34;undefined\u0026#34;; console.log(result); Uncaught ReferenceError: notDeclared is not defined 未声明的变量不能用于比较\n数组 Array.isArray(object)判断一个对象是否是一个数组\n如果对象是一个数组则返回 true，如果对象不是一个数组或参数不是一个对象（object）则返回 false\n创建数组方式：\narrayObj = new Array() arrayObj = new Array(size) arrayObj = new Array()\narrayObj 必需，Array 对象分配到的变量 size 可选，从 0 开始（包括 0）的整数，数组索引范围为[0,size-1] element 可选，数组内所放置的元素，这样会创建 n+1 个元素（n 为数组索引最大值），这种数组创建方式必需提供至少一个元素\nvar d = new Array(\u0026#34;test\u0026#34;, 3); undefined; d[(\u0026#34;test\u0026#34;, 3)]; var ar = []; var result1 = Array.isArray(ar); console.log(result1); var ar = new Array(); var result2 = Array.isArray(ar); console.log(result2); var ar = [1, 2, 3]; var result3 = Array.isArray(ar); console.log(result3); var result = Array.isArray(\u0026#34;an array\u0026#34;); console.log(result); true true true false 数组对象 Array 支持创建任何数据类型的数组\n数组创建后，可通过[]表示法来访问每个独立的元素\njs 数组从 0 开始\nvar my_array = new Array(); for (i = 0; i \u0026lt; 10; i++) { my_array[i] = i; } x = my_array[4]; console.log(x); console.log(my_array[10]); 4 undefined 可以传递一个无符号 32 位整数给 Array 构造函数类指定数组的大小\n如果值为负或者非整数，会出现运行时错误\nvar arr1 = new Array(10); console.log(arr1.length); var arr2 = new Array(-1); console.log(arr2); arr3 = new Array(1.5); console.log(arr3); 10 Uncaught RangeError: Invalid array length Uncaught RangeError: Invalid array length 原型和原型继承 prototype 是函数的一个属性，同时也是由构造函数创建的对象（instance）的一个属性\n函数的原型为对象，主要在函数用作构造函数时使用\n使用原型添加属性和方法 可使用 prototype 属性向对象添加属性和方法，甚至于已创建的对象是也是如此\nfunction Vehicle(wheels, engine) { this.wheels = wheels; this.engine = engine; } var testVehicle = new Vehicle(2, false); Vehicle.prototype.color = \u0026#34;red\u0026#34;; var testColor = testVehicle.color; console.log(testColor); red 向预定义的对象添加属性和方法，例如：在 String 原型上定义一个 Trim 方法，脚本中所有的字符串都将继承该方法\nString.prototype.trim = function () { return this.replace(/(^\\s*)|(\\s*$)/g, \u0026#34;\u0026#34;); }; var s = \u0026#34; leading and trailing spaces \u0026#34;; window.alert(s + \u0026#34;(\u0026#34; + s.length + \u0026#34;)\u0026#34;); s = s.trim(); window.alert(s + \u0026#34;(\u0026#34; + s.length + \u0026#34;)\u0026#34;); leading and trailing spaces(33) leading and trailing spaces(27) Nice, isn\u0026rsquo;t it?\n使用原型通过 Object.create 从一个对象派生另一个对象 例如：；利用 Object.create 函将使之前定义的 Vehicle 对象的原型（以及所需的任何新属性）派生出一个新的对象 Bicycle\nvar Bicycle = Object.create(Object.getPrototypeOf(Vehicle), { pedals: { value: true }, }); 参考：https://msdn.microsoft.com/zh-cn/library/b9w25k6f(v=vs.94).aspx\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-20-js-advanced/","summary":"MSDN 学习 js 高级教程 note\n构造函数 使用构造函数定义类型（type） 概念 构造函数是一个为 Object 初始化一个特定类型的函数\n使用 new 关键字调用构造函数\n这里有一些 js 内建对象和自定义对象的例子\nvar myObject = new Object(); var myBirthday = new Date(1993, 11, 12); var myCar = new Car(); 构造函数包含 this 关键字，它是对新创建的空对象的引用（reference）\n它通过创建属性并为他们赋初始值来初始化新对象\n构造函数将返回对所创建对象的引用\nfunction Circle(xPoint, yPoint, radius) { this.x = xPoint; this.y = yPoint; this.radius = radius; } var aCircle = new Circle(5, 11, 99); 使用自定义构造函数创建的所有对象的类型都是 object\njs 只有 6 中类型：object、function、string、number、boolean、undefined\ntypeof操作符以字符串形式返回类型信息\nvar index = 5; var result = typeof index === \u0026#34;number\u0026#34;; var description = \u0026#34;abc\u0026#34;; var result = typeof description === \u0026#34;string\u0026#34;; true true 为声明和未声明的变量测试 undefined 数据类型","title":"js学习笔记——一些常用的高级属性"},{"content":"js 变量作用域探析\n背景 var o = {}; o.fun = test(); o.fun(); function test() { var fn = function () { console.log(this); }; return fn; } {fun: ƒ} 由于对这个程序的输出结果感到不解，于是决定深入了解 js 作用域究竟是什么个东西\n参考：https://msdn.microsoft.com/zh-cn/library/bzt2dkta(v=vs.94).aspx\n变量作用域 又要谈到 js 的两个范围：全局和局部\n函数之外声明的变量就是全局变量，可在整个程序中访问和修改\n函数内声明的变量是局部变量，每当执行程序时都会创建和销毁该变量（所以称临时变量），并且无法通过函数之外的任何代码访问该变量（MSDN 如是说）\njs 不支持块范围（通过一组大括号定义新范围），于是就只有全局（函数外）和局部（函数内），以函数划分的这两种范围\njs 范围 var aNumber = 100; tweak(); function tweak() { document.write(aNumber); if (false) { var aNumber = 123; } } undefined 虽然 if（false），var aNumber = 123 不会执行，但是 js 在执行函数 tweak()时，会查找所有变量声明，var aNumber 被扫描到，js 使用初始值undefined创建变量，即使使用一个值声明变量 var aNumber = 123，但 aNumber 变量的初始值仍为undefined，仅当执行包含声明的行（var aNumber = 123）时才会使用已声明的值。\njs 会在执行任何代码之前处理所有变量声明，无论是在条件块中声明还是在其他构造中声明\njs 一旦找到所有变量，就会执行函数中的代码。如果函数内部隐式声明变量，即变量出现在赋值表达式左侧，但尚未使用var进行声明，则它将创建为全局变量\njs 中，内部（嵌套）函数将存储对局部变量的引用（即使在函数返回之后），这些局部变量存在于与函数本身相同的范围，这一组引用称为闭包。\nfunction send(name) { return function () { sendHi(name); }; } function sendHi(msg) { console.log(\u0026#34;Hello\u0026#34; + msg); } var func = send(\u0026#34;Bill\u0026#34;); func(); sendHi(\u0026#34;Pete\u0026#34;); func(); HelloBill HelloPete HelloBill 对内部函数的第二次调用输出与第一次调用相同，因为外部函数的输入参数 name 存储在内部函数闭包中的局部变量\n块范围变量 IE11 引入对 let 和 const 这两个块范围变量的支持\nlet x = 10; var y = 10; { let x = 5; var y = 5; { let x = 2; var y = 2; document.write(\u0026#34;x: \u0026#34; + x + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); document.write(\u0026#34;y: \u0026#34; + y + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); // Output: // x: 2 // y: 2 } document.write(\u0026#34;x: \u0026#34; + x + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); document.write(\u0026#34;y: \u0026#34; + y + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); // Output: // x: 5 // y: 2 } document.write(\u0026#34;x: \u0026#34; + x + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); document.write(\u0026#34;y: \u0026#34; + y + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); // Output: // x: 10 // y: 2 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-20-js-parameter-scope/","summary":"js 变量作用域探析\n背景 var o = {}; o.fun = test(); o.fun(); function test() { var fn = function () { console.log(this); }; return fn; } {fun: ƒ} 由于对这个程序的输出结果感到不解，于是决定深入了解 js 作用域究竟是什么个东西\n参考：https://msdn.microsoft.com/zh-cn/library/bzt2dkta(v=vs.94).aspx\n变量作用域 又要谈到 js 的两个范围：全局和局部\n函数之外声明的变量就是全局变量，可在整个程序中访问和修改\n函数内声明的变量是局部变量，每当执行程序时都会创建和销毁该变量（所以称临时变量），并且无法通过函数之外的任何代码访问该变量（MSDN 如是说）\njs 不支持块范围（通过一组大括号定义新范围），于是就只有全局（函数外）和局部（函数内），以函数划分的这两种范围\njs 范围 var aNumber = 100; tweak(); function tweak() { document.write(aNumber); if (false) { var aNumber = 123; } } undefined 虽然 if（false），var aNumber = 123 不会执行，但是 js 在执行函数 tweak()时，会查找所有变量声明，var aNumber 被扫描到，js 使用初始值undefined创建变量，即使使用一个值声明变量 var aNumber = 123，但 aNumber 变量的初始值仍为undefined，仅当执行包含声明的行（var aNumber = 123）时才会使用已声明的值。","title":"js学习笔记——变量作用域"},{"content":"关于深入理解 js 的 44 道 wired 题目，经实际验证及分析的学习笔记。\n[\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;].map(parseInt) [1, NaN, NaN] map() map passes 3 params (element, index, array) parseInt take two parameters (val, radix)\ntypeof null \u0026#34;object\u0026#34; null instanceof object false typeof always return \u0026ldquo;object\u0026rdquo; for native non callable objects\n[ [3, 2, 1].reduce(Math.pow), [].reduce(Math.pow) ] reduce on an empty array without an initial value throws TypeError array.reduce() Math.pow\nvar val = \u0026#34;smtg\u0026#34;; console.log(\u0026#34;Value is \u0026#34; + (val === \u0026#34;smtg\u0026#34;) ? \u0026#34;Something\u0026#34; : \u0026#34;Nothing\u0026#34;); Something the + operator has higher precedence than the ternary(三元) one\nvar name = \u0026#34;World!\u0026#34;; (function () { if (typeof name === \u0026#34;undefined\u0026#34;) { var name = \u0026#34;Jack\u0026#34;; console.log(\u0026#34;Goodbye \u0026#34; + name); } else { console.log(\u0026#34;Hello \u0026#34; + name); } })(); Goodbye Jack The var declaration is hoisted to the function scope, but the initialization is not. 声明被隔离，初始化没有 declaration initialization 闭包\nvar END = Math.pow(2, 53); var START = END - 100; var count = 0; for (var i = START; i \u0026lt;= END; i++) { count++; } console.log(count); boom it goes into a infinite loop 2^53 is the highest possible number in JS 2^53+1 gives 2^53(never become larger than it)\nvar ary = [0, 1, 2]; ary[10] = 10; ary.filter(function (x) { return x === undefined; }); [] Array.prototype.filter is not invoked for the missing elements filter()\nvar two = 0.2; var one = 0.1; var eight = 0.8; var six = 0.6; [two - one == one, eight - six == two]; [true, false] eight - six 0.20000000000000007 two - one 0.1 JS does not have precision(精确的) math, even though sometimes it work correctly\nfunction showCase(value) { switch (value) { case \u0026#34;A\u0026#34;: console.log(\u0026#34;Case A\u0026#34;); break; case \u0026#34;B\u0026#34;: console.log(\u0026#34;Case B\u0026#34;); break; case undefined: console.log(\u0026#34;undefined\u0026#34;); default: console.log(\u0026#34;Do not know!\u0026#34;); } } showCase(new String(\u0026#34;A\u0026#34;)); Do not know! switch uses === internally new String(x) !== x\nfunction showCase2(value) { switch (value) { case \u0026#34;A\u0026#34;: console.log(\u0026#34;Case A\u0026#34;); break; case \u0026#34;B\u0026#34;: console.log(\u0026#34;Case B\u0026#34;); case undefined: console.log(\u0026#34;undefined\u0026#34;); break; default: console.log(\u0026#34;Do not know!\u0026#34;); } } showCase2(String(\u0026#34;A\u0026#34;)); Case A String(\u0026#34;B\u0026#34;) \u0026#34;B\u0026#34; String(1) \u0026#34;1\u0026#34; String does not create an object but does return a string typeof String(1) === \u0026ldquo;string\u0026rdquo;\nfunction isOdd(num) { return num % 2 == 1; } function isEven(num) { return num % 2 == 0; } function isSane(num) { return isEven(num) || isOdd(num); } var values = [7, 4, \u0026#34;13\u0026#34;, -9, Infinity]; values.map(isSane); [true, true, true, false, false] Infinity % 2 gives NaN -9 % 2 gives -1 modulo operator(模运算符) keeps sign so it\u0026rsquo;s result is only reliable compared to 0\nparseInt(3, 8) parseInt(3, 2) parseInt(3, 0) 3 parseInt(3, 8) 3 parseInt(3, 2) NaN parseInt(3, 0) 3 3 does not exist in base 2, so NaN parseInt(3, 0) parseInt will consider a bogus radix(考虑伪造一个基数) and assume you meant 10\nArray.isArray( Array.prototype ) true Array.prototype is an Array\nvar a = [0]; if ([0]) { console.log(a == true); } else { console.log(\u0026#34;wut\u0026#34;); } false [0] as a boolean is considered true Alas using it in the comparisions it gets converted in a different way and all goes to hell\n[] == [] false == is the spawn of satan(==是恶魔之卵？？？)\n\u0026#39;5\u0026#39; + 3 \u0026#39;5\u0026#39; - 3 \u0026#34;53\u0026#34;, 2 Strings know about + and will use it but they are ignoreant of - int that case the strings get converted to numbers\n1 + - + + + - + 1 2 1 + - 1 0 1 + - + 1 0 1 + - + + 1 0 1 + - + + + - 1 2 1 + - + + + - + 1 2 ???\nvar ary = Array(3); ary[0] = 2; ary.map(function (elem) { return \u0026#34;1\u0026#34;; }); [\u0026#34;1\u0026#34;, empty × 2] map is only invoked for elements of the Array which have been initialiazed\nfunction sideEffecting(ary) { ary[0] = ary[2]; } function bar(a, b, c) { c = 10; sideEffecting(arguments); return a + b + c; } bar(1, 1, 1); 21 variables are tied to the arguments object even not in the same scope changing the variables changes arguments changing arguments changes the local variables even\nvar a = 111111111111111110000, b = 1111; a + b; 111111111111111110000 lack of precision for numbers in js affects both small and big numbers\nvar x = [].reverse; x(); ??? [].reverse will return this when invoked without an explicit(明确的) receiver object it will default to the default this AKA window\nES5???\nNumber.MIN_VALUE; 5e-324; Number.MIN_VALUE \u0026gt; 0; true - Number.MAX_VALUE - 1.7976931348623157e308 - Number.MAX_VALUE \u0026gt; 0; false; 1 \u0026lt; 2 \u0026lt; 3 true 3 \u0026lt; 2 \u0026lt; 1 true true gets intified and is 1 false gets intified and become 0\n// the most classic wtf 2 == [[[2]]] true both objects get converted to strings and in both cases the resulting string is \u0026ldquo;2\u0026rdquo;\n3.toString() 3..toString() 3...toString() error \u0026#34;3\u0026#34; error 3.x is a valid syntax to define \u0026ldquo;3\u0026rdquo; with a mantissa(尾数) of x toString is not a valid number, but the empty string is ???\n(function () { var x = (y = 1); })(); console.log(y); console.log(x); 1 error y is an automatic global, not a function local one\nvar a = /123/, b = /123/; a == b; a === b; false false Per spec Two regular expression literals in a program evaluate to regular expression objects that never compare as === to each other even if the two literals\u0026rsquo; contents are identical. 同一个程序内的正则表达式永不使用===相互比较，尽管二者内容一样\nvar a = [1, 2, 3], b = [1, 2, 3], c = [1, 2, 4]; a == b; a === b; a \u0026gt; c; a \u0026lt; c; false false false true Arrays are compared lexicographically with \u0026gt; and \u0026lt;, but not with == and ===\nvar a = {}, b = Object.prototype; [a.prototype === b, Object.getPrototypeOf(a) === b]; false true Functions have a prototype property but other objects don\u0026rsquo;t a.prototype is undefined Every Object instead has an internal property accessible via Object.getPrototypeOf\nfunction f() {} var a = f.prototype, b = Object.getPrototypeOf(f); a === b; false f.prototype is the object that will become the parent of any objects created with new f Object.getPrototypeOf returns the parent in the inheritance hierarchy\nfunction foo() {} var oldName = foo.name; foo.name = \u0026#34;bar\u0026#34;; [oldName, foo.name]; [\u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;] name is a read only property\n1 2 3\u0026#34;.replace(/\\d/g, parseInt) \u0026#34;1 NaN 3\u0026#34; String.prototype.replace invokes the callback function with multiple arguments where the first is the match then there is one argument for each capturing group then there is the offset of the matched substring finally the original string itself parseInt will be invoked with arguments [1, 0], [2, 2], [3, 4] ???\nfunction f() {} var parent = Object.getPrototypeOf(f); f.name; parent.name; typeof eval(f.name); typeof eval(parent.name); \u0026#34;f\u0026#34; \u0026#34;Empty\u0026#34; \u0026#34;function\u0026#34; error The function prototype object is defined somewhere, has a name, can be invoked but it is not in the current scope\nvar lowerCaseOnly = /^[a-z]+$/; [lowerCaseOnly.test(null), lowerCaseOnly.test()]; [true, true] the argument is converted to a string with the abstract ToString operation it is \u0026ldquo;null\u0026rdquo; and \u0026ldquo;undefined\u0026rdquo;\n[, , ,].join(\u0026#34;, \u0026#34;); \u0026#34;, , \u0026#34; JS allows a trailing comma(尾随分隔符) when defining arrays It is an array of three undefined join()\nvar a = {class: \u0026#34;Animal\u0026#34;, name: \u0026#39;Fido\u0026#39;}; a.class It depends on brower class is a reserved word accepted as a property name by Chrome,Firefox and Opera fail in IE accept most reserved words (int, private, throws etc) as variable names class is verboten(禁止的)\nvar a = new Date(\u0026#34;epoch\u0026#34;); a instanceof Date is true, but invalid time is internally kept as a Number in this case it is a NaN\nvar a = Function.length, b = new Function().length; a === b; false Function.length is defined to be 1 the length property of the Function prototype object is defined to be 0\nvar a = Date(0); var b = new Date(0); var c = new Date(); [a === b, b === c, a === c]; [false, false, false] a \u0026#34;Thu Jan 18 2018 18:25:18 GMT+0800 (中国标准时间)\u0026#34; b Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) c Thu Jan 18 2018 18:25:18 GMT+0800 (中国标准时间) When it is invoked as a function, it returns a String representation of the current time When Date is invoked as a constructor it returns an object relative to the epoch(Jan 01 1970) When the argument is missing it returns the current date\nvar min = Math.min(), max = Math.max(); min \u0026lt; max; false min Infinity max -Infinity Math.min returns +Infinity when supplied an empty argument list\nfunction captureOne(re, str) { var match = re.exec(str); return match \u0026amp;\u0026amp; match[1]; } var numRe = /num=(\\d+)/gi, wordRe = /word=(\\w+)/i, a1 = captureOne(numRe, \u0026#34;num=1\u0026#34;), a2 = captureOne(wordRe, \u0026#34;word=1\u0026#34;), a3 = captureOne(numRe, \u0026#34;NUM=2\u0026#34;), a4 = captureOne(wordRe, \u0026#34;WORD=2\u0026#34;); [a1 === a2, a3 === a4]; Regular expressions in JavaScript if defined using the /g flag will carry a state across matches, even if they are actually used on different strings (the lastIndex property). This means a3 will be null as the regular expression was applied starting from the index of the last matched string, even if it was a different one.\nvar a = new Date(\u0026#34;2014-03-19\u0026#34;), b = new Date(2014, 03, 19); [a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]; [false, false] JavaScript inherits 40 years old design from C: days are 1-indexed in C\u0026rsquo;s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn\u0026rsquo;t return a Date object.\nif (\u0026#34;http://giftwrapped.com/picture.jpg\u0026#34;.match(\u0026#34;.gif\u0026#34;)) { (\u0026#34;a gif file\u0026#34;); } else { (\u0026#34;not a gif file\u0026#34;); } \u0026#34;a gif file\u0026#34; String.prototype.match silently converts the string into a regular expression, without escaping it, thus the \u0026lsquo;.\u0026rsquo; becomes a metacharacter matching \u0026lsquo;/\u0026rsquo;.\nfunction foo(a) { var a; return a; } function bar(a) { var a = \u0026#34;bye\u0026#34;; return a; } [foo(\u0026#34;hello\u0026#34;), bar(\u0026#34;hello\u0026#34;)]; [\u0026#34;hello\u0026#34;, \u0026#34;bye\u0026#34;] Variabled declarations are hoisted, but in this case since the variable exists already in the scope, they are removed altogether. In bar() the variable declaration is removed but the assignment remains, so it has effect.\n参考：http://javascript-puzzlers.herokuapp.com/\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-20-javascript-puzzlers/","summary":"关于深入理解 js 的 44 道 wired 题目，经实际验证及分析的学习笔记。\n[\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;].map(parseInt) [1, NaN, NaN] map() map passes 3 params (element, index, array) parseInt take two parameters (val, radix)\ntypeof null \u0026#34;object\u0026#34; null instanceof object false typeof always return \u0026ldquo;object\u0026rdquo; for native non callable objects\n[ [3, 2, 1].reduce(Math.pow), [].reduce(Math.pow) ] reduce on an empty array without an initial value throws TypeError array.reduce() Math.pow\nvar val = \u0026#34;smtg\u0026#34;; console.log(\u0026#34;Value is \u0026#34; + (val === \u0026#34;smtg\u0026#34;) ?","title":"javascript-puzzlers"},{"content":"js 关键字 this 用法解析\n解释 函数运行时自动生成的一个内部对象，只能在函数内部使用（想起了 Python 函数的 self）\nfunction test() { this.x = 1; } 函数使用场合不同，this 的值会发生变化\n但 this 总指的是调用函数的那个对象\n使用场景 纯粹函数调用（全局调用）\n函数作为对象方法的调用\n作为构造函数调用\napply 调用\n1.纯粹函数调用 全局性调用，this 代表全局对象 Global\nfunction test() { this.x = 1; alert(this.x); } test(); 1 var x = 1; function test() { alert(this.x); } test(); 1 不会报错，因为相当于 alert(Global.x)\nvar x = 1; function test() { this.x = 0; } test(); alert(x); 0 test()之后相当于将全局变量的 x 重新赋值 0，Global.x = 0\n2.作为对象方法的调用 函数作为某个对象 o 的方法，this 指的是这个上级对象 o\nfunction test() { alert(this.x); } var o = {}; o.x = 1; o.m = test; o.m(); 1 此时 test()函数作为对象 o 的方法，则 test 方法中的 this 指的是 o 这个对象\n3.作为构造函数调用 构造函数：通过这个函数生成一个新对象（object），此时 this 指这个新对象\nfunction test() { this.x = 1; } var o = new test(); alert(o.x); 1 this 就是当前通过构造函数生成的对象 o\nvar x = 2; function test() { this.x = 1; } var o = new test(); alert(x); alert(o.x); 2 1 构造函数赋值的 x 是 o 的变量 x，而不是全局变量 x\n以上三个很明显都是围绕调用函数的对象\n4.apply 调用 apply 是函数对象的一个方法，作用是改变函数的调用对象\n第一个参数表示改变后的调用这个函数的对象，this 指的就是这第一个参数\nvar x = 0; function test() { alert(this.x); } var o = {}; o.x = 1; o.m = test; o.m.apply(); 0 apply()参数为空时，默认调用全局对象（此时 this 指的是全局对象）\n全局对象的 x 是 0\n其实还是实际调用函数的那个对象\nvar x = 0; function test() { alert(this.x); } var o = {}; o.x = 1; o.m = test; o.m.apply(o); 1 改变调用这个函数的对象，虽然本来调用 test 函数的对象就是 o\n但是如果调用 apply 函数不填参数，就会变成全局对象去调用 test 方法\n总结 Is that clear?\n一句话总结：this 就是调用函数的那个对象\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-19-js-this/","summary":"js 关键字 this 用法解析\n解释 函数运行时自动生成的一个内部对象，只能在函数内部使用（想起了 Python 函数的 self）\nfunction test() { this.x = 1; } 函数使用场合不同，this 的值会发生变化\n但 this 总指的是调用函数的那个对象\n使用场景 纯粹函数调用（全局调用）\n函数作为对象方法的调用\n作为构造函数调用\napply 调用\n1.纯粹函数调用 全局性调用，this 代表全局对象 Global\nfunction test() { this.x = 1; alert(this.x); } test(); 1 var x = 1; function test() { alert(this.x); } test(); 1 不会报错，因为相当于 alert(Global.x)\nvar x = 1; function test() { this.x = 0; } test(); alert(x); 0 test()之后相当于将全局变量的 x 重新赋值 0，Global.","title":"js学习笔记——this关键字"},{"content":"js 的局部变量和全局变量\n大纲 如何声明局部变量和全局变量 js 变量作用域基于特有的作用域链 js 没有块级作用域（ES5-） 函数中声明的变量在整个函数中都有定义 声明局部变量和全局变量 全局变量——定义在函数外的变量 局部变量——函数内部声明的变量 var a = \u0026#34;global\u0026#34;; function getLocal() { var a = \u0026#34;local\u0026#34;; console.log(a); } getLocal(); console.log(a); local global a = \u0026#34;global\u0026#34;; function getLocal() { a = \u0026#34;local\u0026#34;; console.log(a); b = \u0026#34;local\u0026#34;; console.log(b); } getLocal(); console.log(a); console.log(b); local local local local 疑问：\n函数外的 a 为什么变成 local？\n函数外为什么可以访问 b？\n解析：\n函数体内部，局部变量优先级比同名全局变量高\n函数体内声明变量不使用 var，会暴露在全局上下文中，和现有变量冲突，并覆盖同名全局变量\n变量作用域链 每当 js 执行时会有一个对应的执行环境被创建（每一个方法在自己独有的执行环境中执行）\n执行环境中的重要部分——函数的调用对象（存储相应函数的局部变量）\n函数的执行环境包含了调用对象，调用对象的属性就是函数的局部变量，每个函数在这样的执行环境中执行。函数之外的代码在另一个环境中执行，包含了全局变量。\n作用域链 对象组成的列表或链\nvar rain = 1; function rainMan() { var man = 2; function inner() { var innerVar = 4; console.log(rain); } inner(); } rainMan(); 1 解析：\nrainMain() man 和 inner()分别是 rainMain 定义的变量和函数 执行 inner() 寻找 rain 先在 inner 内部找，没找到 继续在 rainMain 中找，没找到 在全局对象找，找到，输出 1 若全局对象中还未找到则报错：Uncaught ReferenceError: rain is not defined 在全局的 js 执行环境中，作用域链只包含一个对象——全局对象\n在函数的执行环境中，同时包含函数的调用对象\njs 的函数可嵌套——每个函数执行环境的作用域链可能包含不同数目个对象\n一个非嵌套的函数的执行环境中，作用域链包含这个函数的调用对象和全局对象\n嵌套的函数的执行环境中，作用域链包含嵌套的每一层函数的调用对象以及全局变量\nJS 没有块级作用域 function checkVariable(obj) { var i = 0; if (typeof obj == \u0026#34;object\u0026#34;) { var j = 0; for (var k = 0; k \u0026lt; 3; k++) { console.log(k); } console.log(k); } console.log(j); } checkVariable(new Object()); 0 1 2 3 0 i,j,k 作用域相同，都在 checkVariable()函数内都是全局的\n函数中声明的所有变量，无论在哪里声明，在整个函数中都有定义\n函数中声明的变量在整个函数中都有定义（即使在声明之前） function checkVariable() { var a = 1; function inner() { a = 100; } inner(); console.log(a); } checkVariable(); 100 var a = 1; function checkVariable() { console.log(a); var a = 2; console.log(a); } checkVariable(); undefined 2 原因：checkVariable()内部变量 a 在整个函数内部有定义（var a = 2 进行了声明）\n于是在整个函数内隐藏了同名全局变量 a\n相当于\nvar a = 1; function checkVariable() { var a; console.log(a); a = 2; console.log(a); } checkVariable(); 总结 js 变量的域根据方法块划分，而非 for、while、if 块（因为没有块作用域）\nfunction checkVariable() { console.log(i); for (var i = 0; i \u0026lt; 3; i++) { console.log(i); } console.log(i); while (true) { var j = 1; break; } console.log(j); if (true) { var k = 1; } console.log(k); } checkVariable(); console.log(i); console.log(j); console.log(k); 0 1 2 3 1 1 Uncaught ReferenceError: i is not defined js 在执行前对整个脚本做分析（包括局部变量）以确定变量是局部变量还是全局变量\nvar a = 1; function checkVariable() { console.log(a); a = 2; console.log(a); var a; console.log(a); } checkVariable(); console.log(a); undefined 2 2 1 函数中声明的变量在整个函数中都有定义（即使在声明之前）\n这里虽然 a 一开始未使用 var 声明，但在 js 一开始的扫描时发现后面有 var 对 a 进行声明，所以 a 不会暴露在全局，覆盖同名全局变量 a，所以函数外面的输出 1\n由于 a 在函数内部后面是使用 var 声明的，所以在前面的输出中能够输出 2，此时其实 a 已经被声明了，整个函数内部是整体分析的，所以才会出现函数中的变量在声明之前被定义（a = 2）\n参考：https://www.w3cplus.com/javascript/the-basics-of-variable-scope-in-javascript.html\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-19-js-variables/","summary":"js 的局部变量和全局变量\n大纲 如何声明局部变量和全局变量 js 变量作用域基于特有的作用域链 js 没有块级作用域（ES5-） 函数中声明的变量在整个函数中都有定义 声明局部变量和全局变量 全局变量——定义在函数外的变量 局部变量——函数内部声明的变量 var a = \u0026#34;global\u0026#34;; function getLocal() { var a = \u0026#34;local\u0026#34;; console.log(a); } getLocal(); console.log(a); local global a = \u0026#34;global\u0026#34;; function getLocal() { a = \u0026#34;local\u0026#34;; console.log(a); b = \u0026#34;local\u0026#34;; console.log(b); } getLocal(); console.log(a); console.log(b); local local local local 疑问：\n函数外的 a 为什么变成 local？\n函数外为什么可以访问 b？\n解析：\n函数体内部，局部变量优先级比同名全局变量高\n函数体内声明变量不使用 var，会暴露在全局上下文中，和现有变量冲突，并覆盖同名全局变量\n变量作用域链 每当 js 执行时会有一个对应的执行环境被创建（每一个方法在自己独有的执行环境中执行）\n执行环境中的重要部分——函数的调用对象（存储相应函数的局部变量）\n函数的执行环境包含了调用对象，调用对象的属性就是函数的局部变量，每个函数在这样的执行环境中执行。函数之外的代码在另一个环境中执行，包含了全局变量。\n作用域链 对象组成的列表或链","title":"js学习笔记——局部变量和全局变量"},{"content":"JS 闭包探析。What exactly the Closure is?\n计算机术语 闭包：引用了自由变量的函数。这个被引用的自由变量和这个函数一同存在，即使已经离开了创造它的环境。\n变量作用域 全局 局部 函数内部可直接读取全局变量 var n1 = 9; function f1() { alert(n1); } f1(); 9 因为变量声明在 Global，全局可见，它的子当然可以访问到\n函数外部无法直接读取函数内部的局部变量 function f2() { var n2 = 99; } alert(n2); n2 is not defined 因为函数是子，函数外部是父，父无法直接访问到子的局部变量\n函数内部变量如果未用 var 声明则为全局变量 function f3() { n3 = 999; } f3(); alert(n3); 999\n不管变量是在函数内还是函数外声明，如果没有使用 var 声明变量，就会是全局可见的\n于是此时的 n3 是 Global.n3\n从外部读取局部变量 ~想起了 Java 的反射~\n方法：在函数内部再定义一个函数\nfunction f4() { var n4 = 9999; function f5() { alert(n4); } } 解析：\nf5 在 f4 内部，f4（父）的所有局部变量对 f5（子）可见 反之，f5（子）的局部变量对 f4（父）不可见\n即“链式作用域”结构（chain scope）：子对象会一级一级向上寻找所有父对象的变量\n将 f5 作为返回值，即可在 f4 外部读取其内部变量\nfunction f4() { var n4 = 9999; function f5() { alert(n4); } return f5; } var result = f4(); result(); // Bingo! 9999 引用了自由变量的函数（f5）和被引用的自由变量（n4）一同存在，即使自由变量离开了创造它的环境（f4）。\n这个函数（f5）称为闭包\n闭包 上面的 f5 函数就是闭包（能够读取其他函数内部变量的函数——函数内部的子函数）\n闭包是连接函数外部和函数内部的桥梁\n用途 读取函数内部的变量 让这些变量的值始终保持在内存中 function f6() { var n6 = 999999; nAdd6 = function () { n6 += 1; }; function f7() { alert(n6); } return f7; } var result6 = f6(); result6(); nAdd6(); result6(); 999999 1000000 相当于 f6 的局部变量 n6 一直保存在内存中，并没有在 f6 调用后被自动清除\nnAdd 的值是一个匿名函数，也相当于一个闭包，使得在函数外部可以对函数内部的局部变量进行操作\n注意点 闭包导致函数中的变量保存在内存中，消耗内存大，易造成性能问题，IE 中可能导致内存泄露（解决：退出函数前将不使用的局部变量删除） 会在父函数外部改变内部变量的值，若把父函数当作对象（object）使用，把闭包当作其公用方法，把内部变量当作私有属性，切忌随意改变父函数内部变量的值 实践 var name = \u0026#34;The Window\u0026#34;; var object = { name: \u0026#34;My Object\u0026#34;, getNameFunc: function () { return function () { console.log(this); return this.name; }; }, }; alert(object.getNameFunc()()); Window The Window 没取到对象内部的变量，则 this 指向 window 中的变量 name（当前匿名函数的 this 即 Window）\nvar name = \u0026#34;The Window\u0026#34;; var object = { name: \u0026#34;My Object\u0026#34;, getNameFunc: function () { var that = this; return function () { return that.name; }; }, }; alert(object.getNameFunc()()); // My Object\n剖析：\n通过函数 getNameFunc 内部的匿名函数取得 object 内部变量 name\nobject.getNameFunc()()\nthis 即是调用 getNameFunc 的 object\n把 object 赋值给 that\nthat.name 即是 My Object\nthat.name，因为当前匿名函数没有 that 变量，会去其父寻找，找到，发现 that 的值是 this，this 又表示当前正在调用函数的对象，即 object\n参考： http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2018-01-19-js-closure/","summary":"JS 闭包探析。What exactly the Closure is?\n计算机术语 闭包：引用了自由变量的函数。这个被引用的自由变量和这个函数一同存在，即使已经离开了创造它的环境。\n变量作用域 全局 局部 函数内部可直接读取全局变量 var n1 = 9; function f1() { alert(n1); } f1(); 9 因为变量声明在 Global，全局可见，它的子当然可以访问到\n函数外部无法直接读取函数内部的局部变量 function f2() { var n2 = 99; } alert(n2); n2 is not defined 因为函数是子，函数外部是父，父无法直接访问到子的局部变量\n函数内部变量如果未用 var 声明则为全局变量 function f3() { n3 = 999; } f3(); alert(n3); 999\n不管变量是在函数内还是函数外声明，如果没有使用 var 声明变量，就会是全局可见的\n于是此时的 n3 是 Global.n3\n从外部读取局部变量 ~想起了 Java 的反射~\n方法：在函数内部再定义一个函数\nfunction f4() { var n4 = 9999; function f5() { alert(n4); } } 解析：","title":"js学习笔记——闭包"},{"content":"本文翻译自 13 年一篇关于比特币协议的深度解析文章\n成千上万篇文章为了解释比特币这一线上、点对点的货币而撰写。大多数文章对于其底层加密协议都只给出一些简短的解释，却忽略了很多细节。甚至那些文章常常掩盖重点进行更深入的研究。我这篇文章的目的是以一种清晰、容易理解的方式解释隐藏在比特币协议后面的主要思想。我们将从第一原则开始，对于比特币如何工作建立一个广义的理论上的理解，然后再深挖其细节，检查比特币交易的原始数据。\n以细节的方式理解协议是一项困难的工作。人们转而接受比特币，并从事投机关于如何通过比特币致富、比特币吧是否泡沫，比特币是否意味着税收结束的一天等等。这很有趣，但是严重限制你理解它。理解比特币的协议细节打开了难以进入的远景。特别是，理解比特币内建脚本语言的基础会使得使用比特币创造新的金融工具成为可能，比如智能合同。反过来，新的金融工具可以被用来创造新的市场并缔造人类行为新的集合形式。聊聊这些趣事吧！\n我会在后面的文章中描述比特币脚本和一些概念，比如智能合同。这篇文章集中解释比特币协议的核心。理解这篇文章你需要对公钥加密以及与其紧密关联的数字签名概念比较熟悉。我将同样假定你对加密散列概念熟悉。以上这些都没有特别难理解的。基本概念都会在大学的大一数学课程或者计算机课程中教授。这些概念很优雅，所以如果你对于他们不是很熟悉，我建议你先花一点时间熟悉一下。\n也许看上去比较神奇，比特币的基础是密码学。比特币不是一种货币？不是一种发送秘密信息的方式？事实上，比特币需要解决的事情大部分是安全事务——确保人们不能互相窃取，或者伪造等等。在原子世界我们通过一些设备，例如锁、保险箱、签名、银行金库实现安全。在比特世界我们通过加密实现安全。这也是为什么比特币的核心是加密协议。\n我在这篇文章中的策略是分阶段建立起比特币。我会通过解释一种非常简单的数字货币开始，所基于的思想几乎显而易见。我们将称其信息货币（Infocoin），以区分于比特币。当然，我们第一个版本的信息币会有很多不足，然后我们会经过多个迭代，每个迭代介绍仅仅一或两个新的想法。经过多个迭代后，我们将达到完整的比特币协议。我们将重新发明了比特币。\n这种策略比起我一次性解释整个比特币协议要慢。但是当你通过这样一次性解释的方式理解了比特币机制时，再去理解比特币为什么这样设计就会很困难。这种通过慢迭代的解释方式优势在于可以让你对于比特币每一个元素理解得更加犀利。\n最后，我应该提及对于比特币我也是个新手。我从 2011 年开始松散地关注（在 20 世纪 90 年代末开始关注加密数字货币），但直到今年早些时候才着重关注比特币协议的细节。所以我将非常感激对于我误解部分的指正。另外在本篇文章中我还包含了很多“留给读者的问题”——在我写作过程中对于新冒出的问题的一些笔记。你会发现这很有趣，但你也可以把它们全部跳过以免丢失全文的线索。\n第一步：签名意图信\n所以我们该如何设计一个数字货币呢？\n从表面上来看，数字货币听起来是不可能的。假设某个人，让我们称其 Alice，她有一些电子钱想花掉。如果 Alice 想使用一串比特字符作为钱，我们如何才能阻止她反复使用相同的比特字符串呢？否则将意味着会产生无穷无尽的钱。或者假如我们可以通过某种方式解决这个问题，但我们如何才能防止其他人伪造这样一串比特字符并用来偷取 Alice 的钱呢？\n这些只是众多问题中的两个，必须被克服以为了使用信息作为货币。\n作为信息币的第一个版本，让我们找到一个方法使得 Alice 可以使用一串字符（非常原始和不完整）作为货币的形式，以某种至少保证她的货币不会被伪造的方式。假设 Alice 想给 Bob 一个信息币。为了这么做，Alice 写下一行字符串“我，爱丽丝，给 Bob 一个信息币”。然后她用私钥给这条信息做了数字签名，并告知全世界 这段签过名的字符串。\n（顺便提一下，我使用首字母大写的 Infocoin 表示信息币协议及一般概念，用首字母小写的 infocoin 特指货币面值，类似用法很常见，虽然在比特币的世界不通用）\n这并不是一个令人非常影响深刻的数字货币原型。但它的确有一些优点。世界上的任何人（包括 Bob）可以使用 Alice 的公钥去确认 Alice 的确是“我，爱丽丝，给 Bob 一个信息币”这条信息签名的主人。没有其他人可以造出这条比特信息。但反过来，Alice 也可以说“不，我没说要给 Bob 一个信息币”。所以这个协议建立在 Alice 真的想给 Bob 一个信息币。同样的事实——没有其他人可以构造这样一条签名信息——也给予 Alice 一些防止其他人伪造的有限保护。当然，在 Alice 创建她的这条信息后也可能其他人复制了这条信息，这样的话伪造是可能的。但无法从头伪造。这两种属性——Alice 建立企图的部分和防止伪造的有限保护部分，是这个协议值得注意的特征。\n我在这个协议中没有（非常）准确地讲数字货币是什么。为了使其明确：特指这条信息本身，例如，这行比特字符串展示了数字货币“我，爱丽丝，给 Bob 一个信息币”。后面的协议类似，我们所有数字货币的形式只是会越来越复杂。\n使用序列号来使得货币被唯一标识\n第一个版本的信息币的问题在于 Alice 可以一次又一次地继续向 Bob 发送相同的签名消息。假定 Bob 收到了十份“我，爱丽丝，给 Bob 一个信息币”这样的拷贝签名信息。意味着 Alice 向 Bob 发送了十个不同的信息币吗？她的信息是巧合复制出来的吗？可能她只是试图戏弄 Bob 使其相信她给了他十个不同的信息币，当这条信息向全世界证明才表示她真的企图传送一个信息币。\n我们想要的是一种使得信息币唯一的方式。它们需要一个标签或者序列号。Alice 将签名“我，爱丽丝，用序列号 8740348 给 Bob 一个信息币”这条信息。然后，随后，Alice 可以签名“我，爱丽丝，用序列号 8770431 给 Bob 一个信息币”消息，然后 Bob（还有其他人）将会知道这是另外一个信息币被传送了。\n使得这个方案工作，我们需要一个可信任的序列号源用于信息币。创建这样一个源的方法之一是引用一个银行。这个银行将为信息币提供序列号，并追溯谁拥有了哪一个信息币并确认交易的确合法。\n更详细地说，让我们假设 Alice 去银行并说“我想从我的账户提取一个信息币”。银行从她的账户余额中扣减一个信息币，并分配给她一个新的、之前从未使用过的序列号，让我们称其 1234567。然后当 Alice 想把她的信息比转移给 Bob 时，她签名“我，Alice，给 Bob 一个信息币，使用序列号 1234567”这条消息。但 Bob 并没有就这样接受这个信息币。而是联系了银行以确认：（a）这个序列号的信息币是否属于 Alice；（b）Alice 已经支付了这个信息币。如果这两者都是真的，然后 Bob 告诉银行他想接受这个信息币，于是银行更新他们的交易记录并展示这个序列号的信息币现在是 Bob 的财产，并不再属于 Alice。\n使每个人都集中于银行\n上一个解决方案看上去很有前途。然而，事实证明，我们可以做一些更有野心的事情。我们完全可以消除银行的协议。这在很大程度上改变了货币的本质。这意味着不再有任何单一的组织管控货币。当你想到中央银行的巨大力量——控制着货币的供应量——这将是一个非常巨大的变化。\n这个想法是使得每个人（全体地）都是银行。特别是，我们假设每一个人都使用信息币保持着哪些信息币属于哪一个人的完整记录。你可以理解为这是一个展示所有的信息币交易的共享公共平台。我们称这个平台为区块链，因为那就被称为比特币的完整记录，一旦我们得到它。\n现在，假定 Alice 想转移一个信息币给 Bob。她签名了“我，Alice，给 Bob 一个信息币，以序列号 1234567”这条消息并把这条签名消息给了 Bob。Bob 可以用他拷贝的区块链去校验这的确是 Alice 给出的。如果校验成功，然后他把这笔交易中 Alice 发出的消息和他的接收消息广播给整个网络，于是每个人都更新他们的区块链拷贝。\n我们仍然有“序列号从哪来”这个问题，但这变得容易解决，所以我将推迟到后面讲解，在讨论比特币的部分。一个更具挑战的问题是，这个协议允许 Alice 通过支付她的信息币双倍来作弊。她发送“我，爱丽丝，给了 Bob 一个信息币，以序列号 1234567”给 Bob，同时发送“我，爱丽丝，给 Charlie 一个信息币，以序列号 1234567”给 Charlie。Bob 和 Charlie 都使用他们拷贝的区块链来检查这个信息币是 Alice 支付的。只要他们是同一时刻做这个验证（在他们有机会彼此听说之前），他们两个都会发现，是的，区块链显示这个信息币的确属于 Alice。于是他们都会接受这笔交易，并广播他们的接受。现在就有了问题，其他人该怎么更新他们的区块链呢？可能没有简单的方法来实现一个一致的共享事务平台。即使每个人都能达成一致的方式去更新他们的区块链，仍会有 Bob 或者 Charlie 将被欺骗的问题。\n乍一看 Alice 支付双份的问题难以解决。毕竟，如果 Alice 先向 Bob 发送消息，然后 Bob 可以确认这条消息，并告诉每个在网络内的人（包括 Charlie）去更新他们的区块链。一旦那发生了，Charlie 就不再会被 Alice 欺骗。所以最有可能只有非常短的一段时间内 Alice 可以支付出双份。然而，显然这样的一段时间是不可理喻的。更糟糕的是，有技术可以被 Alice 用来延长这一段时间。她可以，举个例子，利用网络流量分析发现 Bob 和 Charlie 沟通延迟很多的一段时间。或者她可以做些事情来故意破坏他们的通信。如果她能减慢通信甚至一点都将使得她支付双份更加容易。\n我们怎样才能解决这个双份支付的问题？明显的解决方法是当 Alice 向 Bob 发送一个信息币的时候，Bob 不应该试图独自确认交易。相反，他应该将可能的交易广播给信息币用户整个网络，并询问他们去判定这笔交易是否合法。如果他们集体决定这笔交易没问题，然后 Bob 可以接受这个信息币，并告诉每个人更新区块链。这种协议可以避免双份支付，因为如果 Alice 试图将她的信息币同时支付给 Bob 和 Charlie，其他人会察觉到，并且网络用户会告诉 Bob 和 Charlie 这笔交易有问题，于是交易将无法通过。\n更详细地，让我们假设 Alice 想要给 Bob 一个信息币。像之前那样，她签名“我，爱丽丝，给 Bob 一个信息币，以序列号 1234567”这条消息，并把这条签名消息发送给 Bob。同样如以前那样，Bob 做了一个明智的检查，使用他拷贝的区块链检查，的确，当前这个信息币属于爱丽丝。但在这个点上协议被修改了。Bob 并没有继续接受这笔交易。取而代之的是，他广播 Alice 的这条消息给整个网络。网络上的其他成员检查 Alice 是否拥有这个信息币。如果如此，他们广播消息“是的，Alice 拥有信息币 1234567，现在这条消息可以发送给 Bob”。一旦足够多的人广播这条消息，每个人都更新他们的区块链以显示信息币现在属于 Bob，交易将完成。\n目前这个协议有许多不准确的元素。例如，什么是“一旦足够多的人广播了这条消息”？这里的“足够”到底意味着什么？它可以意味着网络里的每一个人，因为我们无法预先知道谁在这个信息币网络里。出于同样的原因，它不能意味着网络内一些固定的用户。我们现在不试着使这些想法变准确。取而代之，在下一个部分我会指出一个严重的问题和方法按照所描述。解决那个问题将同时有良好的副作用可以使得上面的想法更加准确。\n工作证据（Proof-of-work）\n假设 Alice 想要支付双份，以我刚描述的基于网络的协议。她可以通过接管信息币网络来这么做。让我们假设她使用了一个自动化系统建立了非常大量的独立身份，让我假设是十亿个，在信息币网络上。正如此前，她想支付双份，同时将一个信息币发送给 Bob 和 Charlie。但是当 Bob 和 Charlie 询问网络以验证他们对于交易的观点，Alice 的傀儡身份在网络中向 Bob 声称他们验证了这笔交易，并告诉 Charlie 他们验证了这笔交易，可能同时愚弄一个或二者同时去接受这笔交易。\n有一个聪明的方法可以避免这个问题，使用一个被称为工作证据的想法。这个想法是违反直觉的并且设计到两个概念的结合：（1）去（人工）使得对于网络用户验证交易变得从计算角度花费很大（昂贵）（原文：to (artificially) make it computationally costly for network users to validate transactions）；(2) 奖励那些试图帮助验证交易的人。奖励被使用，这样网络上的用户就会努力去帮忙验证交易。虽然那样会导致一个计算非常昂贵的过程。使得验证交易变得昂贵的收益是不再会受网络身份的某些人控制的影响，而只有通过总的计算力量才能施加在验证上（原文：The benefit of making it costly to validate transactions is that validation can no longer be influenced by the number of network identities someone controls, but only by the total computational power they can bring to bear on validation.）我们会看到，用一些聪明的设计我们可以让骗子欺骗需要巨大的计算资源，使得其不切实际。\n这是 Proof-of-work 的要点。但要真正理解其，我们需要深究细节。\n假定 Alice 向网络广播一条消息“我，爱丽丝，给 Bob 一个信息币，以序列号 1234567”。\n当别人在网络上听到这条消息，每个人将其添加进一个他们被告知的交易等待队列，但他们还尚未被网络所批准。举个例子，另一个网络用户名叫 David 可能有以下交易等待队列：\n我，Tom，给 Sue 一个信息币，以序列号 1201174 我，Sydney，给 Cynthia 一个信息币，以序列号 1295618 我，Alice，给 Bob 一个信息币，以序列号 1234567\nDavid 检查自己的区块链，并可以看到每一笔交易都是有效的。他想通过广播整个网络这个有效性来帮忙。\n然而，在此之前，作为验证协议的一部分，David 被要求去解决一个困难的计算难题——the proof-of-work。没有对于这个难题的解决，网络的其他人不会接受他对于这笔交易的验证。\nDavid 需要解决的是一个怎样的难题呢？为了解释它，让 h 作为一个固定的散列函数，被网络内的每一个人所知道——被建立在协议内。比特币使用著名的 SHA-256 散列函数，但是任何加密安全散列函数都可以。让我们给 David 的交易等待队列一个标签 l，这样它有了名字可以被用来谈及。假设 David 为 l 附上一个数字 x（称为 nonce）并为其组合求哈希。举个例子，如果我们使用 l=\u0026ldquo;Hello,world!\u0026quot;(显然这不是一个交易清单，只是一个用于演示目的的字符串)和临时值（nonce）x=0（输出是一个十六进制）\nh(\u0026#34;Hello,world!0\u0026#34;) = 1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64 David 需要解决的难题是——the proof-of-work——去找到一个临时值（nonce）x，这样当我们将 x 附加于 l 并求其组合的散列值，输出的哈希值以很长一段 0 开头。这里的困难可以被变得更加困难或更加简单通过改变解决这个困难所需要的 0 的数量。一个较为简单的 proof-of-work 难题可能在哈希值的头部只需要 3 个或 4 个 0，然而一个较为困难的 proof-of-work 难题可能需要更长的一串 0，比如 15 个连续的 0。在任何一种情况，上述找到合适的临时值尝试，用 x=0，都是一个失败，因为输出的开头根本就不含任何的 0。尝试用 x=1 也没有效果。\nhttp://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works proof-of-work ","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-18-how-bitcorn-works-translation/","summary":"本文翻译自 13 年一篇关于比特币协议的深度解析文章\n成千上万篇文章为了解释比特币这一线上、点对点的货币而撰写。大多数文章对于其底层加密协议都只给出一些简短的解释，却忽略了很多细节。甚至那些文章常常掩盖重点进行更深入的研究。我这篇文章的目的是以一种清晰、容易理解的方式解释隐藏在比特币协议后面的主要思想。我们将从第一原则开始，对于比特币如何工作建立一个广义的理论上的理解，然后再深挖其细节，检查比特币交易的原始数据。\n以细节的方式理解协议是一项困难的工作。人们转而接受比特币，并从事投机关于如何通过比特币致富、比特币吧是否泡沫，比特币是否意味着税收结束的一天等等。这很有趣，但是严重限制你理解它。理解比特币的协议细节打开了难以进入的远景。特别是，理解比特币内建脚本语言的基础会使得使用比特币创造新的金融工具成为可能，比如智能合同。反过来，新的金融工具可以被用来创造新的市场并缔造人类行为新的集合形式。聊聊这些趣事吧！\n我会在后面的文章中描述比特币脚本和一些概念，比如智能合同。这篇文章集中解释比特币协议的核心。理解这篇文章你需要对公钥加密以及与其紧密关联的数字签名概念比较熟悉。我将同样假定你对加密散列概念熟悉。以上这些都没有特别难理解的。基本概念都会在大学的大一数学课程或者计算机课程中教授。这些概念很优雅，所以如果你对于他们不是很熟悉，我建议你先花一点时间熟悉一下。\n也许看上去比较神奇，比特币的基础是密码学。比特币不是一种货币？不是一种发送秘密信息的方式？事实上，比特币需要解决的事情大部分是安全事务——确保人们不能互相窃取，或者伪造等等。在原子世界我们通过一些设备，例如锁、保险箱、签名、银行金库实现安全。在比特世界我们通过加密实现安全。这也是为什么比特币的核心是加密协议。\n我在这篇文章中的策略是分阶段建立起比特币。我会通过解释一种非常简单的数字货币开始，所基于的思想几乎显而易见。我们将称其信息货币（Infocoin），以区分于比特币。当然，我们第一个版本的信息币会有很多不足，然后我们会经过多个迭代，每个迭代介绍仅仅一或两个新的想法。经过多个迭代后，我们将达到完整的比特币协议。我们将重新发明了比特币。\n这种策略比起我一次性解释整个比特币协议要慢。但是当你通过这样一次性解释的方式理解了比特币机制时，再去理解比特币为什么这样设计就会很困难。这种通过慢迭代的解释方式优势在于可以让你对于比特币每一个元素理解得更加犀利。\n最后，我应该提及对于比特币我也是个新手。我从 2011 年开始松散地关注（在 20 世纪 90 年代末开始关注加密数字货币），但直到今年早些时候才着重关注比特币协议的细节。所以我将非常感激对于我误解部分的指正。另外在本篇文章中我还包含了很多“留给读者的问题”——在我写作过程中对于新冒出的问题的一些笔记。你会发现这很有趣，但你也可以把它们全部跳过以免丢失全文的线索。\n第一步：签名意图信\n所以我们该如何设计一个数字货币呢？\n从表面上来看，数字货币听起来是不可能的。假设某个人，让我们称其 Alice，她有一些电子钱想花掉。如果 Alice 想使用一串比特字符作为钱，我们如何才能阻止她反复使用相同的比特字符串呢？否则将意味着会产生无穷无尽的钱。或者假如我们可以通过某种方式解决这个问题，但我们如何才能防止其他人伪造这样一串比特字符并用来偷取 Alice 的钱呢？\n这些只是众多问题中的两个，必须被克服以为了使用信息作为货币。\n作为信息币的第一个版本，让我们找到一个方法使得 Alice 可以使用一串字符（非常原始和不完整）作为货币的形式，以某种至少保证她的货币不会被伪造的方式。假设 Alice 想给 Bob 一个信息币。为了这么做，Alice 写下一行字符串“我，爱丽丝，给 Bob 一个信息币”。然后她用私钥给这条信息做了数字签名，并告知全世界 这段签过名的字符串。\n（顺便提一下，我使用首字母大写的 Infocoin 表示信息币协议及一般概念，用首字母小写的 infocoin 特指货币面值，类似用法很常见，虽然在比特币的世界不通用）\n这并不是一个令人非常影响深刻的数字货币原型。但它的确有一些优点。世界上的任何人（包括 Bob）可以使用 Alice 的公钥去确认 Alice 的确是“我，爱丽丝，给 Bob 一个信息币”这条信息签名的主人。没有其他人可以造出这条比特信息。但反过来，Alice 也可以说“不，我没说要给 Bob 一个信息币”。所以这个协议建立在 Alice 真的想给 Bob 一个信息币。同样的事实——没有其他人可以构造这样一条签名信息——也给予 Alice 一些防止其他人伪造的有限保护。当然，在 Alice 创建她的这条信息后也可能其他人复制了这条信息，这样的话伪造是可能的。但无法从头伪造。这两种属性——Alice 建立企图的部分和防止伪造的有限保护部分，是这个协议值得注意的特征。\n我在这个协议中没有（非常）准确地讲数字货币是什么。为了使其明确：特指这条信息本身，例如，这行比特字符串展示了数字货币“我，爱丽丝，给 Bob 一个信息币”。后面的协议类似，我们所有数字货币的形式只是会越来越复杂。\n使用序列号来使得货币被唯一标识\n第一个版本的信息币的问题在于 Alice 可以一次又一次地继续向 Bob 发送相同的签名消息。假定 Bob 收到了十份“我，爱丽丝，给 Bob 一个信息币”这样的拷贝签名信息。意味着 Alice 向 Bob 发送了十个不同的信息币吗？她的信息是巧合复制出来的吗？可能她只是试图戏弄 Bob 使其相信她给了他十个不同的信息币，当这条信息向全世界证明才表示她真的企图传送一个信息币。","title":"比特币协议是如何工作的（译）"},{"content":"关于 Webpack 基础使用的整理\n背景 网站由网页模式进化成 Webapp 模式\n网站运行在高级浏览器中，使用 HTML5、CSS3、ES6 等新技术\nwebapp 通常是单页面应用（每一个视图通过异步方式加载，导致页面初始化和使用过程会加载更多的 js 代码）\n前端开发基于多语言、多层次编码和组织工作，交付基于浏览器，需要保证代码和资源在浏览器端快速优雅的加载和更新，亟需模块化系统\n传统方式 \u0026lt;script src=\u0026#34;module1.js\u0026#34;\u0026gt;\u0026lt;/scrpti\u0026gt; \u0026lt;script src=\u0026#34;module2.js\u0026#34;\u0026gt;\u0026lt;/scrpti\u0026gt; \u0026lt;script src=\u0026#34;module3.js\u0026#34;\u0026gt;\u0026lt;/scrpti\u0026gt; ... 弊端 全局作用域（定义在 window 对象下）下易造成变量冲突\n文件只能按照脚本引入的顺序加载\n需要主观解决模块和代码库的依赖关系\n大型项目中资源难以管理，长期积累导致代码库混乱不堪\nCommonJS 服务端的 Node.js 遵循 CommonJS 规范\n核心思想 允许模块通过 require 方法来同步加载要依赖的其他模块 通过 exports 或 module.exports 导出需要暴露的接口 require(\u0026#34;module\u0026#34;); require(\u0026#34;../file.js\u0026#34;); exports.doStuff = function() {}; module.exports = someValue; 优势 服务端模块便于重用 NPM 中已有大量可用模块包（20w） 简单易用 缺陷 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 ES6 模块 ES6 标准增加了 js 语言层面的模块体系定义\nES6 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。\n优势 易于进行静态分析 面向未来 ES 标准 缺陷 原生浏览器未实现该标准 全新命令字，新版 Node.js 才支持 静态分析 编译时对整个代码进行静态分析，分析出各模块的类型和依赖关系，将不同类型的模块交由相应的加载器处理。\nWebpack 概念 Webpack 是一个模块打包器。\n根据模块的依赖关系进行静态分析，然后将模块按照指定的规则生成对应的静态资源\n现有模块化工具无法实现 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可视作模块 将第三方库整合成模块 自定义打包逻辑 适合无论单页或多页的 Web 应用大项目 Webpack 特点 代码拆分 Loader 智能解析 插件系统 快速运行 代码拆分 两种组织模块依赖的方式：同步、异步、 异步依赖作为分割点，形成新的块 优化了依赖树后，每一个异步区块都作为一个文件被打包 Loader Webpack 本身只能处理原生 js 模块 loader 转换器可将各种类型的资源转换成 js 模块 智能解析 Webpack 有一个智能解析器，几乎可以处理任何第三方库\n无论模块形式是 CommonJS 或是普通 js 文件\n加载依赖时甚至允许动态表达式\nrequire(\u0026#34;./templates/\u0026#34; + name + \u0026#34;.jade\u0026#34;) 插件系统 Webpack 有一个功能丰富的插件系统\n可开发和使用开源插件满足各式需求\n快速运行 Webpack 使用异步 I/O 和多级缓存提高运行效率\n安装 Webpack 需要 Node.js v0.6 以上支持\n使用 npm 全局安装\nnpm install webpack -g 将 Webpack 安装到项目的依赖中\nnpm install webpack --save-dev 使用 index.html\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;scritp src=\u0026#34;bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; entry.js\ndocument.write(\u0026#39;Hello world\u0026#39;) 编译 entry.js 并打包到 bundle.js\nwebpack entry.js bundle.js 访问 index.html 即可\n添加模块 module.js\nmodule.exports = \u0026#39;It works from module.js.\u0026#39; entry.js\ndocument.write(\u0026#39;Hello world\u0026#39;) document.write(require(\u0026#39;./module.js\u0026#39;)) 打包\nwebpack entry.js bundle.js 分析 webpack 分析入口文件，解析包含依赖关系的各个文件\n这些文件（模块）都打包到 bundle.js\nwebpack 给每个模块分配一个唯一 ID 并通过 ID 索引和访问模块\n页面启动时先执行 entry.js，其他模块在运行 require 时再执行\nloader 背景 webpack 本身只能处理 js 模块，其他类型文件需要 loader 进行转换\nloader 本身一个函数，接受源文件为参数，返回转换结果\nloader 特性 可通过管道方式链式调用，每个 loader 可将资源转换成任意格式并传递给下一个 loader，最后一个 loader 必须返回 js 可同步或异步执行 运行在 node.js 环境中，可做任何可能的事情 可接受参数，以此传递配置给 loader 可通过文件拓展名（或正则表达式）绑定给不同类型的文件 可通过 npm 发布和安装 除了通过 package.json 和 main 指定，通常的模块也可导出一个 loader 来使用 可访问配置 支持插件 可分发出附件的任意文件 loader 命名 一般为 xxx-loader，xxx 为转换的功能，例如 json-loader\n引用 loader 时可通过全名（json-loader）或短名(json)\n命名规则和搜索优先级顺序在 resolveLoader.moduleTemplates API 中定义\nDefault: [\u0026#34;*-webpack-loader\u0026#34;, \u0026#34;*-web-loader\u0026#34;, \u0026#34;*-loader\u0026#34;, \u0026#34;*\u0026#34;] 添加方式 在 require()引用模块时添加 webpack 全局配置中绑定 命令行方式 场景 在页面引入一个 CSS 文件 style.css\nbody { background: yellow; } entry.js\n// 载入style.css require(\u0026#34;!style-loader!css-loader!./style.css\u0026#34;) document.write(\u0026#39;Hello world.\u0026#39;) document.write(require(\u0026#39;./module.js\u0026#39;)) 处理 将 style.css 看作一个模块\n用 css-loader 读取\n用 style-loader 把它插入页面\n安装 loader npm install css-loader style-loader 即可\n改进 根据模块类型（拓展名）自动绑定需要的 loader，避免每次 require CSS 文件时都写 loader 前缀\nentry.js\nrequire(\u0026#34;!style!css!./style.css\u0026#34;) 修改为\nrequire(\u0026#34;./style.css\u0026#34;) 打包 webpack entry.js bundle.js --module-bind \u0026#34;css=style-loader!css-loader\u0026#34; Bingo! 效果一样\n只不过是在打包环节根据模块类型绑定需要的 loader，不需要在 require 中写 loader 前缀\n配置文件 上面通过在命令行在执行 webpack 时传入参数，可通过指定配置文件来执行\n默认搜索当前目录 webpack.config.js\n该文件是一个 node.js 模块，返回一个 json 格式的配置信息对象\n可通过\u0026ndash;config 选项指定配置文件\n具体操作 创建 package.json 添加 webpack 需要的依赖\n{ \u0026#34;name\u0026#34;: \u0026#34;my-webpack\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A simple webpack example\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;bundle.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [ \u0026#34;webpack\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;igam\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;css-loader\u0026#34;: \u0026#34;^0.21.0\u0026#34;, \u0026#34;style-loader\u0026#34;: \u0026#34;^0.13.0\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;^1.12.2\u0026#34; } } 根据 package.json 下载依赖模块\nnpm install 创建配置文件 webpack.config.js\nvar webpack = require(\u0026#39;webpack\u0026#39;) module.exports = { entry: \u0026#39;./entry.js\u0026#39;, output: { path: __dirname, filename: \u0026#39;bundle.js\u0026#39; }, module: { loaders: [ {test: /\\.css$/, loader: \u0026#39;style-loader!css-loader\u0026#39;} ] } } Bingo again!\n插件 一般在配置文件 plugins 选项中指定\nwebpack 内置一些常用插件，还可通过 npm 安装第三方插件\n实例 内置插件 BannerPlugin：给输出的文件头部添加注释\nwebpack.config.js\nvar webpack = require(\u0026#39;webpack\u0026#39;) module.exports = { entry: \u0026#39;./entry.js\u0026#39;, output: { path: __dirname, filename: \u0026#39;bundle.js\u0026#39; }, module: { loaders: [ {test: /\\.css$/, loader: \u0026#39;style-loader!css-loader\u0026#39;} ] }, plugins: [ new webpack.BannerPlugin(\u0026#39;This file is created by igam\u0026#39;) ] } 在 bundle.js 文件头可看见效果\n开发环境 编译时间长，可以通过参数让编译输出内容带有进度和颜色\nwebpack --progress --colors 若不想每次修改模块后重新编译，可启动监听模式\n开启后，没有变化的模块会在编译后缓存到内存中，而非每次重新编译\nwebpack --progress --colors --watch 更好选择 使用 webpack-dev-server 开发服务\n将在 localhost:8080 启动一个 express 静态资源服务器\n以监听模式自动运行 webpack\n访问 http://localhost:8080/或 http://localhost:8080/webpack-dev-server/可浏览项目中的页面和编译后的资源输出，并通过一个 socket.io 服务实时监听变化并自动刷新\n安装 npm install webpack-dev-server -g 运行 webpack -dev-server --progress --colors 故障处理 可通过参数\u0026ndash;display-error-deatils 打印错误详情\nwebpack 的配置提供了 resovle 和 resolveLoader 参数设置模块解析的处理细节\nresolve 配置应用层模块（被打包的模块）解析\nresolveLoader 配置 loader 模块的解析\n当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误\nNode.js 模块的依赖解析算法是通过查看模块的每一层父目录中的 node-modules 文件夹来查询依赖\n当出现 Node.js 模块依赖查找失败时可尝试设置 resolve.fallback 和 resolveLoader.fallback 解决问题\nmodule.exports = { resolve: { fallback: path.join(__dirname, \u0026#34;node_modules\u0026#34;) }, resolveLoader: { fallback: path.join(__dirname, \u0026#34;node_modules\u0026#34;) } } webpack 中设计路径配置最好使用绝对路径，建议使用 path.resolve(**dirname, \u0026ldquo;app/folder\u0026rdquo;)或 path.join(**dirname, \u0026ldquo;app\u0026rdquo;, \u0026ldquo;folder\u0026rdquo;)方式配置，以兼容 Windows 环境\n参考： http://zhaoda.net/webpack-handbook/index.html\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-17-webpack-basic/","summary":"关于 Webpack 基础使用的整理\n背景 网站由网页模式进化成 Webapp 模式\n网站运行在高级浏览器中，使用 HTML5、CSS3、ES6 等新技术\nwebapp 通常是单页面应用（每一个视图通过异步方式加载，导致页面初始化和使用过程会加载更多的 js 代码）\n前端开发基于多语言、多层次编码和组织工作，交付基于浏览器，需要保证代码和资源在浏览器端快速优雅的加载和更新，亟需模块化系统\n传统方式 \u0026lt;script src=\u0026#34;module1.js\u0026#34;\u0026gt;\u0026lt;/scrpti\u0026gt; \u0026lt;script src=\u0026#34;module2.js\u0026#34;\u0026gt;\u0026lt;/scrpti\u0026gt; \u0026lt;script src=\u0026#34;module3.js\u0026#34;\u0026gt;\u0026lt;/scrpti\u0026gt; ... 弊端 全局作用域（定义在 window 对象下）下易造成变量冲突\n文件只能按照脚本引入的顺序加载\n需要主观解决模块和代码库的依赖关系\n大型项目中资源难以管理，长期积累导致代码库混乱不堪\nCommonJS 服务端的 Node.js 遵循 CommonJS 规范\n核心思想 允许模块通过 require 方法来同步加载要依赖的其他模块 通过 exports 或 module.exports 导出需要暴露的接口 require(\u0026#34;module\u0026#34;); require(\u0026#34;../file.js\u0026#34;); exports.doStuff = function() {}; module.exports = someValue; 优势 服务端模块便于重用 NPM 中已有大量可用模块包（20w） 简单易用 缺陷 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 ES6 模块 ES6 标准增加了 js 语言层面的模块体系定义\nES6 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。","title":"webpack学习笔记"},{"content":"本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享\nAPI 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会\n为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量\n好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑\n通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前\n从你将扔掉的实现中拯救你 以下应开始于你正确指定出 API 之前\n从撰写你将扔掉的规范中拯救你 继续写 API 因为它充实你\n避免令人讨厌的惊喜 代码作为例子、单元测试而存在 关于 SPI 的内容甚至更重要 服务提供接口（Service Provider Interface, SPI） 插件式接口使得实现多样性 例如：Java 加密拓展接口（Java Cryptography Extension, JCE） 在发布之前编写多个插件 如果你只写一个，它可能不支持另一种情况 如果你写两个，它会很难支持更多 如果你写三个(原文 three 应表示多个?)，它会良好工作 Will Tracz 称之为“三项法则” （曾经以为程序销售员 Addision-Wesley,1995 的自白）\n保持现实的期望 大多数 API 设计的过约束 你不必取悦每一个人 旨在平等地使每个人都感到高兴 期望犯错 几年真实世界的使用将冲洗它们 期望发展 API II 一般原则 API 应该只做一件事并把它做好 功能应该易于解释 如果很难命名 API，那它通常是一个坏讯号 良好的命名会驱动开发 要易于分割和合并 API 应尽可能的小但不能再小\nAPI 应该满足它的初始需求\n当存疑时就抛弃掉 函数、类、方法、参数等等 你总可以加些什么，但你永远不能去掉什么 概念的重量比实体块的重量更重要 寻找一个好的力量/重量比率（此处应指 API 的作用和轻重之比） 实现不应该影响 API 实现细节 迷惑用户 禁止掉改变 API 实现的自由 意识到实现细节是什么 不要过度指定方法的行为 例如：不要指定散列函数 所有的可调整参数都是可疑的 别让实现细节“泄露”进 API 磁盘上的格式和线上的格式例外 最小化对于所有的可达性 将类和方法指定得尽可能私有\n公共类不应该有公共域（除了常量）\n这最大化了信息隐藏\n允许模块被独立使用、理解、构建、测试、调试\n给 API 命名的事务相当于一种小语言 名字应大部分不言自明（自解释的） 避免模糊的缩写 保持一致——同样的词应表达同样的意思 贯穿 API 的整个内容（包括不同平台上的该 API） 定期争取对称\n代码应该读起来像散文\nif (car.speed() \u0026gt; 2 * SPEED_LIMIT) generateAlert(\u0026#34;Watch out for cops!\u0026#34;); 文档相关事宜 重用是一件说起来容易做起来难的事。具体做起来既需要好的设计又需要良好的文档。即使我们看到好的设计，我们仍很少能看到没有好的文档组件被重用。\nD.L.Parnas, _Software Aging. Proceedings of 16th International Conference Software Engineering, 1994\nDocument Religiously 为每一个类、接口、方法、构造器、参数和异常制作文档（注释） 类：实例所表示的东西 方法：方法和客户之间的契约 先决条件、后置条件、副作用 参数：提示性的单位、格式、所有权 文档要非常认真地陈述\n考虑 API 设计决定的性能后果 糟糕的决定会限制性能 让类型易变 提供构造器以取代静态工厂 使用实现类型取代接口 不要扭曲 API 来获得性能 底层性能问题会被修复，但头疼的事会一直伴随着你 良好的设计通常与良好的性能相吻合 API 设计决策在性能方面的影响是真实并且永久的 Component.getSize() returns Dimension 尺寸是易变的 每一个 getSize 调用都必然分配 Dimension 将导致非常多不必要的对象分配 在 1.2 版本增加替代品，老的客户端代码仍然慢（在新的版本找到解决方案，但不能解决旧代码的性能问题） API 必须和平台和平共存 做习惯性的事 遵守标准的命名约定 避免过时的参数和返回类型 模仿核心 APIs 和语言中的模式 利用 API 友好功能 泛型、可变参数、枚举、默认参数 了解并避免 API 陷阱 常量（Finalizers）、公共静态常量数组 III 类设计 最小化可变性 类应该是不可变的除非有一个好的理由不去这么做\n优点： 简洁、线程安全、可复用 缺点： 对于每个值都分离了对象 如果可变，保证状态空间尽可能小并被良好定义\n搞清何时去调用哪一个方法是合法的 仅在合理的地方建子类 建子类按时可替代性（Liskov）\n子类仅当 is-a 关系时存在 否则，使用组合 公共类不应该再包含其他公共子类，以保证实现简单\n反例： Properties extends Hashtable Stack extends Vector\n正例： Set extends Collection\n为继承做设计和文档否则禁止 继承违反封装（Snyder, 86）\n子类对于父类的实现细节敏感 如果你允许建子类，那么就文档自用\n方法如何相互使用 保守策略：所有具体的类都不可变（final）\n反例：J2SE 包中许多的具体类 正例：AbstractSet, AbstractMap\nIV 方法设计 别让客户端把模板能做的事都做了 减少对样板代码的需要\n通常经 cut-and-paste 完成 丑陋、恼人并且易错 不要违反最小原则 API 的使用者不应该对于某些行为感到惊讶\n值得额外的实现努力 这甚至值得降低性能 public class Thread implements Runnable { // Tests whether current thread has been interrupted // Clears the interrupted status of current thread. public static boolean interrupted(); } 上面的第二行注释所述的功能就做了额外的没必要的努力，违背了最小原则\n当错误发生尽可能快地产生错误报告 编译时报错最佳——静态拼写、generics\n在运行时，第一个方法调用失败为最佳\n方法应该是原子性失败（failure-atomic） // A Properties instance maps strings to strings public class Properties extends Hashtable { public Object put(Object key, Object value); // Throws ClassCastException if this Properties // contains any keys or values that are not strings public void save(OutputStream out, String comments); } 为所有的数据访问提供字符串的形式的编程接口 否则客户端需要做字符串转换 对于客户端来说很痛苦 更糟糕的是，turns strings format into de facto API（无力翻译 orz） public class Throwable { public void printStackTrace(PrintStream s); public StackTraceElement[] getStackTrace();\t// Since 1.4 } public final class StackTraceElement { public String getFilaName(); public int getLineNumber(); public String getClassName(); public String getMethodName(); public boolean isNativeMethod(); } 小心重载 避免模糊的重载 多个重载适用于相同的情况 保守策略：没有两个重载拥有同样多的参数个数 仅仅是因为你可以但不意味着你应当 通常最好使用不同的名字 如果你必须提供模糊的重载，请确保相同的参数拥有相同的行为 反例:\npublic TreeSet(Collection c);\t// Ignores order public TreeSet(SortedSet s);\t// Respects order 使用恰当的参数和返回类型 赞成接口类型作为类的输入\n提供灵活性、性能 使用最具体的可能的输入参数类型\n把运行时错误提前到编译时 如果存在更好的类型请别用 String 类型\nStrings 是繁琐的、易错的并且慢的 不要将浮点数用于货币值\n二进制浮点会导致不精确的结果 使用 double(64 位)优于 float(32 位)\n精确度损失是真实的，性能损失是可忽略的 在方法之间使用一致的参数顺序 如果参数类型相同，尤其重要 反例：\n#include \u0026lt;string.h\u0026gt; char *strcpy (char *dest, char *src); void bcopy (void *src, void *dst, int n); 正例： java.util.Collections——第一个参数总被收集来用于修改或查询\njava.util.concurrent——time 总被指定为 long delay, TimeUnit unit\n避免长参数列表 三个或更少参数是比较理想的\n如果存在更多，用户则需参阅文档 相同类型的长参数列表是有害的\n程序员会错误地转置参数 程序仍会编译、运行，但行为不端 两种缩短参数列表的技巧\n拆分方法 创建辅助类来保存参数 反例：\n// Eleven parameters including four consecutive ints HWND CreateWindow(LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam); 避免返回值需要异常处理 返回零长度数组或空集合而非 null\npackage java.awt.image; public interface BufferedImageOp { // Returns the rendering hints for this operation, // or null if no hints have been set. public RenderingHints getRenderingHints(); } V.异常设计 抛出异常以表明异常的条件 不要强迫客户端去使用异常来控制流\n反例:\nprivate byte[] a = new byte[BUF_SIZE]; void processBuffer (ByteBuffer buf) { try { while (true) { buf.get(a); processBytes(tmp, BUF_SIZE); } } catch (BufferUnderflowException e) { int remaining = buf.remaining(); buf.get(a, 0, remaning); processBytes(bufArray, remaining); } } 反过来，不要安静的失败\n例如：\nThreadGroup.enumerate(Thread[] list) 赞成未经检查的异常 已检查——客户端必须采取修复措施\n未检查——程序报错\n过度使用已检查的异常会导致样板化\n反例：\ntry { Foo f = (Foo) super.clone(); ... } catch (CloneNotSupportedException e) { // This can\u0026#39;t happen, since we\u0026#39;re Cloneable throw new AssertionError(); } 在异常中包含错误捕获信息 允许诊断、修复或恢复\n对于未检查的异常，信息就足够了\n对于已检查的异常，提供访问者\nVI 重构 API 设计 向量的子列表操作 public class Vector { public int indexOf(Object elem, int index); public int lastIndexOf(Object elem, int index); } 不够强大——只支持搜索\n没有文档很难使用\n字列表操作重构 public interface List { List subList(int fromIndex, int toIndex); ... } 非常强大——支持所有的操作\n接口的使用减少了概念的重量\n高功率重量比 没有文档也易于使用\nThread-local 变量 // Broken - inappropriate use of String as capability. // Keys constitue a shared global namespace. public class ThreadLocal { private ThreadLocal() { } // Non-instantiable // Sets current thread\u0026#39;s value for named variable. public static void set(String key, Object value); // Returns current thread\u0026#39;s value for named variable. public static Object get(String key); } Thread-Local 变量重构（1） public class ThreadLocal { private ThreadLocal() { } // Noninstantiable public static class Key {\tKey() { } } // Generates a unique, unforgeable key public static void set(Key key, Object value); public static Object get(Key key); } 有效，但是需要使用样板代码 例如:\nstatic ThreadLocal.Key serialNumberKey = ThreadLocal.getKey(); ThreadLocal.set(serialNumberKey, nextSerialNumber()); System.out.println(ThreadLocal.get(serialNumberKey)); Thread-Local 变量重构（2） public class ThreadLocal { public ThreadLocal() { } public void set(Object value); public Object get(); } 消除 API 和客户端代码之间的混乱 static ThreadLocal serialNumber = new ThreadLocal(); serialNumber.set(nextSerialNumber()); System.out.println(serialNumber.get()); 结论 API 设计是一种高贵且有益的工艺 改进了很多程序员、最终用户和公司 这次谈话涵盖了一些启发式的手艺 不要狂妄地坚持，但\u0026hellip; 不要没有理由的违反 API 设计很难 不是一个孤独的活动 完美是无法实现的，但无论如何都要尝试 个人评价\u0026amp;总结 本文评价了很多 Java 语言包以及面向对象的优点和缺点，也包含 C 语言的部分例子。本文作者 Joshua Bloch 同时也是 Effective Java 的作者。本文中有些用词比较晦涩难懂，但通篇整体很好也很全面地剖析了 API 设计的重要性及一部分技巧和注意事项，值得参考借鉴。\n翻译过程也是磕磕绊绊，很多地方自我感觉翻译的不甚准确，甚至有问题，实在找不到合适的翻译的地方注明了原文或保留原文词句，希望有心读者能指正并反馈。不过翻译的过程的确为了理解作者原意，也会竭尽脑力去思考和体会字里行间所表达的思想，收益良多。 其中不乏有些建议的确出现于日常的编程实践，并作为编程规范存在于最佳实践中，一眼就能理解。也有一些目前可能尚未在实际应用中良好实践。\n原文链接：https://web.archive.org/web/20110903030015/http://lcsd05.cs.tamu.edu/slides/keynote.pdf\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2018-01-16-api-designing-translation/","summary":"本文翻译自 Effective Java 作者 Joshua Bloch 撰写的一篇关于 API 设计的分享\nAPI 可以是公司最大的资产之一 客户投入巨资：购买、撰写、学习（售前一系列培训） 停止使用 API 导致的花费令人望而却步（如果不使用 API 可能要花费更多） 成功的公共 API 赢得客户 也可以成为公司最大的负债之一 糟糕的 APIs 将导致无休止的电话技术支持（需要接听很多来自客户的反映） 公共的 APIs 是永久的——一次去做正确事情的机会\n为什么 API 设计对于你来说很重要 如果你编码，你就是一个 API 的设计者 良好的代码应该是模块化的——每一个模块都有一个 API 有用的模块往往被重用 对于 API 方面的思考将提高代码的质量\n好的 API 所具备的特征 易于学习 易于使用，甚至无需任何文档 不易误用 易于阅读并且对所使用的代码部分易于维护 足够强大以满足需求 易于拓展 适用于大众 大纲 API 设计的过程 一般原则 类设计 方法设计 异常设计 API 重构设计 I API 设计的过程 收集需求——以一种健康的程度怀疑\n通常你会得到建议的解决方法作为替代方案 可能存在更好的解决方案 你的工作是去提取出真正的需求 应采取用例的形式 可以更容易、更有意义地建立更普遍的东西 从简短的规范页开始比较理想 在这个阶段，敏捷胜过完整性 和尽可能多的人谈（原文：Bounce spec off as many people as possible） 倾听他们的输入并认真对待 如果你保持规范简短，那么将易于修改 充分自信 这涉及到编码时也很必要 尽早写给你的 API 以下应开始于在你实现 API 之前","title":"如何设计良好的API并且为什么这很重要（译）"},{"content":"今天就之前疑惑不解的 vultr 账单做了一波分析，终于算是破案了，借此也记录一下服务器搭建 ssr 的详细步骤。\n一开始打开 vultr 账单，我是懵比的\n这里面的加加减减使我很费解，不知道 vultr 的记账方式，也不知道它的扣款方式（原因是我从开通账户后就毫无规律的充值，但服务器的使用却一直未受影响而断过）\n首先我第一反应是看我总共实际花了多少钱。\n我的 vultr 是绑定 Paypal 作为付款方式，而 Paypal 中绑定了两张银行卡，一张储蓄卡，一张信用卡，在查阅了银行卡关于 paypal 的消费记录后统计如下\n然后我试着从 vultr 账单中与之响应对账\n的确找到四笔是通过 paypal 消费的\n现在证实了一点，我一共在 vultr 花费了 17.65 美元，折合人民币 123.6 元\n那么接下来再通过这四笔明确的消费来反推其他账单记录的含义，发现一笔比较特殊的\n计算得到\n由此可见 vultr 是按小时计费，一开始承诺的每月 5 美元，指的是如果你用满一个月（744 个小时，31 天）为 5 美元，而使用就是指你的服务器开启着（记录中一开始有十几天没计费应该是我虽然开通了 vultr 并且也充了值，但是没建立服务器实例，或者说建立的实例没开启）\n归根结底，当服务器开启，每个月还是相当于 5 美元的，这样再看账单可以清晰一点\n那么更进一步，我回想到之前按照首页提示的奖励金额去关注了 vultr 的 twitter 账号，所以有了 11 月这三笔记录\n这三笔很明显是系统审核我的行为后为我以信用账户（accout credit）的方式分别充值了 3 美元\n至此，整体应该算是破案了，我们可以用类比的思想（把陌生的事物类比成熟悉的事物，以便理解）可以理解为，vultr 在开通账户的时候是需要先付款后消费，不存在试用（先免费用，再补交费用）的情况。\n但是当开通账户并充值以后，它的收费方式是每月 1 号，结算上个月的消费实际情况，会给你账单记录中发送一枚发票（invoice），你使用 paypal 进行的主动充值也会有所记录。但是可以先消费，后缴费。具体体现就是你这个月使用的费用是下个月 1 号结算，如果到时候你的 vultr 账户余额不足，它就会从你绑定的支付方式（比如 paypal 或信用卡）中自动扣款。\n最终再次整理账单分析\n下面是在 vultr 上搭建 ssr 的步骤（在国外服务器搭建代理）：\n首先，你得有台服务器，国外服务器，国内服务器也可以，不过达不到“代理”的效果\n然后，你得有 ssr 的客户端 下载\n接着你只需要在你的服务器上安装 ssr 服务，再通过 ssr 客户端访问，就可以实现让你电脑上的网络访问经由代理处理。\n代理的作用就是，首先它是国外的服务器，它可以轻松访问很多国外的资源，比如谷歌，比如 youtube。然后它作为你的代理帮你拿到这些资源后，你和代理有着亲密的关系（通过 ssr），这时你访问谷歌或者 youtube，实际是在访问代理替你拿到的资源。（whatever）最终你实现了访问你本来访问不到的资源这样的效果。\n这么看来，关键在于搭建 ssr 服务这一步（和代理服务器搞好关系），那么其实这个操作也没什么难度，因为已经有大佬写了 ssr 这个东西，你只是需要安装而已。\n有这样的一键安装脚本\n不检查证书安装 shadowsocksR\nwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh 将 shadowsocksR 设置为可执行\nchmod +x shadowsocksR.sh 执行 shadowsocksR 并记录日志\n./shadowsocksR.sh 2\u0026gt;\u0026amp;1 | tee shadowsocksR.log 安装过程中会提示你输入一些东西（当然，也会提示你如果不填会有默认项）\n密码：设置你通过 ssr 客户端连接 ssr 服务的密码\n服务端口：设置你的 ssr 服务在服务器上开放哪个端口提供外部访问\n以及加密方式等 balabala 其他参数信息（都可以根据提示填好，提示很清晰，只需英语好）\n最后，重启服务器\nreboot 在你本地的 ssr 客户端填入刚才在服务器设置的一系列参数（密码、端口、加密方式及其他）即可愉快地科学上网啦\n拓展：卸载 shadowsocksR 方法（当然，你要在安装 shadowsocks 的目录执行该命令）\n./shadowsocks-go.sh uninstall 参考链接：\nhttps://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B ","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-28-vultr-billing-and-ssr-on-vultr/","summary":"今天就之前疑惑不解的 vultr 账单做了一波分析，终于算是破案了，借此也记录一下服务器搭建 ssr 的详细步骤。\n一开始打开 vultr 账单，我是懵比的\n这里面的加加减减使我很费解，不知道 vultr 的记账方式，也不知道它的扣款方式（原因是我从开通账户后就毫无规律的充值，但服务器的使用却一直未受影响而断过）\n首先我第一反应是看我总共实际花了多少钱。\n我的 vultr 是绑定 Paypal 作为付款方式，而 Paypal 中绑定了两张银行卡，一张储蓄卡，一张信用卡，在查阅了银行卡关于 paypal 的消费记录后统计如下\n然后我试着从 vultr 账单中与之响应对账\n的确找到四笔是通过 paypal 消费的\n现在证实了一点，我一共在 vultr 花费了 17.65 美元，折合人民币 123.6 元\n那么接下来再通过这四笔明确的消费来反推其他账单记录的含义，发现一笔比较特殊的\n计算得到\n由此可见 vultr 是按小时计费，一开始承诺的每月 5 美元，指的是如果你用满一个月（744 个小时，31 天）为 5 美元，而使用就是指你的服务器开启着（记录中一开始有十几天没计费应该是我虽然开通了 vultr 并且也充了值，但是没建立服务器实例，或者说建立的实例没开启）\n归根结底，当服务器开启，每个月还是相当于 5 美元的，这样再看账单可以清晰一点\n那么更进一步，我回想到之前按照首页提示的奖励金额去关注了 vultr 的 twitter 账号，所以有了 11 月这三笔记录\n这三笔很明显是系统审核我的行为后为我以信用账户（accout credit）的方式分别充值了 3 美元\n至此，整体应该算是破案了，我们可以用类比的思想（把陌生的事物类比成熟悉的事物，以便理解）可以理解为，vultr 在开通账户的时候是需要先付款后消费，不存在试用（先免费用，再补交费用）的情况。\n但是当开通账户并充值以后，它的收费方式是每月 1 号，结算上个月的消费实际情况，会给你账单记录中发送一枚发票（invoice），你使用 paypal 进行的主动充值也会有所记录。但是可以先消费，后缴费。具体体现就是你这个月使用的费用是下个月 1 号结算，如果到时候你的 vultr 账户余额不足，它就会从你绑定的支付方式（比如 paypal 或信用卡）中自动扣款。","title":"vultr账单解析及使用ssr在vultr搭建代理"},{"content":"使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。\n正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。\nhexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。\n假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。\n那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。\n操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录\n可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录\ngit init 这样 hexo 主目录会多一个隐藏目录.git\n创建本地分支，与远端的分支对应\ngit checkout -b source 然后将 hexo 主目录的所有文件按照.gitignore 文件的配置交由 git 管理（hexo 原主目录中的.gitignore 配置即可，过滤了 node_modules 目录、public 目录、deploy 目录，node_modules 目录是 hexo 使用到的相关 node 模块，不必上传，否则会出错，后面两个目录会在 hexo g -d 时发生变化，也不需要上传）\ngit add . git commmit -m \u0026#34;commit hexo files to remote\u0026#34; git push 添加远程仓库\ngit remote add origin URL 将本地当前分支（source）的文件上传到远端仓库的 source 分支（此命令会自动在远端仓库创建 source 分支）\n这样就实现了将 hexo 工程交由 git 管理，并在远端仓库进行备份的操作\n接下来就是异地恢复\n首先，我们要下载的是 hexo 原工程目录的文件，而不是发布后的。当前远端仓库有两个分支，主干分支存储着 hexo 发布后的文件，source 分支存储 hexo 原始工程文件。所以我们需要将远端仓库的默认分支设置为 source（master 仅用于访问，而 source 用于下载）\n然后就是克隆 source 分支的文件\ngit clone URL 本地仓库名（任意起） 然后进入本地下载下来的仓库\ncd 本地仓库名 这个时候能看到 hexo 原始工程的大部分文件，但由于上传的时候.gitignore 过滤了一些文件没上传，所以需要在本地自行生成那些文件，方式如下：\nnpm install hexo 这个命令可以通过 node 的包管理器在当前目录下载 hexo 所需要的模块，即会生成一个 node_modules 目录\n然后生成一些 hexo 初始配置文件\nhexo init 因为当前目录已经包含一些 hexo 初始文件，所以敲该命令时会提示有些重复文件未生成，没有问题，我们只需要补全那些没有的初始文件，已存在的当然就用从远端下载下来的，比如主配置文件_config.yml\n然后更新 npm 并下载发布工具\nnpm install npm install hexo-deployer-git 这样就完成了本地恢复博客所有结构的操作。\n最后，可以创建新的博文，然后更新到远端，然后在本地发布。\n每次使用前只需要拉下最新的文件，在其基础上操作即可。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-hexo-backup-using-git-branch/","summary":"使用一台电脑使用 hexo 创建博文、生成静态文件、发布，没毛病，但由于 hexo 在本地生成静态文件的模式，如果你换一台电脑呢？很明显你需要把原始电脑上的 hexo 文件夹拷贝到新电脑。这样带来的问题就是多台电脑上的 hexo 不能总保持同步，需要通过物理拷贝的方式，很不方便。\n正文 实现方式可能有多种，但我看到的主流方式是通过在远端仓库添加分支来保存 hexo 原始文件来将你的整个博客工程交由 git 管理。\nhexo 本身的确是通过 git 发布到远端的，也就是借助 hexo-deployer-git 这个 nodejs 模块，但其功能是将 hexo 发布目录（public）里的静态文件上传至远端仓库，因为远端仓库是通过 pages 服务直接访问仓库文件，需要保证仓库文件符合 web 可访问结构。\n假如你把 hexo 原始工程目录上传到你的同名仓库来实现 pages 服务，是无法正常访问的。\n那么我们可以再建一个仓库来管理 hexo 原始工程文件，但没必要，这里通过在原仓库上添加分支来保存 hexo 原始工程文件，达到管理的目的。\n操作步骤 hexo 主目录默认有一个.gitignore 文件，暗示可以通过 git 管理 hexo 主目录\n可以在 hexo 主目录通过 git bash here 唤出 git bash，然后 git 初始化 hexo 主目录\ngit init 这样 hexo 主目录会多一个隐藏目录.git\n创建本地分支，与远端的分支对应\ngit checkout -b source 然后将 hexo 主目录的所有文件按照.","title":"使用分支备份hexo博客"},{"content":"虽说 markdown 用了一段时间，但还未曾专门地阅读文档对其进行过相对系统的学习。刚才使用分割线时发现分割线下面的文字变成标题般字体，专门查了一波，发现还是有必要系统学习一下 md 语法，以节省日后使用时的查阅时间。\n宗旨 易读易写\n一份使用 markdown 格式撰写的文档理应可以直接以纯文本发布，也就意味着 markdown 的一系列标签语法对于纯文本来说应该是低浸入、无感知的，用户阅读不会因为增加了 md 标签而变得晦涩。\n这点区别于 HTML 语言至少还需要掌握 HTML 编程语法，才能理解部分标签的使用规则。\n灵感 markdown 最大灵感源自纯文本电子邮件的格式（可能人们对于纯文本的电子邮件格式觉得太过单调，于是通过添加一些小标记，来增加丰富的格式）\n目标 成为一种适用于网络的书写语言 markdown 并非要取代 HTML，甚至也没有要和它相近。\n相比 HTML，markdown 语法种类少，仅对应 HTML 标记的一小部分\n让文档更容易读、写、随意改 易读的前提就是 md 的标记需要尽量的没有侵入感，比如一篇纯文本文档增加 md 标记后不会影响原始阅读感受\n易写易改的要求则是 md 的语法标记需要同 HTML 一样“语义化”，能够见标知意\n兼容 HTML 区块标签 一些 HTML 区块元素比如\u0026lt;div\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;pre\u0026gt;、\u0026lt;p\u0026gt;等，必须在其前后加上空行与其他内容隔开，并且开始标签与结束标签不能用制表符（Tab）或空格来进行缩进。 （下面实例的缩进实现方式是通过 HTML 的 pre 标签，使其内部的 markdown 语法失效）\n比如这里的 HTML 标签如果我想要以标签的样子显示在屏幕上，那我其实需要在文本里通过 md 标记来编辑，类似使用 code 标签、转义字符（通过转义字符来“画出”尖括号，code 标签可以使其成为块状文本）\n另外，markdown 生成器不会在 HTML 区块标签外加上不必要的\u0026lt;p\u0026gt;标签，区别于对于 HTML 文本进行编辑时，若你写了大段内容而未加任何标签的话，HTML 生成器会为你在内容前后加上\u0026lt;p\u0026gt;标签\n实例如下：\n注意！在 HTML 区块标签区间的 Markdown 语法将不会被处理\n区段（行内）标签 HTML 行内标签比如\u0026lt;span\u0026gt;、\u0026lt;cite\u0026gt;、\u0026lt;del\u0026gt;可以在 Markdown 的段落、列表或是标题内随意使用，比如直接使用\u0026lt;a\u0026gt;标签撰写超链接、使用\u0026lt;img\u0026gt;标签取代 md 的\n（当想要 md 标签直接显示在屏幕上，而不被 markdown 生成器处理，可以将其写在 HTML 区块标签内）\n总结：HTML 区块内的 md 标签不生效，HTML 区段内的 md 标签生效\n特殊字符自动转换 balabala\n上面这个 a 标签超链接 href 中的 https://balabala\u0026amp;balabala 会被解析成 https://balabala%26balabala/\n（这一点我看到的时候，瞬间感觉到头皮发麻，因为我之前博客里的参考链接都是使用 HTML 的 a 标签，也就意味着如果连接内包含\u0026amp;字符的话，其实应该要改写成\u0026amp;amp;才能被正确的解析）转义还真是门学问-_-||\n如果你下在页面显示出 AT\u0026amp;T，其实需要在 md 文件中写成 AT\u0026amp;amp;T，而想要显示 AT\u0026amp;amp;T，则要在 md 中写成 AT**\u0026amp;amp;**apm;T，别绕晕，总之需要通过\u0026amp;amp;这个转义符来“渲染”\u0026amp;符，即遇到想要显示\u0026amp;的地方使用\u0026amp;amp;来转义，理清之后会觉得转义很有意思 : ）\n那么究竟 markdown 对于\u0026amp;的处理方式是如何的呢？答案是：视情况而定\n不做转换 当\u0026amp;是 HTML 字符实体的一部分时，它会不做干涉\n比如你在 md 内写到\u0026amp;copy;\n会被解析成©\n（注意：当想你的 md 某段内容包含 md 标签时，请不要在外部套上 HTML 区块标签，因为那会使 md 标签失效）\n转换 而如果你在 md 中写的\u0026amp;不是 HTML 字符实体的一部分的话，它就会被转换成\u0026amp;amp;\nmarkdown 这么做充分体现其兼容 HTML 的做法\n（当多行引用标记连续使用时，若其中某一行进行缩进，会在引用的基础上增加层次）\n4 \u0026lt; 5\n4 \u0026lt; 5\n在 code 范围内，不论是行内还是区块，\u0026lt;和\u0026amp;两个符号都一定会被转换成 HTML 实体，这项特性可以使你轻易地使用 md 写 HTML code，相比在 HTML 文档中需要把所有的\u0026lt;和\u0026amp;转换为 HTML 实体才能在 HTML 文件内写 HTML code\n上面这段话的意思就是在 html 文件里，遇到\u0026amp;或是\u0026lt;，需要以\u0026amp;amp;或是\u0026amp;lt;这样的 HTML 实体来表示之后，才能正常地编写 html code，但是在 markdown 里不需要这一步，\n\u0026lt;span\u0026gt;\u0026lt;code\u0026gt;4 \u0026amp;\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;code\u0026gt;4 \u0026lt; 5\u0026lt;/code\u0026gt;\n\u0026lt;code\u0026gt;\u0026lt;code\u0026gt;\n参考链接：\nhttp://www.appinn.com/markdown/ ","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-markdown-programmer/","summary":"虽说 markdown 用了一段时间，但还未曾专门地阅读文档对其进行过相对系统的学习。刚才使用分割线时发现分割线下面的文字变成标题般字体，专门查了一波，发现还是有必要系统学习一下 md 语法，以节省日后使用时的查阅时间。\n宗旨 易读易写\n一份使用 markdown 格式撰写的文档理应可以直接以纯文本发布，也就意味着 markdown 的一系列标签语法对于纯文本来说应该是低浸入、无感知的，用户阅读不会因为增加了 md 标签而变得晦涩。\n这点区别于 HTML 语言至少还需要掌握 HTML 编程语法，才能理解部分标签的使用规则。\n灵感 markdown 最大灵感源自纯文本电子邮件的格式（可能人们对于纯文本的电子邮件格式觉得太过单调，于是通过添加一些小标记，来增加丰富的格式）\n目标 成为一种适用于网络的书写语言 markdown 并非要取代 HTML，甚至也没有要和它相近。\n相比 HTML，markdown 语法种类少，仅对应 HTML 标记的一小部分\n让文档更容易读、写、随意改 易读的前提就是 md 的标记需要尽量的没有侵入感，比如一篇纯文本文档增加 md 标记后不会影响原始阅读感受\n易写易改的要求则是 md 的语法标记需要同 HTML 一样“语义化”，能够见标知意\n兼容 HTML 区块标签 一些 HTML 区块元素比如\u0026lt;div\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;pre\u0026gt;、\u0026lt;p\u0026gt;等，必须在其前后加上空行与其他内容隔开，并且开始标签与结束标签不能用制表符（Tab）或空格来进行缩进。 （下面实例的缩进实现方式是通过 HTML 的 pre 标签，使其内部的 markdown 语法失效）\n比如这里的 HTML 标签如果我想要以标签的样子显示在屏幕上，那我其实需要在文本里通过 md 标记来编辑，类似使用 code 标签、转义字符（通过转义字符来“画出”尖括号，code 标签可以使其成为块状文本）\n另外，markdown 生成器不会在 HTML 区块标签外加上不必要的\u0026lt;p\u0026gt;标签，区别于对于 HTML 文本进行编辑时，若你写了大段内容而未加任何标签的话，HTML 生成器会为你在内容前后加上\u0026lt;p\u0026gt;标签","title":"Markdown语法学习整理"},{"content":"对于 Git 学习的一些整理，包含常用命令整理\n个人觉得，对于一些开源工具，最好的学习资源还是其官网，我们就先来分析一波 Git 究竟是做什么的。\n概念解析 git 官网的定义是：Git 是一种免费并且开源的分布式版本控制系统，被设计用来快速高效地处理堆积成大工程的每一块小部分。（个人翻译，不喜勿喷）\nGit 简单易用、占用空间小并且性能优越。它远超过一些伴有类似廉价的本地分支、方便的阶段区域和多工作流特点的配置管理工具（SCM，Software Configuration Management），比如 SVN、CVS、Perforce 和 ClearCase 这些。\nGit 允许同一组下的人们同一时刻在相同的文档上工作（通常是代码），并且不会踩到其他人的脚趾（形容两个人同时在相同的文档上工作也不会发生冲突）\n特性 小而快速（Small and Fast） 分布式（Distributed,这也是它比 SVN 优势明显的地方） 数据保证（Data Assurance） 分阶段区域（Staging Area） 免费并开源（Free and Open Source） 教程 初级教程：Try Git\n高级教程：gitreal\n官方书籍：Pro Git\n使用步骤（包含常见命令） 1.初始化\ngit init init 命令会创建一系列 git 结构的文件\n仅对一个制定目录创建 git 结构时使用，用于将某个目录交给 git 管理\n2.查看 git 状态\ngit status 可在任何时间阶段使用， 以查看当前 git 管理下的文件状态\n3.将文件交予 git 管理\ngit add filename 对于在 git init 后的目录里的每一个文件都有 tracked 和 untracked 两种状态，也就是是否被 git 追溯（管理）\n对于每一个文件，要么通过 git add 交由 git 管理，要么加入 ignore 行列，不然新创建的文件就会处于不受 git 管理的“游离”状态。\n当对于新创建的文件操作 git add 之后，文件就会处于 Staging Area（阶段区域），在 commit 之前还尚未放进 git 的仓库（repository），所以在文件到仓库之前，我们可以将文件添加（add）进或是移出 Staging Area（暂存区）\n当然我们也可以对文件进行批量添加到暂存区，比如 git add \u0026lsquo;*.txt\u0026rsquo;来将所有后缀为 txt 的文件添加进暂存区（注意引号）\n4.将暂存区的文件提交到仓库\ngit commit -m \u0026#34;提交注释\u0026#34; 5.查看提交历史\ngit log 6.将本地仓库与远端仓库建立关联 为了将本地仓库推到远端 Github 服务器中（Push local Repo to Github Server），我们需要添加一个远端仓库（add a remote repository）\ngit remote add origin `Remote Repository URL` 这条命令初学者看起来晦涩难懂，我也是研究了很多遍才大致理解，首先这与普通的 git add 不同的是，git add 是将本地新建的文件添加到 git 的暂存区，而 git remote add 是表示添加一个远端仓库，与本地的仓库建立关联。\n默认取名 origin，直观易懂，后面的 URL 也就是远端仓库的地址，虽然在远端（Github）创建仓库的时候我们创建了名字，但现在毕竟本地还没有那个仓库，所以相当于先在本地创建一个空名字，以备和远端的实体仓库对应。\n当你使用 git remote 命令时，可以看到你 add 的“虚拟”远端仓库，它们的地址就是你 add 时最后的 URL\n7.将本地仓库内容推到远端\ngit push -u origin master 我们表示远端仓库的代号是 origin，默认的本地分支名是 master，-u 是告诉 git 去记住这两个参数（origin master），这样下次提交就可以简化为 git push\n经过上面的 7 个步骤，我们就完成了在本地创建 git 仓库，并创建文件交由 git 管理，并将本地仓库与远端仓库进行关联，再将本地仓库的文件上推到远端仓库\n接下来是关于远端发生变更，本地来查看（比如其他人 fork 了你的仓库，并且 commit 了内容，并 pull request）\n8.将远端仓库的最新文件拉到本地\ngit pull origin master 看懂 git push origin master 再来看这条命令就好理解一些，git pull 是拉（下载）代码，也就是从远端往本地拉，然而其实本地的 origin 其实就是一个关联了远端仓库的钩子，你从 origin 拉代码就是从远端仓库拉代码，而拉下来的代码要放在哪个分支，这里选择了 master 主干分支\n9.对比拉下来的远端仓库最新代码和本地的区别\ngit diff HEAD HEAD 是一个指针，指向我们最新 commit 的地方，不加 HEAD，默认也是与 HEAD 对比\n其他命令 10.使用 diff 命令对比暂存区文件之间的区别\ngit diff --staged 前面提到过 git add 命令是将文件添加入暂存区，即 add to stage\n11.回撤 add 行为\ngit reset 我们可以通过 git add 将文件交由 git 管理，同样也可以通过 git reset 将文件脱离 git 管理，即移出暂存区（unstage file）。 当执行完 git reset somefile 后，somefile 会脱离 git 管理，但文件依旧会在那里。\n12.Undo\ngit checkout -- somefile（注意破折号与文件名之间有一个空格，否则会提示“未定义的选项‘--文件名’”） 可以通过 git checkout 命令将文件恢复成它们上一次提交前的样子\n13.创建分支（branch out）\ngit branch branchname 当需要在主分支之外开发新功能或者修改 bug，需要拉另外的分支以与主分支分离，来进行提交，当工作完成后可以再将其分支合并回主分支（merge back to master） 当直接输入 git branch 命令是查看当前分支情况，当 git branch 后面加任意名字即为创建新的分支\n14.切换分支\ngit checkout branchname 15.清除文件\ngit rm filename git rm 命令不仅会删除你本地的实体文件，还会同时将这些删除行为追溯到 git（stage these removal） 删除时同样可以使用通配符（wildcard）来一次清扫多个文件，例如 git rm \u0026lsquo;*.txt\u0026rsquo; 当然这些删除行为也需要通过 commit 来通知仓库，尽管是删除文件，但对于 git 来说都是新增一次操作 此时在新建的分支，将所有的文件删除并提交，仅是对本分支的操作，当切换到主分支时，主分支依然是原样（分支相当于对主分支的拷贝，然而实际实现并不是通过拷贝实现）\n16.合并分支\ngit merge branchname git merge 是将输入的分支合并到当前分支，一般是切回到主分支，执行合并命令，来将其他某一个分支合并到主分支\n17.删除分支\ngit branch -d branchname 当分支合并回主分支后，就没用了，可以进行删除\n使用场景 1.先在本地通过 git 创建工程，然后上传到远程新建的空仓库(Github)\n2.在远端仓库（Github）创建文件或工程，克隆到本地，进行修改后再提交到远端仓库\n3.fork 其他人的仓库，若符合工程结构，则下载到本地可直接运行，修改，提交\n参考链接：\ngit 官网 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-17-git-learning/","summary":"对于 Git 学习的一些整理，包含常用命令整理\n个人觉得，对于一些开源工具，最好的学习资源还是其官网，我们就先来分析一波 Git 究竟是做什么的。\n概念解析 git 官网的定义是：Git 是一种免费并且开源的分布式版本控制系统，被设计用来快速高效地处理堆积成大工程的每一块小部分。（个人翻译，不喜勿喷）\nGit 简单易用、占用空间小并且性能优越。它远超过一些伴有类似廉价的本地分支、方便的阶段区域和多工作流特点的配置管理工具（SCM，Software Configuration Management），比如 SVN、CVS、Perforce 和 ClearCase 这些。\nGit 允许同一组下的人们同一时刻在相同的文档上工作（通常是代码），并且不会踩到其他人的脚趾（形容两个人同时在相同的文档上工作也不会发生冲突）\n特性 小而快速（Small and Fast） 分布式（Distributed,这也是它比 SVN 优势明显的地方） 数据保证（Data Assurance） 分阶段区域（Staging Area） 免费并开源（Free and Open Source） 教程 初级教程：Try Git\n高级教程：gitreal\n官方书籍：Pro Git\n使用步骤（包含常见命令） 1.初始化\ngit init init 命令会创建一系列 git 结构的文件\n仅对一个制定目录创建 git 结构时使用，用于将某个目录交给 git 管理\n2.查看 git 状态\ngit status 可在任何时间阶段使用， 以查看当前 git 管理下的文件状态\n3.将文件交予 git 管理\ngit add filename 对于在 git init 后的目录里的每一个文件都有 tracked 和 untracked 两种状态，也就是是否被 git 追溯（管理）","title":"git学习总结"},{"content":"centos 内置一个非常强劲的防火墙，统称为 iptables，实际原理是 iptables 是用户空间的模块，在内核中存在一个 netfilter 核心模块用于实现 iptables 中设置的规则，进行底层的实际过滤。\niptables 关键字 IP 地址 协议（TCP、UDP、ICMP） 端口 原理 iptables 将规则放入缺省规则链（INPUT、FORWARD、OUTPUT），所有流量（IP 封包）会被相关的规则链检查，根据规则处理每个封包（ACCEPT/REJECT），这些动作称为目标（target）\nINPUT：以主机为目的地的封包 FORWARD：封包的目的地和来源地都不是主机，途经主机（由其选路），比如主机是路由器，这条规则链将被应用 OUTPUT：源自主机的封包\n每个封包会逐一匹配每条规则，若符合某一条规则，响应动作将被执行（ACCEPT/REJECT），一旦吻合一条规则，则不再被其他规则检查。若所有规则都不匹配，将会执行这条规则链的缺省动作（即括号内的缺省策略）\n使用方式 白名单方式：即规则链缺省规则设为 REJECT，仅对符合某些条件的封包进行放行，例如：bittorrent、FTP 服务器、网页服务器、Samba 文件服务器\n黑名单方式：规则链缺省策略设置为 ACCEPT，对需要拦截的封包做拦截 REJECT\n一般白名单用于 INPUT 规则链，用于控制目的地为主机的封包，黑名单用于 OUTPUT 规则链，用于控制由主机流出的封包\n使用 iptables 需要 root 用户操作\niptables 是缺省安装在 centos5.x 及 6.x 上，而 centos7.x 使用 firewalld 取代之\n先使用 rpm -q iptables 查看 iptables 是否安装在系统上\nlsmod | grep ip_table 检查 iptables 模块是否被装入，\n当 iptables 模块被装入后可通过 iptables -L 查看活动规则\n更多使用策略参考链接：\nhttps://wiki.centos.org/zh/HowTos/Network/IPTables firewalld 简介 firewalld 是 centos7 预装的动态防火墙后台程序，用以支持网络“zones”，以分配对一个网络及其相关链接和界面的一定程度的信任。\n特性 具备对 IPV4 和 IPV6 防火墙设置的支持 支持以太网桥 有运行时（runtime）和永久性（permanent）两种配置方式 具备一个通向服务或者应用程序的接口，以直接增加防火墙规则 动态生效，不需要保存或执行配置改变，会随时执行 对比 firewalld 和 iptables 配置存储 iptables service 存储在/etc/sysconfig/iptables\nfirewalld 配置存储在/usr/lib/firewalld 和/etc/firewalld/中的各种 XML 文件中\n注意！当 firewalld 在 RHEL(Red Hat Enterprise Linux)上安装失败时，/etc/sysconfig/iptables 文件将不存在\n规则修改 iptables service 每一个单独修改意味着清除所有原有规则，重新从/etc/sysconfig/iptables 中中读取规则\nfirewalld 不会创建新的规则，仅运行规则中的不同之处（因为可以在运行时修改而不丢失现有连接）\n使用 上图可看出对于 iptables 防火墙 centos 有两种实现方式，即 iptables service(service)或 firewalld(daemon\u0026amp;service)\n实际场景分别如下：\ncentos5.x 或 centos6.x 默认使用 iptables-services\ncentos7 默认使用 firewalld\nTip：若安装了 systemctl，使用\u0026quot;service 服务名 status\u0026quot;查看服务状态会被重定向为\u0026quot;systemctl status 服务名\u0026quot;\n将 firewalld 切换至 iptables.service 1.以 root 身份，先禁用并停止 firewalld 服务\nsystemctl disabled firewalld systemctl stop firewalld 2.查看 iptables 是否安装在系统上，若不存在则安装 iptables-services 程序包\nrpm -q iptables yum install iptables-services iptables-services 包含 iptables 和 ip6tables 服务\n3.启动服务\nsystemctl start iptables systemctl start ip6tables systemctl enable iptables systemctl enable ip6tables 使用 firewalld 取代 iptables.service 1.查看 firewalld 服务运行情况\nsystemctl status firewalld firewall-cmd --state 2.安装 firewalld（可选：图形化用户接口工具 firewall-config）\nyum install firewalld yum install firewall-config 3.配置防火墙三种方式\n命令行接口工具 firewall-cmd 图形化接口工具 firewall-config 编辑相应 XML 文件 注意：在 Runtime 模式下更改防火墙设置会立即生效，应注意本系统上的其他用户使用情况；Permanent 模式下更改设置，仅在重新加载防火墙或重启系统后生效\n重启防火墙命令\nfirewall-cmd --reload 参考链接：\nhttps://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-using_firewalls http://havee.me/linux/2015-01/using-firewalls-on-centos-7.html ","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-16-centos-iptables-and-firewalld/","summary":"centos 内置一个非常强劲的防火墙，统称为 iptables，实际原理是 iptables 是用户空间的模块，在内核中存在一个 netfilter 核心模块用于实现 iptables 中设置的规则，进行底层的实际过滤。\niptables 关键字 IP 地址 协议（TCP、UDP、ICMP） 端口 原理 iptables 将规则放入缺省规则链（INPUT、FORWARD、OUTPUT），所有流量（IP 封包）会被相关的规则链检查，根据规则处理每个封包（ACCEPT/REJECT），这些动作称为目标（target）\nINPUT：以主机为目的地的封包 FORWARD：封包的目的地和来源地都不是主机，途经主机（由其选路），比如主机是路由器，这条规则链将被应用 OUTPUT：源自主机的封包\n每个封包会逐一匹配每条规则，若符合某一条规则，响应动作将被执行（ACCEPT/REJECT），一旦吻合一条规则，则不再被其他规则检查。若所有规则都不匹配，将会执行这条规则链的缺省动作（即括号内的缺省策略）\n使用方式 白名单方式：即规则链缺省规则设为 REJECT，仅对符合某些条件的封包进行放行，例如：bittorrent、FTP 服务器、网页服务器、Samba 文件服务器\n黑名单方式：规则链缺省策略设置为 ACCEPT，对需要拦截的封包做拦截 REJECT\n一般白名单用于 INPUT 规则链，用于控制目的地为主机的封包，黑名单用于 OUTPUT 规则链，用于控制由主机流出的封包\n使用 iptables 需要 root 用户操作\niptables 是缺省安装在 centos5.x 及 6.x 上，而 centos7.x 使用 firewalld 取代之\n先使用 rpm -q iptables 查看 iptables 是否安装在系统上\nlsmod | grep ip_table 检查 iptables 模块是否被装入，\n当 iptables 模块被装入后可通过 iptables -L 查看活动规则","title":"关于centos的iptables以及firewalld的总结"},{"content":"今天在查问题的时候偶然进了一篇 StackExchange 的帖子，无论是站点名字还是首页界面，第一反应都是：StackOverFlow？\n查阅相关说明之后了解了二者的关系，StackExchange 是在 StackOverFlow 成功推出以后，在其基础上将仅仅讨论编程问题的网站拓展成话题更丰富的论坛。\n当更加深入了解二者关系之余发现一篇关于对比 StackExchange 和 Quora 二者区别的帖子写得很清楚，特将其翻译如下：\n正文 简短版本： StackExchange 是你的助教 Quora 是你的酒保\nQuora 是你认识的那个足迹遍布很多角落，品尝过城市每一家餐厅的人 StackExchange 是一个受过专业训练的专业帮助者\nStackExchange 是一个指导手册（详细，包含有用的例子） Quora 是一个著名的在其演讲后回答问题的知识分子\n详细版本： 想真正理解这二者，你需要从 the lens of purpose（目标透镜）看这个问题，从那里你能了解到一个专门的推送（see pull request at github?），它会从本质上讲清楚二者的区别。你会知道以下绝非偶然——Quora 不想成为 StackExchange，StackExchange 也不想成为 Quora，并且它们按照各自的方式建设以促进它们各自的目的。\n正如 Manish 所述，Quora 是关于“消费”,但它也关乎好奇。也就是，我在阅读问题的时候更多的是被动的，大多时候我可能会在 Quora 的邮件中看到一个有趣的问题之后发现自己想要的。我会阅读问题的答案（或者不止几个），然后查看站点上推荐给我的相关问题，同时我也会阅读它们。这些问题中很少数曾“逼迫”我去寻找一个答案，但我就是充满好奇并且想要了解更多。\nStackExchange 不同于其他在于其基于目的或者基于问题。我来到 StackExchange 大多情况是通过搜索引擎，因为我在处理某些事情上遇到问题并且需要答案。它绝大多数时候当然充当了一个技术支持，经常可以处理……(未完待续)\n尾声 通篇下来个人觉得充满了蹩脚的翻译，这篇文章看起来大体可以理解作者的意思，但落实翻译对于我而言是不小的挑战。\n个人比拟 国外网站 对应 国内网站 StackExchange \u0026lt;\u0026mdash;\u0026gt; 暂无 Quora \u0026lt;\u0026mdash;\u0026gt; 知乎 StackOverFlow \u0026lt;\u0026mdash;\u0026gt; SegamentFault 相关链接 原文链接 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-14-stackexchange-vs-quora/","summary":"今天在查问题的时候偶然进了一篇 StackExchange 的帖子，无论是站点名字还是首页界面，第一反应都是：StackOverFlow？\n查阅相关说明之后了解了二者的关系，StackExchange 是在 StackOverFlow 成功推出以后，在其基础上将仅仅讨论编程问题的网站拓展成话题更丰富的论坛。\n当更加深入了解二者关系之余发现一篇关于对比 StackExchange 和 Quora 二者区别的帖子写得很清楚，特将其翻译如下：\n正文 简短版本： StackExchange 是你的助教 Quora 是你的酒保\nQuora 是你认识的那个足迹遍布很多角落，品尝过城市每一家餐厅的人 StackExchange 是一个受过专业训练的专业帮助者\nStackExchange 是一个指导手册（详细，包含有用的例子） Quora 是一个著名的在其演讲后回答问题的知识分子\n详细版本： 想真正理解这二者，你需要从 the lens of purpose（目标透镜）看这个问题，从那里你能了解到一个专门的推送（see pull request at github?），它会从本质上讲清楚二者的区别。你会知道以下绝非偶然——Quora 不想成为 StackExchange，StackExchange 也不想成为 Quora，并且它们按照各自的方式建设以促进它们各自的目的。\n正如 Manish 所述，Quora 是关于“消费”,但它也关乎好奇。也就是，我在阅读问题的时候更多的是被动的，大多时候我可能会在 Quora 的邮件中看到一个有趣的问题之后发现自己想要的。我会阅读问题的答案（或者不止几个），然后查看站点上推荐给我的相关问题，同时我也会阅读它们。这些问题中很少数曾“逼迫”我去寻找一个答案，但我就是充满好奇并且想要了解更多。\nStackExchange 不同于其他在于其基于目的或者基于问题。我来到 StackExchange 大多情况是通过搜索引擎，因为我在处理某些事情上遇到问题并且需要答案。它绝大多数时候当然充当了一个技术支持，经常可以处理……(未完待续)\n尾声 通篇下来个人觉得充满了蹩脚的翻译，这篇文章看起来大体可以理解作者的意思，但落实翻译对于我而言是不小的挑战。\n个人比拟 国外网站 对应 国内网站 StackExchange \u0026lt;\u0026mdash;\u0026gt; 暂无 Quora \u0026lt;\u0026mdash;\u0026gt; 知乎 StackOverFlow \u0026lt;\u0026mdash;\u0026gt; SegamentFault 相关链接 原文链接 ","title":"关于StackExchange和Quora的区别"},{"content":"均衡，存乎万物之间\n负载均衡（Load Balance）是指将请求均匀分摊到多个操作单元上执行，关键在于均匀\n本来在学习过反向代理这个概念以后以为负载均衡就是反向代理在服务端将来自客户端短时大量的访问请求做分发，将其分配到多台提供相同服务的服务器上。 看了负载均衡以后发现其实负载均衡是一个很宏观的概念，上述的理解存在一定偏差。\n负载均衡旨在将特定的业务分担给多个服务器或网络设备，从而提高业务处理能力，保证业务的高可用性。\n（负载均衡用于缓解极大量的访问请求，所以下面的场景都基于同时来自客户端大量的访问请求）\n首先，我上面的理解在实际的负载均衡中其实表述的是【DNS 层】（客户端-\u0026gt;反向代理层）的负载均衡，这一层的负载均衡由 DNS 服务器实现。\n具体也就是当用户通过网站域名访问服务时，为了负载均衡，同一域名会配置多个解析 IP，每当 DNS 解析请求来访问 DNS 服务器时，它会轮询这些 IP，并保证每个 IP 的解析概率相同（均匀），这些 IP 就是 nginx 的外网 IP。\n然后拿到某台 nginx 的 IP 也就结束了第一层的负载均衡\n接下来，来到【反向代理层—\u0026gt;站点层】，这一层的负载均衡通过 nginx 的配置实现，策略有很多种：比如轮询、IP 哈希、URL 哈希、权重等\n请求轮询：类似 DNS 轮询，请求依次被路由到每一个 web 服务器\n最少连接路由：将请求路由到连接数最少的 web 服务器\nIP 哈希：通过客户端 IP 的哈希值来路由到某一个 web 服务器（只要用户 IP 分布均匀，理论上路由的路径就是均匀的），这样同一个用户的请求会固定路由到固定的某一台 web 服务器上，该策略适合有状态服务，比如 session（但不建议这么做，因为站点层无状态是分布式架构设计的基本原则之一，session 最好放在数据层存储）\n然后是【站点层-\u0026gt;服务层】的负载均衡，该层通过服务连接池实现\n上游连接池与下游服务建立多个连接，每次请求会“随机”选取连接访问下游服务\n最后是【数据层】负载均衡\n当数据量十分庞大的时候，数据层（db，cache）可能会进行数据的水平切分，于是该层的负载均衡包含“数据均衡”和“请求均衡”两部分\n数据均衡指：水平切分后的每个服务（db，cache），彼此之间数据量均匀\n请求均衡指：水平切分后的每个服务（db，cache），彼此之间请求量均匀\n常见水平切分法如下：\n按照数据范围切分：每个数据服务存储一定范围内的数据 DataServiceA：存储 uid 为[1-1kw)内的数据 DataServiceB：存储 uid 为[1kw-2kw)内的数据\n优点：\n规则简单，来自服务层的访问仅根据 uid 范围即可路由到对应的存储服务\n数据均衡性良好（除最后一份，其他均为等分）\n易拓展，可随时添加 uid 为 2kw 以后的数据服务\n缺点：\n请求均衡不一定到位，例如新注册的用户会比老用户更活跃，即 uid 数值大的服务请求压力更大 按照 ID 的哈希值切分：每个数据服务存储 uid 哈希后的部分数据 DataServiceA：存储 uid 哈希后的部分数据 DataServiceB：存储 uid 哈希后的另一部分数据\n优点：\n规则简单，来自服务层的访问仅根据 uid 进行哈希计算即可路由到对应的存储服务\n数据均衡性良好\n请求均衡性良好\n缺点：\n不易拓展，拓展一个数据服务时，哈希方法改变，可能需要进行数据迁移 总结：\n各层负载均衡实现方式\n【客户端-\u0026gt;反向代理】：DNS 轮询\n【反向代理-\u0026gt;Web 站点】：nginx\n【Web 站点-\u0026gt;服务】：服务连接池\n【服务-\u0026gt;数据】：数据均衡+请求均衡\n参考链接：一分钟了解负载均衡\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-09-about-load-balance/","summary":"均衡，存乎万物之间\n负载均衡（Load Balance）是指将请求均匀分摊到多个操作单元上执行，关键在于均匀\n本来在学习过反向代理这个概念以后以为负载均衡就是反向代理在服务端将来自客户端短时大量的访问请求做分发，将其分配到多台提供相同服务的服务器上。 看了负载均衡以后发现其实负载均衡是一个很宏观的概念，上述的理解存在一定偏差。\n负载均衡旨在将特定的业务分担给多个服务器或网络设备，从而提高业务处理能力，保证业务的高可用性。\n（负载均衡用于缓解极大量的访问请求，所以下面的场景都基于同时来自客户端大量的访问请求）\n首先，我上面的理解在实际的负载均衡中其实表述的是【DNS 层】（客户端-\u0026gt;反向代理层）的负载均衡，这一层的负载均衡由 DNS 服务器实现。\n具体也就是当用户通过网站域名访问服务时，为了负载均衡，同一域名会配置多个解析 IP，每当 DNS 解析请求来访问 DNS 服务器时，它会轮询这些 IP，并保证每个 IP 的解析概率相同（均匀），这些 IP 就是 nginx 的外网 IP。\n然后拿到某台 nginx 的 IP 也就结束了第一层的负载均衡\n接下来，来到【反向代理层—\u0026gt;站点层】，这一层的负载均衡通过 nginx 的配置实现，策略有很多种：比如轮询、IP 哈希、URL 哈希、权重等\n请求轮询：类似 DNS 轮询，请求依次被路由到每一个 web 服务器\n最少连接路由：将请求路由到连接数最少的 web 服务器\nIP 哈希：通过客户端 IP 的哈希值来路由到某一个 web 服务器（只要用户 IP 分布均匀，理论上路由的路径就是均匀的），这样同一个用户的请求会固定路由到固定的某一台 web 服务器上，该策略适合有状态服务，比如 session（但不建议这么做，因为站点层无状态是分布式架构设计的基本原则之一，session 最好放在数据层存储）\n然后是【站点层-\u0026gt;服务层】的负载均衡，该层通过服务连接池实现\n上游连接池与下游服务建立多个连接，每次请求会“随机”选取连接访问下游服务\n最后是【数据层】负载均衡\n当数据量十分庞大的时候，数据层（db，cache）可能会进行数据的水平切分，于是该层的负载均衡包含“数据均衡”和“请求均衡”两部分\n数据均衡指：水平切分后的每个服务（db，cache），彼此之间数据量均匀\n请求均衡指：水平切分后的每个服务（db，cache），彼此之间请求量均匀\n常见水平切分法如下：\n按照数据范围切分：每个数据服务存储一定范围内的数据 DataServiceA：存储 uid 为[1-1kw)内的数据 DataServiceB：存储 uid 为[1kw-2kw)内的数据\n优点：","title":"关于负载均衡的理解小结"},{"content":"最近几天开发任务不甚紧张，每天可能一部分是在读博客或者写博客。在此过程中，突然想给自己炖一锅鸡汤醒醒脑。\n作为一个软件工程毕业的人，或许更宏观的讲，作为一个计算机专业毕业的人，该怎么规划自己的职业生涯呢？\n（这里不讨论想转行的同学们，我很幸运当初坚持了自己的选择和判断，由于兴趣，入行了计算机，如今应该称呼为“互联网”领域）\n过程在我看来是先易后难的\n第一阶段 刚毕业的两三年，甚至五年，可能都是知识储备期，也就是技术积淀期。当然，打牢基础并不意味着沉迷基础，走走停停，及时看清楚技术风向标，是避免徒劳无功的基本意识。\n在打牢基础的这几年应该做什么？或者说应该培养哪些能力\n专业基础自然不用说，那是最基本的敲门砖，可能在学生时代，每个人的专业能力还都参差不齐，但步入职场后，对于每个从事技术工作的人，在技术基础方面的要求都是“一视同仁”的，也就是对于从事各个不同技术方向的人，你的技术栈都应该是完整的。为什么说这些是最基本的呢，因为这些东西大多是“死”的，也就是不管量有多少，甚至还在不断增加，但它的本质几乎不会发生质的变化，所以关乎技术的东西，你可以从学校、书籍或者人那里都可以习得，而后面要讲的第二阶段的技能可能不是单纯靠“学习”便可拥有的。\n那么能力方面应该涉及哪些呢？个人总结如下（其实在不管大型还是初创的各个互联网公司招聘中也能经常看到这些字眼）：\n学习能力：首屈一指必然是学习的能力，因为这一点决定你“可拓展性”有多强，这里的学习能力指的是活学活用以及持续学习的能力。假如你是以初高中某些死记硬背或者应试手段的学习方法，我不敢保证那样的收益如何，因为我不曾有过以那样的方式的学习经历。另外就是持续学习的概念，这种需求其实是由时代滋生的，因为如今的时代决定了你很难（我没有说“不可能”的字眼）以固定的知识量驾驭你的整个职业生涯。 综合上面两种学习的能力其实也就自然带来你上手新事物的能力，比如公司派你去负责完成一项新的任务，使用的是一项你从未接触过的技术，那么此时如果你是拥有学习的能力，而不是仅仅拥有定量的知识，那么任何新事物你自然都能搞定。\n理解能力：这是一个输入+分析的过程（Input \u0026amp; Process），理工一点的说法类似计算机的核心（CPU）处理任务方式。理解能力决定你在学习一项新事物时的效率，比如如果你对一个事物在最初认识的时候发生了偏差，那可能你用的劲越多，就越偏离理解它的正规。另外逻辑思维也在此体现出重要的作用，可能单纯的理性思维并不能帮助你快速地认识到新事物的本质，有时候可能还需要一些感性思维，Maybe 想象力.etc\n沟通能力：这是一个输出的过程（Output \u0026amp; Translate），有时候单纯一味地输入未必可以发挥你所掌握知识的最大价值，技术需要分享，而交流就是一个有效媒介。但是有时候知识的传递在一些糟糕的表达后会变得晦涩难懂，所以良好的表达能力才会成为知识传播的有效大使。另外，有效的沟通势必带来 1+1\u0026gt;2 的收益，这样既节省时间又提高效率的多赢结果是大家都希望看到的。\n第二阶段 这些技能大多基于经验主义，并且没有标准答案\n判断力：“错与对”、“进与退”、“黑与白”（太极思想，黑中有白，白中有黑）的判断是永恒的难题（突然想到明天即将上映“马爸爸”的《攻守道》）\n趋势/形势判断：趋势的判断往往决定你路程的远近，这东西可大可小，小在一笔小额的投资，大在一个集团的定位，如果仅有埋头苦干的踏实，而没有远瞻未来的判断，想必很难成为一位成功的管理者。而形势的判断其实就是一句“识时务者为俊杰”，何时放手一搏，主动出击，何时及时止损，这里的学问也是需要经验的不断积累来沉淀所得。\n决策能力：如果你进行统计，其实我们每一天的所有行为串起来就是一颗巨大的决策树，每一个分支的两种选择都会带来不同的结果，而如此累积，将会因为每一步的不同而带来巨大差异的结果，这也就是所谓世界上没有两片相同的叶子，两个人尽管处于相同的环境，接收相同的知识，完成相同的任务，也会在日积月累的微小差异中变成两个独一无二的个体。\n能否做出正确的决策，能否果断地做出决策，能否预知不同决策带来的结果，能否对结果负责，这一点其实在 AlphaGo 与人类围棋对决中就已经证明了计算机在决策方面已经掌握非常强大的能力，人类如果不增强自己的优势，可能等待你的只是“智能危机”。\n前面三项能力或多或少都和选择有关，这也是为什么讲“有时候，选择比努力更重要”\n是否注重细节：每个领域都会有大量的同类竞争，能够另辟蹊径的毕竟是少数，那么如何在“大家都差不多的”的情况下脱颖而出，细节方面至关重要\n能否抵抗诱惑：新手大多急于求成，急功近利，而老手则懂得放长线钓大鱼\n这些能力没有人能教的了你，同时也是决定你能否成为一个拥有独立完整人格的个体。\n后续 未来毕竟还是很难预知的，所以我也不想给自己太远的未来做太过具体的规划，每个人都有自己的想法和规划，我的观点不一定适用别人，所以本篇博文也仅仅是一篇与自己灵魂的对话，仅此而已。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-09-about-career/","summary":"最近几天开发任务不甚紧张，每天可能一部分是在读博客或者写博客。在此过程中，突然想给自己炖一锅鸡汤醒醒脑。\n作为一个软件工程毕业的人，或许更宏观的讲，作为一个计算机专业毕业的人，该怎么规划自己的职业生涯呢？\n（这里不讨论想转行的同学们，我很幸运当初坚持了自己的选择和判断，由于兴趣，入行了计算机，如今应该称呼为“互联网”领域）\n过程在我看来是先易后难的\n第一阶段 刚毕业的两三年，甚至五年，可能都是知识储备期，也就是技术积淀期。当然，打牢基础并不意味着沉迷基础，走走停停，及时看清楚技术风向标，是避免徒劳无功的基本意识。\n在打牢基础的这几年应该做什么？或者说应该培养哪些能力\n专业基础自然不用说，那是最基本的敲门砖，可能在学生时代，每个人的专业能力还都参差不齐，但步入职场后，对于每个从事技术工作的人，在技术基础方面的要求都是“一视同仁”的，也就是对于从事各个不同技术方向的人，你的技术栈都应该是完整的。为什么说这些是最基本的呢，因为这些东西大多是“死”的，也就是不管量有多少，甚至还在不断增加，但它的本质几乎不会发生质的变化，所以关乎技术的东西，你可以从学校、书籍或者人那里都可以习得，而后面要讲的第二阶段的技能可能不是单纯靠“学习”便可拥有的。\n那么能力方面应该涉及哪些呢？个人总结如下（其实在不管大型还是初创的各个互联网公司招聘中也能经常看到这些字眼）：\n学习能力：首屈一指必然是学习的能力，因为这一点决定你“可拓展性”有多强，这里的学习能力指的是活学活用以及持续学习的能力。假如你是以初高中某些死记硬背或者应试手段的学习方法，我不敢保证那样的收益如何，因为我不曾有过以那样的方式的学习经历。另外就是持续学习的概念，这种需求其实是由时代滋生的，因为如今的时代决定了你很难（我没有说“不可能”的字眼）以固定的知识量驾驭你的整个职业生涯。 综合上面两种学习的能力其实也就自然带来你上手新事物的能力，比如公司派你去负责完成一项新的任务，使用的是一项你从未接触过的技术，那么此时如果你是拥有学习的能力，而不是仅仅拥有定量的知识，那么任何新事物你自然都能搞定。\n理解能力：这是一个输入+分析的过程（Input \u0026amp; Process），理工一点的说法类似计算机的核心（CPU）处理任务方式。理解能力决定你在学习一项新事物时的效率，比如如果你对一个事物在最初认识的时候发生了偏差，那可能你用的劲越多，就越偏离理解它的正规。另外逻辑思维也在此体现出重要的作用，可能单纯的理性思维并不能帮助你快速地认识到新事物的本质，有时候可能还需要一些感性思维，Maybe 想象力.etc\n沟通能力：这是一个输出的过程（Output \u0026amp; Translate），有时候单纯一味地输入未必可以发挥你所掌握知识的最大价值，技术需要分享，而交流就是一个有效媒介。但是有时候知识的传递在一些糟糕的表达后会变得晦涩难懂，所以良好的表达能力才会成为知识传播的有效大使。另外，有效的沟通势必带来 1+1\u0026gt;2 的收益，这样既节省时间又提高效率的多赢结果是大家都希望看到的。\n第二阶段 这些技能大多基于经验主义，并且没有标准答案\n判断力：“错与对”、“进与退”、“黑与白”（太极思想，黑中有白，白中有黑）的判断是永恒的难题（突然想到明天即将上映“马爸爸”的《攻守道》）\n趋势/形势判断：趋势的判断往往决定你路程的远近，这东西可大可小，小在一笔小额的投资，大在一个集团的定位，如果仅有埋头苦干的踏实，而没有远瞻未来的判断，想必很难成为一位成功的管理者。而形势的判断其实就是一句“识时务者为俊杰”，何时放手一搏，主动出击，何时及时止损，这里的学问也是需要经验的不断积累来沉淀所得。\n决策能力：如果你进行统计，其实我们每一天的所有行为串起来就是一颗巨大的决策树，每一个分支的两种选择都会带来不同的结果，而如此累积，将会因为每一步的不同而带来巨大差异的结果，这也就是所谓世界上没有两片相同的叶子，两个人尽管处于相同的环境，接收相同的知识，完成相同的任务，也会在日积月累的微小差异中变成两个独一无二的个体。\n能否做出正确的决策，能否果断地做出决策，能否预知不同决策带来的结果，能否对结果负责，这一点其实在 AlphaGo 与人类围棋对决中就已经证明了计算机在决策方面已经掌握非常强大的能力，人类如果不增强自己的优势，可能等待你的只是“智能危机”。\n前面三项能力或多或少都和选择有关，这也是为什么讲“有时候，选择比努力更重要”\n是否注重细节：每个领域都会有大量的同类竞争，能够另辟蹊径的毕竟是少数，那么如何在“大家都差不多的”的情况下脱颖而出，细节方面至关重要\n能否抵抗诱惑：新手大多急于求成，急功近利，而老手则懂得放长线钓大鱼\n这些能力没有人能教的了你，同时也是决定你能否成为一个拥有独立完整人格的个体。\n后续 未来毕竟还是很难预知的，所以我也不想给自己太远的未来做太过具体的规划，每个人都有自己的想法和规划，我的观点不一定适用别人，所以本篇博文也仅仅是一篇与自己灵魂的对话，仅此而已。","title":"关于职业规划"},{"content":"用了一段时间的 hexo，本着“授人以鱼，不如授人以渔”的理念，决定整理一篇 hexo 使用教程，分享大家。\nhexo 是一种快速、简单并且强大的博客框架，你可以通过使用 markdown 或者其他语言撰写 post（帖子），然后 hexo 引擎将其生成静态网页文件（当然，官网的说法是“在数秒内生成伴有漂亮主题的静态文件”）并以博文的形式显现出来。\n写在前面 本文定位于面向非专业人士角度撰写的科普式教程，有专业基础的人可跳过大多步骤，仅阅读标*部分\n背景 应@JXY 邀，要我教他搭建个人博客，于是也就找了一个足够的理由来回顾一波如何使用 hexo 搭建个人博客。\n既然给别人讲东西，那自然要先对讲的东西深入了解，不然就是误人子弟了。于是打开hexo 官网，发现！竟然！被！墙！了！好吧，后来发现是 9 点多被墙了一段时间（貌似是 hexo 使用的 CDN 服务 Cloudflare 被 block 了），介于避免日后再想参考官网文档时无法及时访问，索性这次就把官网的一些精华翻译下来，留作日后参考。\n*核心步骤 先看官方给出的安装步骤\n准备篇 首先你要做好准备掌握以下几项东西：\ngit nodejs bash 命令 好吧，这样讲未免显得门槛略高，其实 hexo 是一种非常零门槛的工具，只要你想学，任何没有专业知识的人都能用起来，只要照着做就可以了\n环境搭建篇 第一步：在电脑安装git（如果下载不了,可以通过我的网盘下载git） git 是一个伟大的版本控制软件，它的作用在于作为一个代码提交工具，将你编写的每一行代码（或文字）存放到一个代码仓库，它在其中起到记录你每一次提交历史的作用，这样你就可以对自己的每一次提交历史有直观的查看，并且可以对比不同版本之间的区别，还可以回退到某一个提交历史节点，还有 balabala 很多好处。\n第二步：安装 nodejs 当你安装好了 git 以后，可以鼠标右键唤出 git\n方式一 然后你就可以很方便的安装 nodejs 了，通过如下命令先安装 nvm（此方式适用于专业人士，非专业人士请参考后面下载安装包的方式二）\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash nvm 是 nodejs version manager，nodejs 版本管理器，用以在机器上安装并维护多个 node 的版本\n如果执行失败（看到很多 error）,也可以通过我网盘的安装包进行下载\n当安装完成后，通过 cmd 窗口键入 nvm\n方式二 如果你想在电脑尚未安装 git 的情况下安装 nodejs，或者安装 nvm 失败，你也可以通过传统的方式安装 nodejs，如下：\n访问nodejs 官网下载，或者通过我的网盘下载安装包，安装方式如同安装其他软件一样\n安装成功后打开 cmd 窗口，键入 node \u0026ndash;version\nnodejs 是一个基于谷歌的V8 Javascript 引擎的 Javascript 运行环境。它利用一个事件驱动的、非阻塞 I/O 的模型使得其轻量并且高效。另外，nodejs 的包生态系统npm是世界上最大的开源库生态系统。\n（包生态系统通俗来讲就是，一个会编程的你，某天写了一段代码，觉得其功能可被大家重复使用，并且很好用，于是你就把这段代码打了个包丢到网上，于是大家就都可以通过下载你这个包来使用这个功能了）\nV8 是谷歌的一个开源高性能 Javascript 引擎，使用 C++编写，并应用于 Google Chrome 浏览器（来自谷歌的开源浏览器）、Node.js 等等。它按照 ECMA-262 标准实现了 ECMAScript，并可运行在 windows7 及更高版本、macOS10.5 及更高版本和使用 IA-32、ARM 或者 MIPS 处理器的 linux 系统。V8 可以单独运行，或者被嵌入任何 C++程序。（以上内容由本人翻译自V8 官网首页，如有不准确之处请指正）\np.s. 关于 nodejs 和 Javascript 的关联，个人理解就是 Javascript 本来是运行在客户端（浏览器）的脚本语言，如果想要 Javascript 脚本在服务器端运行怎么办呢，此时就有了 nodejs，由于 V8 引擎的存在，使得通过 Nodejs 可以在服务器端模拟出客户端的环境，从而来运行 Javascript 脚本\n安装篇 在你的电脑有了 git 和 nodejs 以后，就可以正式安装 hexo 了\n接下来你只需要在任何一个地方（比如桌面）右键鼠标唤出 git bash\n然后粘贴这段命令\nnpm install -g hexo-cli 解释：这就是通过你刚才安装的 nodejs 里自带的包管理器 npm 安装了一个叫做 hexo-cli 的包（在 npm 里管这叫模块 module）\nnpm 意思是使用 npm 执行命令\ninstall 意思是要通过 npm 进行安装模块行为\n-g 是对于 install 动作添加的参数，意思是 global，全局安装\nhexo-cli 是你已知需要安装的模块名称\n安装成功后你就可以正式进行使用了\n使用篇 此时你可以选电脑上的任何一个目录（文件夹）作为自己博客的存放地\n然后在这里右键唤出 git bash\n这个时候就用到准备篇里讲的 git 和 bash 命令的知识了，不过不要怕，其实经常用的也就那么几个命令，比如 ls（就是 list，列出当前目录的所有文件）、cd(change directory，切换目录)\n首先，我们通过\nhexo init 任意名称（比如 hexo init blog） 这就是通过刚才安装的 hexo 里的 hexo init（初始化）命令创建了一个 hexo 式的文件夹，点进去看看都有什么\n当然，你鼠标点进去只是在你的 windows 界面系统你这个当前用户进入到 blog 这个目录了，但 git bash 还停留在刚才的 myblog 那个目录，所以你需要在 git bash 里键入 cd blog，来切换到 blog 目录，你可以再键入 pwd（print working directory，打印出当前工作目录）来确认自己是否进到了 blog 目录\n然后输入 npm install，会根据博客既定的依赖安装依赖包\nTip: 既然步入程序世界，理应准备一个好用（高效）的文本编辑器，总不能使用 windows 自带记事本来编辑这些东西吧，此处我推荐Atom、Visual Studio Code、Sublime Text都是主流的文本编辑器，具体下载使用请自行查阅\n结构解释篇 _config.yml：主配置文件（博客写到一半时突然获知 YAML 原来是一种新型的配置文件语言，是一种比 JSON 还简洁和强大的格式，而 yml 则是这种配置文件的后缀）\npackage.json：应用数据，EJS、Stylus 和 Markdown 渲染器已默认安装，当然你也可以卸载掉它们，如果你想\nscaffolds（脚手架）：当你新建一篇帖子时，hexo 会基于这个里面的模板生成一个文件\nsource（源）：这是你放置网站内容的地方，hexo 会忽略隐藏文件或者以下划线 _ 开头的文件夹，除了_post 这个目录。可渲染的文件，例如 markdown 文件、HTML 文件会被 hexo 处理并放入 public（发布）目录，其他文件将会被原样拷贝过去。\nthemes（主题）：Hexo 会结合主题的网页内容和你的博文生成静态站点\n当你第一次 hexo init 之后生成的一系列文件其实包含了 hexo 最核心的一些东西，其中包含如上所介绍的，包括主配置文件_config.yml、source 目录里的_post（帖子）里放了一篇示例博文“hello-world.md”、themes 里提供了默认主题 landscape、scaffolds 里提供了 post 文件的初始模子。这一切就足以让你快速体验如何部署一个博客在放在网上提供别人来访问。\n博客部署 那么博文已经有了，怎么把它放到网上让所有人都能访问呢，这时候你需要把它部署到服务器，并提供访问地址，理论上来讲，你可能需要租服务器，并把博客丢上去，然后还要配域名，因为你总不可能让别人通过 IP 地址访问你的博客，这样看来，还有 balabala 很多事情要做，涉及到 web 应用部署发布的一系列知识。\n但是一般 hexo 的使用都是联合Github Pages或者Coding Pages一起使用的，Github 和 Coding 都是在线代码仓库，（二者的区别在于前者是国际的，后者是国内的）可以远程寄存你的代码或文件，他们都各自提供了一种叫 Pages 的服务，可以使得你的用户名同名仓库可以作为域名对外公布访问，这样你相当于拥有了一个免费个人网站，并且还不需要注册域名和备案。\n有了这个技术，我们就可以通过 git 把本地生成的博客静态文件（public 目录里的）上传到这个仓库里，然后别人就可以通过访问这个仓库的方式来访问你的博客（只要你的代码结构符合网站基本结构）\n快速上手篇 所以一切都配置好之后（按照个性化配置好你的_config.yml 文件），你发布一篇博客到网上只需要三步：\n第一步：创建博文 在你的博客主目录下通过 git bash 键入 hexo new 博客标题\n第二步：按照 hexo 的渲染方式将你的博文渲染成静态文件 继上一步之后，hexo g（完整命令是 hexo generate，即生成文件的意思）\n第三步：按照_config.yml 里配置的发布方式，将 public 里的静态文件上传至你的线上代码仓库（Github 或 Coding） hexo d（完整命令是 hexo deploy，即发布的意思）\n仅此而已，这时打开浏览器，输入符合你 pages 的域名，看看自己的博客是不是显现出来了。\n后记 其实 hexo 本身还是有不少的东西，如果想要成为一名高级玩家，需要你自己去进一步了解学习，本文仅初步安装做如此介绍，后续如果有精力的话，我会再继续出其他关于 hexo 其他配置的使用教程。\n不过，大道至简，看穿事物的本质，即能快速掌握其核心。hexo 说白了就是一个基于 nodejs 的工程，它定义了自己的一套文件格式，你只要按照一系列模板进行个性化编辑，并添加个人用户内容，然后使用它的一套命令，就可以把这些文件渲染成浏览器可访问的格式。剩下的就是关乎 WEB 原理的东西了。\n本文中后部可能略去了一些详细的操作步骤，不过整体性上应该达到了教学的目的，希望读者都可以借助互联网自己完成剩余的部分。\nEND 过程中由于天时·地利·人和都不同，所以可能遇到与我教程中所写不同的情况，但作为一个非专业人士，只要你肯耐着性子折腾，这些东西你也玩得转，而如果作为一个专业人士，钻研，是你的天职。比如博主写这篇教程也是通过先学习很多知识点，才“负责任”地整理出这篇博文。\n参考链接：\nhexo 官方文档 nodejs 官网 V8 引擎官网 npm 官网 廖雪峰 Javascript 教程 阮一峰的网络日志 YAML 语言教程 Hexo 源码 知识是理应无私分享的，而智慧是分享不了的。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-08-setup-blog-using-hexo/","summary":"用了一段时间的 hexo，本着“授人以鱼，不如授人以渔”的理念，决定整理一篇 hexo 使用教程，分享大家。\nhexo 是一种快速、简单并且强大的博客框架，你可以通过使用 markdown 或者其他语言撰写 post（帖子），然后 hexo 引擎将其生成静态网页文件（当然，官网的说法是“在数秒内生成伴有漂亮主题的静态文件”）并以博文的形式显现出来。\n写在前面 本文定位于面向非专业人士角度撰写的科普式教程，有专业基础的人可跳过大多步骤，仅阅读标*部分\n背景 应@JXY 邀，要我教他搭建个人博客，于是也就找了一个足够的理由来回顾一波如何使用 hexo 搭建个人博客。\n既然给别人讲东西，那自然要先对讲的东西深入了解，不然就是误人子弟了。于是打开hexo 官网，发现！竟然！被！墙！了！好吧，后来发现是 9 点多被墙了一段时间（貌似是 hexo 使用的 CDN 服务 Cloudflare 被 block 了），介于避免日后再想参考官网文档时无法及时访问，索性这次就把官网的一些精华翻译下来，留作日后参考。\n*核心步骤 先看官方给出的安装步骤\n准备篇 首先你要做好准备掌握以下几项东西：\ngit nodejs bash 命令 好吧，这样讲未免显得门槛略高，其实 hexo 是一种非常零门槛的工具，只要你想学，任何没有专业知识的人都能用起来，只要照着做就可以了\n环境搭建篇 第一步：在电脑安装git（如果下载不了,可以通过我的网盘下载git） git 是一个伟大的版本控制软件，它的作用在于作为一个代码提交工具，将你编写的每一行代码（或文字）存放到一个代码仓库，它在其中起到记录你每一次提交历史的作用，这样你就可以对自己的每一次提交历史有直观的查看，并且可以对比不同版本之间的区别，还可以回退到某一个提交历史节点，还有 balabala 很多好处。\n第二步：安装 nodejs 当你安装好了 git 以后，可以鼠标右键唤出 git\n方式一 然后你就可以很方便的安装 nodejs 了，通过如下命令先安装 nvm（此方式适用于专业人士，非专业人士请参考后面下载安装包的方式二）\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash nvm 是 nodejs version manager，nodejs 版本管理器，用以在机器上安装并维护多个 node 的版本","title":"使用hexo搭建个人博客教程"},{"content":"之前一直对反向代理这个概念理解的很模糊，网上参阅了很多解释，看完也是觉得不够信服，相比较而言觉得解释的还算良好的是知乎上看到的一个回答，但看了之后也仅限于“当时理解，过后就忘”，于是今天再次在 stackoverflow 看到的解释版本，特此翻译整理，留作备忘。\n原文链接：https://stackoverflow.com/questions/224664/difference-between-proxy-server-and-reverse-proxy-server/366212#366212\n如果当你访问不了这个链接的时候，也就说明，GFW 限制了大陆网络内的主机访问 stackoverflow 的网站内容，此时你即需要通过代理服务器来作为你的代理，帮你取拿到远端 stackoverflow 网站上的内容取回给你，这就是正向代理的使用实例。\n而反向代理其实更常见，因为它充斥在我们每一天的网上冲浪之中，只不过你意识不到罢了（注意！这也就是正向代理和反向代理很大的特征区别之一：正向代理需要你去寻得一个代理来帮助你访问你访问不了的服务器资源，而反向代理是服务器端使用的代理，来处理你提交的访问请求，所以作为客户端的你是意识不到代理的存在的）。\n比如你通过浏览器访问百度网搜索一个条目，或者直接在地址栏输入 stackoverflow.com，然而这个行为在互联网中有太多用户在做，所以百度或者 stackoverflow 的服务器不一定能够驾驭这么大的访问量，此时他们可能会把相同的服务部署在 N 多台服务器节点上，然后你其实访问到的是那些提供反向代理的服务器，反向代理服务器将大量的请求做了负载均衡处理，再把这些请求均衡合理地分配到那些提供相同服务的不同服务器节点上，这就是反向代理的实例。\n接下来是本人对于 stackoverflow 上精彩回答的翻译，如有不准确之处请指正\n前面的回答都很准确，但可能太过于精简了。我会试着增加一些例子。 首先，“代理”这个词描述了某个人或者某个事物扮演着代表另一个人的角色。在计算机领域，我们讨论的即是一台服务器扮演着代表另一台计算机的角色。为了保证观点可达性（即观点可以被很容易的理解）这一目的（这句感觉翻译的不太好），我会限制我的讨论仅限于“web 代理”，然而“代理”这一思想其实不仅限于 web 网站。\n正向代理 大多数关于 web 代理的讨论都指的是\u0026quot;正向代理\u0026quot;（这句感觉翻译得不甚准确）。这种情况下的代理事件其实就是“正向代理”代表请求者从另一个 web 站点取得数据。\n举个栗子，我会列举三台接入互联网的计算机。\nX = 你的计算机，或者说互联中的“客户机”\nY = 代理站点，proxy.example.org\nZ = 你想要访问的网站，www.example.net\n通常，你可能是类似 X \u0026ndash;\u0026gt; Z 这样的直连。\n然而，在一些场景下，Y \u0026ndash;\u0026gt; Z 来代表 X（去访问 Z）更好，链条如下：X \u0026ndash;\u0026gt; Y \u0026ndash;\u0026gt; Z\n为什么 X 需要使用代理服务器的原因：\nX 无法直接访问到 Z:\na)在 X 的互联网连接中某个拥有管理权限的人决定拦截所有 X 到 Z 站点的访问（比如 GFW : ) ）\n实例：\n风暴蠕虫病毒蔓延，它欺骗人们去访问 familypostcards2008.com，所以系统管理员封锁了对于这个网站的访问来保护用户们以避免其因为不小心而感染病毒。 一家大型公司的员工花费了太多的时间用在 facebook.com 的访问上，所以管理者想要这些访问在工作时间被屏蔽掉。 一家当地小学禁止了其对于 playboy.com 这个网站的互联网访问 政府无法控制人们发布新闻，所以它控制了新闻的访问取而代之，通过封锁类似 wikipedia.org 这样的网站，更多请查阅**TOR或者FreeNet** b) Z 点的管理员禁止了来自 X 的访问\n实例：\nZ 站点的管理员被告知可能存在来自于 X 的黑客攻击尝试行为，所以管理员决定禁掉 X 的 IP 地址（http://www.netrange.com/） Z 是一个论坛网站，X 正在该论坛刷屏。Z 禁掉了 X。 反向代理 X = 你的计算机，或者说互联中的“客户机”\nY = 反向代理站点，proxy.example.org\nZ = 你想要访问的网站，www.example.net\n通常，你可能是类似 X \u0026ndash;\u0026gt; Z 这样的直连。\n然而，在一些场景，对于 Z 的管理员限制掉或者不允许这样的直连更好，同时强迫访问者先去访问 Y。所以，如同往常，我们通过 Y \u0026ndash;\u0026gt; Z 代表 X 取得想要访问的数据，链条如下： X \u0026ndash;\u0026gt; Y \u0026ndash;\u0026gt; Z\n相比“正向代理”不同的是，这次用户 X 并不知道他在访问 Z，因为他只能看到他在和 Y 通信。Z 服务端对于客户端来说不可见并且只有反向代理 Y 对于外部是可见的。所以一个反向代理是不需要在客户端做配置的。\n客户端 X 认为他只是在和 Y 进行通信（即 X \u0026ndash;\u0026gt; Y），但事实上是 Y 在传导所有的通信（再一次成为 X \u0026ndash;\u0026gt; Y \u0026ndash;\u0026gt; Z 这样的通信结构）\n为什么 Z 想要设置一个代理服务器的原因：\n1）Z 想要强迫所有对于它的通信访问都先经过 Y。 a)Z 有一个成千上万人想要访问的巨大 web 站点，但仅仅一个 web 服务器不能处理所有的网络请求。所以 Z 架设了许多许多的服务器，并在互联网放置一个反向代理，以便当用户想要访问 Z 的时候把他们的访问请求派发到离他们最近的服务器去。这也是内容分发网络（CDN）概念如何工作的一部分。\n实例：\nApple Trailers使用Akamai Jquery.com 使用CloudFront CDN来存放它的 javascript 文件（例如：sample） 等等 2）Z 的管理员担心来自于对其网站内容的报复行为，并且不想直接向大众暴露其主服务器。\n类似\u0026quot;Canadian Pharmacy\u0026quot;这样的垃圾品牌的拥有者看上去拥有成千上万的服务器，然而实际上它大多数网站都只部署在比看上去少得多的服务器上。另外，关于刷屏的 abuse complaints 实际上只会关掉那些公共服务器，而非主服务器。 最后这段实在无力翻译，自己都看着难受 :(\n在如上的场景，Z 决定选择 Y（作为反向代理）\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-07-about-nginx-reverse-proxy/","summary":"之前一直对反向代理这个概念理解的很模糊，网上参阅了很多解释，看完也是觉得不够信服，相比较而言觉得解释的还算良好的是知乎上看到的一个回答，但看了之后也仅限于“当时理解，过后就忘”，于是今天再次在 stackoverflow 看到的解释版本，特此翻译整理，留作备忘。\n原文链接：https://stackoverflow.com/questions/224664/difference-between-proxy-server-and-reverse-proxy-server/366212#366212\n如果当你访问不了这个链接的时候，也就说明，GFW 限制了大陆网络内的主机访问 stackoverflow 的网站内容，此时你即需要通过代理服务器来作为你的代理，帮你取拿到远端 stackoverflow 网站上的内容取回给你，这就是正向代理的使用实例。\n而反向代理其实更常见，因为它充斥在我们每一天的网上冲浪之中，只不过你意识不到罢了（注意！这也就是正向代理和反向代理很大的特征区别之一：正向代理需要你去寻得一个代理来帮助你访问你访问不了的服务器资源，而反向代理是服务器端使用的代理，来处理你提交的访问请求，所以作为客户端的你是意识不到代理的存在的）。\n比如你通过浏览器访问百度网搜索一个条目，或者直接在地址栏输入 stackoverflow.com，然而这个行为在互联网中有太多用户在做，所以百度或者 stackoverflow 的服务器不一定能够驾驭这么大的访问量，此时他们可能会把相同的服务部署在 N 多台服务器节点上，然后你其实访问到的是那些提供反向代理的服务器，反向代理服务器将大量的请求做了负载均衡处理，再把这些请求均衡合理地分配到那些提供相同服务的不同服务器节点上，这就是反向代理的实例。\n接下来是本人对于 stackoverflow 上精彩回答的翻译，如有不准确之处请指正\n前面的回答都很准确，但可能太过于精简了。我会试着增加一些例子。 首先，“代理”这个词描述了某个人或者某个事物扮演着代表另一个人的角色。在计算机领域，我们讨论的即是一台服务器扮演着代表另一台计算机的角色。为了保证观点可达性（即观点可以被很容易的理解）这一目的（这句感觉翻译的不太好），我会限制我的讨论仅限于“web 代理”，然而“代理”这一思想其实不仅限于 web 网站。\n正向代理 大多数关于 web 代理的讨论都指的是\u0026quot;正向代理\u0026quot;（这句感觉翻译得不甚准确）。这种情况下的代理事件其实就是“正向代理”代表请求者从另一个 web 站点取得数据。\n举个栗子，我会列举三台接入互联网的计算机。\nX = 你的计算机，或者说互联中的“客户机”\nY = 代理站点，proxy.example.org\nZ = 你想要访问的网站，www.example.net\n通常，你可能是类似 X \u0026ndash;\u0026gt; Z 这样的直连。\n然而，在一些场景下，Y \u0026ndash;\u0026gt; Z 来代表 X（去访问 Z）更好，链条如下：X \u0026ndash;\u0026gt; Y \u0026ndash;\u0026gt; Z\n为什么 X 需要使用代理服务器的原因：\nX 无法直接访问到 Z:\na)在 X 的互联网连接中某个拥有管理权限的人决定拦截所有 X 到 Z 站点的访问（比如 GFW : ) ）","title":"关于反向代理的整理"},{"content":" 冒号是 MATLAT 中最有用的操作符之一。它用于创建向量，下标数组，并为迭代指定。\n背景 怎么解释？作为初学者可能一下子看不懂，但是研究后你会发现，作为老手，你也不应该看懂，因为，这是个印刷错误！\n借此学习一下 MATLAB 的冒号符和矩阵定义\n冒号符（ ：） 创建行向量 包含从 1 到 10 的整数行向量\noctave:2\u0026gt; 1:10 ans = 1 2 3 4 5 6 7 8 9 10 指定增量值\noctave:3\u0026gt; 100:-5:50 ans = 100 95 90 85 80 75 70 65 60 55 50 one more 栗子\noctave:4\u0026gt; 0:pi/8:pi ans = Columns 1 through 7: 0.00000 0.39270 0.78540 1.17810 1.57080 1.96350 2.35619 Columns 8 and 9: 2.74889 3.14159 因吹斯汀（pi 为 π）\n使用冒号运算符创建索引向量，以选择数组的行、列或元素 格式 目的 A(:,j) A 的第 j 列 A(i,:) A 的第 i 行 A(:,:) 等效的二维数组。对于矩阵，与 A 相同 A(j:k) A(j), A(j+1),\u0026hellip;,A(k) A(:,j:k) A(:,j), A(:,j+1),\u0026hellip;,A(:,k) A(:,:,k) 三维数组 A 的第 k 页 A(i,j,k,:) 四维数组 A 中的向量。向量包括 A(i，j，k，1)，A(i，j，k，2)，A(i，j，k，3)等 A(:) A 的所有要素，被视为单列。在赋值语句的左侧，A(:)填充 A，从之前保留其形状。在这种情况下，右侧必须包含与 A 相同数量的元素 前四个比较好理解\n实例解析\noctave:5\u0026gt; A = [1 2 3 4; 4 5 6 7; 7 8 9 10] A = 1 2 3 4 4 5 6 7 7 8 9 10 上面为直接创建矩阵的最基本方式，直接定义矩阵每行的元素并以分号为行分隔符\n下面解释冒号作为索引来获取矩阵元素的方式\n这个矩阵也就是一个二维数组，每一个元素则是 A（i，j），i 为矩阵的行，j 为矩阵的列，以此为索引定位每个元素，当 i 或者 j 为冒号时表示 ALL 例如：A(:,j)等同于 A(1,j)、A(2,j)、A(3,j)，矩阵有几行，则遍历全部行，取全部行的第 j 个元素，最后即是取这个矩阵的第 j 列\n所以 A(:,:)也就是遍历矩阵的每一行每一列的全部元素，也就相当于等效的二维数组\noctave:7\u0026gt; A = [1 2 3 4; 4 5 6 7; 7 8 9 10] A(:,2) % second column of A A(:,2:3) % second and third column of A A(2:3,2:3) % second and third rows and second and third columns A = 1 2 3 4 4 5 6 7 7 8 9 10 ans = 2 5 8 ans = 2 3 5 6 8 9 ans = 5 6 8 9 看到了吗，A（:,2:3）相当于 A(（ALL:ALL,2:3），如果是二维数组，则逗号左右即为定位元素的行、列索引，所有逗号左边的是行，逗号右边的是列，当逗号左边是冒号，即表示取所有的行，也就是该二维数组（矩阵）的第 2 列和第 3 列的没一行上的元素，也就矩阵的第 2、3 列\n回到第一种用法，冒号用于创建向量\n行向量：a=[1,2,3,4,5] （直接创建向量，写出每个元素，以逗号分隔元素，即生成行向量） 列向量：a=[1;2;3;4;5] （分号用以分隔向量的行，所以这样创建出的是列向量）\na=J:K 生成的行向量是 a=[J,J+1,…,K] a=J:D:K 生成行向量 a=[J,J+D,…,J+m*D],m=fix((K-J)/D) （生成以 D 为步长的行向量，D 默认为 1,可以不写，即为上面的形式） 若 J\u0026gt;K，则需要 D\u0026gt;0，否则得到空矩阵[] 同理，若 J\u0026lt;K，则需要 D\u0026lt;0，否则为空矩阵\n例如：\noctave:13\u0026gt; 1:5:11 ans = 1 6 11 中括号用于创建向量 小括号用于提取向量中的元素\n比较特殊的 octave:3\u0026gt; A=[1:3;4:6;7:9] A = 1 2 3 4 5 6 7 8 9 octave:2\u0026gt; A(1:2) ans = 1 4 octave:3\u0026gt; A(2:1) ans = [](1x0) octave:4\u0026gt; A(1:3) ans = 1 4 7 octave:5\u0026gt; A(1:2,2) ans = 2 5 类似这样的取值的方式，MATLAB 帮助文档没有给出这样的语法，但使用起来不报错 按照测试规律，只能暂且猜测其编译方式为按照（1:2:1）：3 这样的结合律，即 1:3\noctave:4\u0026gt; A=[1:2:5;7:2:11;13:2:17] A = 1 3 5 7 9 11 13 15 17 类似这样的取值\noctave:5\u0026gt; A(1:2:3) ans = 1 13 A(1:2:3)会被解释为 1 和 3，而这次索引没有加逗号，作为二维数组，会将其认为是行索引，即第一、三行，列索引未指定，则会默认取第一列\n在 MATLAB 编译器中，这种不规范的向量创建方式（空向量;非空向量）会成功创建后面的正常向量。\n致谢：问题提出者，同时也是本文校对者@Fan 同学\n参考链接：http://www.cnblogs.com/haore147/p/3633050.html\n附：MATLAB 在线解释器\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-11-01-matlab-matrix/","summary":"冒号是 MATLAT 中最有用的操作符之一。它用于创建向量，下标数组，并为迭代指定。\n背景 怎么解释？作为初学者可能一下子看不懂，但是研究后你会发现，作为老手，你也不应该看懂，因为，这是个印刷错误！\n借此学习一下 MATLAB 的冒号符和矩阵定义\n冒号符（ ：） 创建行向量 包含从 1 到 10 的整数行向量\noctave:2\u0026gt; 1:10 ans = 1 2 3 4 5 6 7 8 9 10 指定增量值\noctave:3\u0026gt; 100:-5:50 ans = 100 95 90 85 80 75 70 65 60 55 50 one more 栗子\noctave:4\u0026gt; 0:pi/8:pi ans = Columns 1 through 7: 0.00000 0.39270 0.78540 1.17810 1.57080 1.96350 2.35619 Columns 8 and 9: 2.74889 3.","title":"关于matlab使用冒号定义矩阵的小栗子"},{"content":"继《关于 mysql 中 max 函数和 groupby 联合使用的坑》后进一步关于 SQL 性能的探究\n类型 解释 id select 查询的序列号 select_type select 查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询 table 输出的行所引用的表 type 联合查询所使用的类型 possible_keys MySQL 能使用哪个索引在该表中找到行 key MySQL 实际决定使用的键 key_len MySQL 决定使用的键长 ref 哪个字段或常数与 key 一起被使用 rows mysql 要遍历多少数据才能找到，在 innodb 上是不准确的 Extra - 实例解释\nmysql\u0026gt; desc t3; +-------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | other | varchar(255) | YES | | NULL | | +-------+--------------+------+-----+---------+----------------+ 2 rows in set mysql\u0026gt; select * from (select * from (select * from t3 where id = 3952602) a) b; +---------+-------+ | id | other | +---------+-------+ | 3952602 | sth | +---------+-------+ 1 row in set mysql\u0026gt; explain select * from (select * from (select * from t3 where id = 3952602) a) b; +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 2 | DERIVED | \u0026lt;derived3\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 3 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ 3 rows in set mysql\u0026gt; show index from t3; +-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | t3 | 0 | PRIMARY | 1 | id | A | 1 | NULL | NULL | | BTREE | | | | t3 | 1 | idx_t3_id | 1 | id | A | 1 | NULL | NULL | | BTREE | | | +-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 2 rows in set id 从里往外执行，从 id 为 3 往上执行\n同时作为一个解释序号，比如 id 为 2 中的 table 中的 derived3 就是指 id 为 3 的那个 DERIVED（衍生表）\nselect_type SIMPLE | PRIMARY | UNION | DEPENDENT UNION | UNION RESULT | SUBQUERY | DEPENDENT SUBQUERY | DERIVED | 共 7 种\n逐个分析\nSIMPLE 简单查询，即不使用 UNION 或子查询\nmysql\u0026gt; explain select * from t3 where id = 3952602; +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+ | 1 | SIMPLE | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+ 1 row in set PRIMARY 最外层的主查询\nmysql\u0026gt; explain select * from (select * from t3 where id = 3952602) a; +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 2 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ 2 rows in set UNION union 中的第二个或者后面的 select 语句\nUNION RESULT mysql\u0026gt; select * from t3 where id = 3952602 union all select * from t3; +---------+-------+ | id | other | +---------+-------+ | 3952602 | sth | | 3952602 | sth | +---------+-------+ 2 rows in set mysql\u0026gt; explain select * from t3 where id = 3952602 union all select * from t3; +------+--------------+------------+-------+-------------------+---------+---------+-------+------+-----------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+--------------+------------+-------+-------------------+---------+---------+-------+------+-----------------+ | 1 | PRIMARY | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | | 2 | UNION | t3 | ALL | NULL | NULL | NULL | NULL | 1 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | ALL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+-------+-------------------+---------+---------+-------+------+-----------------+ 3 rows in set DEPENDENT UNION union 的结果\nmysql\u0026gt; select * from t3 where id in (select id from t3 where id = 3952602 union all select id from t3); +---------+-------+ | id | other | +---------+-------+ | 3952602 | sth | +---------+-------+ 1 row in set mysql\u0026gt; explain select * from t3 where id in (select id from t3 where id = 3952602 union all select id from t3); +------+--------------------+------------+--------+-------------------+---------+---------+-------+------+-----------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+--------------------+------------+--------+-------------------+---------+---------+-------+------+-----------------+ | 1 | PRIMARY | t3 | ALL | NULL | NULL | NULL | NULL | 1 | Using where | | 2 | DEPENDENT SUBQUERY | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | Using index | | 3 | DEPENDENT UNION | t3 | eq_ref | PRIMARY,idx_t3_id | PRIMARY | 4 | func | 1 | Using index | | NULL | UNION RESULT | \u0026lt;union2,3\u0026gt; | ALL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------------+------------+--------+-------------------+---------+---------+-------+------+-----------------+ 4 rows in set SUBQUERY 子查询的第一个 select\nmysql\u0026gt; select * from t3 where id = (select id from t3 where id = 3952602); +---------+-------+ | id | other | +---------+-------+ | 3952602 | sth | +---------+-------+ 1 row in set mysql\u0026gt; explain select * from t3 where id = (select id from t3 where id = 3952602); +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+ | 1 | PRIMARY | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | | 2 | SUBQUERY | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | Using index | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+ 2 rows in set DEPENDENT SUBQUERY 子查询的第一个查询，取决于外面的查询\nmysql\u0026gt; explain select * from t3 where id in (select id from t3 where id = 3952602); +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+ | 1 | SIMPLE | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | | 1 | SIMPLE | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | Using index | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+ 2 rows in set DERIVED 派生表的 select（from 子句的子查询）\nmysql\u0026gt; select * from (select * from t3 where id = 3952602); 1248 - Every derived table must have its own alias mysql\u0026gt; select * from (select * from t3 where id = 3952602) a; +---------+-------+ | id | other | +---------+-------+ | 3952602 | sth | +---------+-------+ 1 row in set mysql\u0026gt; explain select * from (select * from t3 where id = 3952602) a; +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 2 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ 2 rows in set table 该行数据是关于哪张表的\nmysql\u0026gt; explain select * from (select * from (select * from t3 where id = 3952602) a) b; +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 2 | DERIVED | \u0026lt;derived3\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 3 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ 3 rows in set type 重要指标，查询类型/访问类型\n从好到坏依次是：\nsystem \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; unique_subquery \u0026gt; index_subquery \u0026gt; range \u0026gt; index \u0026gt; ALL\n一般来说，得保证查询至少达到 range 级别，最好能达到 ref\nnull MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引\nsystem system 是 const 连接类型的一个特例，即当查询的表中仅有一行满足条件\nmysql\u0026gt; explain select * from (select * from t3 where id = 3952602) a; +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 2 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ 2 rows in set const 表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const 表很快，因为只读取一次\nmysql\u0026gt; explain select * from t3 where id = 3952602; +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+ | 1 | SIMPLE | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+ 1 row in set eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描\n对于每个来自前面的表的行组合，从该表中读取一行。是除了 const 最好的连接类型，用在一个索引的所有部分被连接使用并且索引是 UNIQUE 或 PRIMARY KEY\nmysql\u0026gt; explain select * from t3,t4 where t3.id = t4.accountId; +----+-------------+-------+--------+-------------------+---------+---------+-----------------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+--------+-------------------+---------+---------+-----------------+------+-------+ | 1 | SIMPLE | t3 | ALL | PRIMARY,idx_t3_id | NULL | NULL | NULL | 1 | NULL | | 1 | SIMPLE | t4 | eq_ref | PRIMARY | PRIMARY | 4 | localtest.t3.id | 1 | NULL | +----+-------------+-------+--------+-------------------+---------+---------+-----------------+------+-------+ 2 rows in set ref 非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引及唯一索引的非唯一前缀进行的查找\nref_or_null 该类型如同 ref，但是添加了 MySQL 可以专门搜索包含 null 值的行\nindex_merge 该连接类型表示使用了索引合并优化方法。这种情况下，key 列包含了使用的索引清单，key_len 包含了使用的索引最长的关键元素\nunique_subquery 子查询中的返回结果字段组合是主键或唯一索引，可以完全替换子查询，效率更高\nindex_subquery 类似于 unique_subquery，可以替换 IN 子查询，但只适合子查询中的返回结果字段组合是非唯一索引\nrange 只检索给定范围的行，使用一个索引来选择行。\nkey 显示使用了哪个索引，key_len 包含所使用索引的最长关键元素。\n在该类型中的 ref 列为 null\nmysql\u0026gt; explain select * from t3 where id = 3952602 or id = 3952603; +----+-------------+-------+-------+-------------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+-------------------+---------+---------+------+------+-------------+ | 1 | SIMPLE | t3 | range | PRIMARY,idx_t3_id | PRIMARY | 4 | NULL | 2 | Using where | +----+-------------+-------+-------+-------------------+---------+---------+------+------+-------------+ 1 row in set index 该连接类型与 ALL 相同，但只有索引树被扫描。通常比 ALL 快，因为索引文件通常比数据文件小\nALL 对于每个来自于先前的表的行组合，进行完整的表扫描。\n通常可以增加更多的索引而不要使用 ALL\npossible_keys 指出 MySQL 能使用哪个索引在该表中找到行\n如果是空的，则表示没有相关的索引。这时要提高性能，可通过检验 WHERE 子句，看是否它引用某些列或适合索引的列来提高查询性能。\nkey MySQL 实际决定使用的键（索引）\n若没有选择索引，值是 null\n若想强制 MySQL 使用或忽视 possible_keys 中的索引，查询中可用 FORCE INDEX、USE INDEX、IGNORE INDEX\nkey_len MySQL 决定使用的键长度，在不损失精确性的情况下，长度越短越好。特别注意这个值可以得出一个多重主键里 mysql 实际使用了哪一部分\nref 表示 MySQL 使用哪个列或常数与 key 一起从表中选择行\nrows MySQL 认为其执行查询时必须检查的行数\nextra 包含 MySQL 解决查询的详细信息\ndistinct 一旦找到与行相联合匹配的行就不再搜索了\nnot exists MySQL 优化了 left join，一旦找到了匹配 left join 标准的行，就不再搜索了\nrange checked for each Record(index map:#) 没有找到理想的索引，这是使用索引的最慢连接之一\nusing filesort 出现这种情况需要优化，因为 MySQL 需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。\nusing temporary MySQL 需要建立一个临时表来存储结果，通常发生在对不同的列集进行 order by 而不是 group by 上。\n如果此信息显示 Using filesort 或者 Using temporary 的话会很吃力，WHERE 和 ORDER BY 的索引经常无法兼顾，如果按照 WHERE 来确定索引，那么在 ORDER BY 时，就必然会引起 Using filesort，这就要看是先过滤再排序划算，还是先排序再过滤划算。\nusing index 不读数据文件，只从索引文件获取数据\nOnly index 这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。\nwhere used 就是使用上了 where 限制。\n如果是 impossible where 表示用不着 where，一般就是没查出来啥。\nEND 这篇博客写了好几天，中间断断续续，东拼西凑，内容有待改进。参考了很多，但都找不到完整详细的解释，关于参考的实例都进行了本地验证，特此整理\n主要参考链接：http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-10-31-sql-performance-profile/","summary":"继《关于 mysql 中 max 函数和 groupby 联合使用的坑》后进一步关于 SQL 性能的探究\n类型 解释 id select 查询的序列号 select_type select 查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询 table 输出的行所引用的表 type 联合查询所使用的类型 possible_keys MySQL 能使用哪个索引在该表中找到行 key MySQL 实际决定使用的键 key_len MySQL 决定使用的键长 ref 哪个字段或常数与 key 一起被使用 rows mysql 要遍历多少数据才能找到，在 innodb 上是不准确的 Extra - 实例解释\nmysql\u0026gt; desc t3; +-------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | other | varchar(255) | YES | | NULL | | +-------+--------------+------+-----+---------+----------------+ 2 rows in set mysql\u0026gt; select * from (select * from (select * from t3 where id = 3952602) a) b; +---------+-------+ | id | other | +---------+-------+ | 3952602 | sth | +---------+-------+ 1 row in set mysql\u0026gt; explain select * from (select * from (select * from t3 where id = 3952602) a) b; +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 2 | DERIVED | \u0026lt;derived3\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | NULL | | 3 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | const | 1 | NULL | +----+-------------+------------+--------+-------------------+---------+---------+-------+------+-------+ 3 rows in set mysql\u0026gt; show index from t3; +-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | t3 | 0 | PRIMARY | 1 | id | A | 1 | NULL | NULL | | BTREE | | | | t3 | 1 | idx_t3_id | 1 | id | A | 1 | NULL | NULL | | BTREE | | | +-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 2 rows in set id 从里往外执行，从 id 为 3 往上执行","title":"关于SQL性能评估的一些分析"},{"content":"关于朋友随手抛出的一段 SQL，发现 MySQL 中关于 max()和 group by 联合使用中的一个坑，特此整理。\nYH:老铁们，这段 hql 对不对啊\n我扫了一眼，总觉得看着别扭，自己试着去掉字符串拼接，还原出 SQL 来看，依然感觉不对，然后自己试着写了查询，在本地建个表，造了些数据，用简化后的 SQL 做测试时， 当我定睛检查以下这句 SQL\nselect predictId, max(evaluateDate) evalDate, productId from productcashpredict group by productId; 抛出一个疑问，MySQL 是从后往前执行，先分组再求分组结果中 evaluateDate 最大的记录呢？还是先找出 evaluateDate 的最大记录，再分组呢？\n网上查了查，发现，都不是！这里有个坑！如果直接这么结合 max 和 group by 使用，查出的结果，除了求 max 的字段和分组条件 productId 字段，其他字段的值都是错的！\n首先我在本地验证了一下是不是的确如此\ndesc productcashpredict; predictId\tint(11)\tNO\tPRI\tauto_increment evaluateDate\tdatetime\tYES\ton update CURRENT_TIMESTAMP other\tvarchar(255)\tYES productId\tint(11)\tYES select * from productcashpredict +-----------+---------------------+-------+-----------+ | predictId | evaluateDate | other | productId | +-----------+---------------------+-------+-----------+ | 1 | 2017-10-31 18:14:37 | NULL | 10001 | | 2 | 2017-10-31 18:14:45 | NULL | 10002 | | 3 | 2017-10-31 18:14:59 | NULL | 10002 | | 4 | 2017-10-31 18:15:09 | NULL | 10003 | | 5 | 2017-10-31 18:15:22 | NULL | 10001 | +-----------+---------------------+-------+-----------+ select predictId, max(evaluateDate) evalDate, productId from productcashpredict group by productId; +-----------+---------------------+-----------+ | predictId | evalDate | productId | +-----------+---------------------+-----------+ | 1 | 2017-10-31 18:15:22 | 10001 | | 2 | 2017-10-31 18:14:59 | 10002 | | 4 | 2017-10-31 18:15:09 | 10003 | +-----------+---------------------+-----------+ 直接这样查的确是错的，看 predictId 可以看出\n我们可以看出来，MySQL 其实是把以下两种查询揉在了一起，结果的确是按照 productId 进行分组的，查询结果也是从取自分组后，排序则是默认按照主键排序，但 evalDate 也的确取的是每一个 productId 组内最大的那一项，但这样揉起来，数据就不对了。\nselect * from productcashpredict group by productId; 1\t2017-10-31 18:14:37\t10001 2\t2017-10-31 18:14:45\t10002 4\t2017-10-31 18:15:09\t10003 select max(evaluateDate) evalDate, productId from productcashpredict; 2017-10-31 18:15:22\t10001 既然这样，那总得有解决方案，我又问了抛问者 YH，他们实际的使用场景是怎么查的，他甩出一张图。 我看了半天，很是理解不了，至少觉得逻辑不甚清晰，我开始质疑这样查询的结果是否正确，于是又去寻求 max 和 group by 联合使用的正确写法，得到下面两种方案：\n于是我又建了一张表，来模拟真实场景\ndesc product_cash_predict; id\tint(11)\tNO\tPRI\tauto_increment add_time\tdatetime\tYES\ton update CURRENT_TIMESTAMP deleted\tvarchar(255)\tYES update_time\tdatetime\tYES\ton update CURRENT_TIMESTAMP version\tvarchar(255)\tYES evaluated_date\tdatetime\tYES\ton update CURRENT_TIMESTAMP other\tvarchar(255)\tYES product_id\tint(11)\tYES SELECT * FROM `product_cash_predict`; +----+----------+---------+-------------+---------+---------------------+-------+------------+ | id | add_time | deleted | update_time | version | evaluated_date | other | product_id | +----+----------+---------+-------------+---------+---------------------+-------+------------+ | 1 | NULL | NULL | NULL | NULL | 2017-10-31 18:14:37 | NULL | 10001 | | 2 | NULL | NULL | NULL | NULL | 2017-10-31 18:14:45 | NULL | 10002 | | 3 | NULL | NULL | NULL | NULL | 2017-10-31 18:14:59 | NULL | 10002 | | 4 | NULL | NULL | NULL | NULL | 2017-10-31 18:15:09 | NULL | 10003 | | 5 | NULL | NULL | NULL | NULL | 2017-10-31 18:15:22 | NULL | 10001 | +----+----------+---------+-------------+---------+---------------------+-------+------------+ 先按 YH 的业务场景查询方式查一下：\nSELECT p2.* FROM ( SELECT max(evaluated_date) evaluated_date, product_id FROM product_cash_predict GROUP BY product_id ) p1 LEFT JOIN product_cash_predict p2 ON p1.product_id = p2.product_id AND p1.evaluated_date = p2.evaluated_date -- 0.034s -- +----+----------+---------+-------------+---------+---------------------+-------+------------+ | id | add_time | deleted | update_time | version | evaluated_date | other | product_id | +----+----------+---------+-------------+---------+---------------------+-------+------------+ | 3 | NULL | NULL | NULL | NULL | 2017-10-31 18:14:59 | NULL | 10002 | | 4 | NULL | NULL | NULL | NULL | 2017-10-31 18:15:09 | NULL | 10003 | | 5 | NULL | NULL | NULL | NULL | 2017-10-31 18:15:22 | NULL | 10001 | +----+----------+---------+-------------+---------+---------------------+-------+------------+ 那么这个结果对不对呢\n先来看一下错误的查询方式：\nselect id, add_time, deleted, update_time, version, max(evaluated_date) evalDate, other, product_id from product_cash_predict group by product_id; 1\t2017-10-31 18:15:22\t10001 2\t2017-10-31 18:14:59\t10002 4\t2017-10-31 18:15:09\t10003 由于数据量少，上面查询的错误肉眼可以用识别\n-- 解决方案一：先排序再分组 select * from product_cash_predict ORDER BY evaluated_date desc 5\t2017-10-31 18:15:22\t10001 4\t2017-10-31 18:15:09\t10003 3\t2017-10-31 18:14:59\t10002 2\t2017-10-31 18:14:45\t10002 1\t2017-10-31 18:14:37\t10001 select * from (select * from product_cash_predict ORDER BY evaluated_date desc) group by product_id; -- Every derived table must have its own alias（衍生表需要有其自己的别名） select * from (select * from product_cash_predict ORDER BY evaluated_date desc) as result group by product_id; -- 正确结果 5\t2017-10-31 18:15:22\t10001 3\t2017-10-31 18:14:59\t10002 4\t2017-10-31 18:15:09\t10003 -- 0.025s -- 0.025s -- 0.027s -- 解决方案二：看上去很费解 select * from product_cash_predict p where p.evaluated_date = (select max(evaluated_date) from product_cash_predict where p.product_id = product_id) group by product_id; 5\t2017-10-31 18:15:22\t10001 3\t2017-10-31 18:14:59\t10002 4\t2017-10-31 18:15:09\t10003 -- 0.028s -- 0.019s -- 0.025s 最后，也就是 YH 实际业务场景的处理方式再来回顾分析一波\n-- 解决方案三：自连接，根据max结合group by查出最大日期和分组条件product_id，再自连接查出该product_id对应的其他字段 -- 只查最大日期和分组条件product_id，若查其他字段则为不准的数据（group by取分组第一条） select max(evaluated_date) evalDate, product_id from product_cash_predict GROUP BY product_id 2017-10-31 18:15:22\t10001 2017-10-31 18:14:59\t10002 2017-10-31 18:15:09\t10003 -- 把查出的结果作为p1集 select p1.* from ( select max(evaluated_date) evalDate, product_id from product_cash_predict GROUP BY product_id ) p1; -- 然后从根据此结果自连接后查出的结果中取真是的记录值 select p2.* from ( select max(evaluated_date) evalDate, product_id from product_cash_predict GROUP BY product_id ) p1 LEFT JOIN product_cash_predict p2 on p1.product_id = p2.product_id and p1.evalDate = p2.evaluated_date; 3\t2017-10-31 18:14:59\t10002 4\t2017-10-31 18:15:09\t10003 5\t2017-10-31 18:15:22\t10001 性能比较 explain select * from (select * from product_cash_predict ORDER BY evaluated_date desc) as result group by product_id; +----+-------------+----------------------+------+---------------+------+---------+------+------+---------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+----------------------+------+---------------+------+---------+------+------+---------------------------------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | ALL | NULL | NULL | NULL | NULL | 5 | Using temporary; Using filesort | | 2 | DERIVED | product_cash_predict | ALL | NULL | NULL | NULL | NULL | 5 | Using filesort | +----+-------------+----------------------+------+---------------+------+---------+------+------+---------------------------------+ explain select * from product_cash_predict p where p.evaluated_date = (select max(evaluated_date) from product_cash_predict where p.product_id = product_id) group by product_id; +----+--------------------+----------------------+------+---------------+------+---------+------+------+----------------------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+--------------------+----------------------+------+---------------+------+---------+------+------+----------------------------------------------+ | 1 | PRIMARY | p | ALL | NULL | NULL | NULL | NULL | 5 | Using where; Using temporary; Using filesort | | 2 | DEPENDENT SUBQUERY | product_cash_predict | ALL | NULL | NULL | NULL | NULL | 5 | Using where | +----+--------------------+----------------------+------+---------------+------+---------+------+------+----------------------------------------------+ explain select p2.* from ( select max(evaluated_date) evalDate, product_id from product_cash_predict GROUP BY product_id ) p1 LEFT JOIN product_cash_predict p2 on p1.product_id = p2.product_id and p1.evalDate = p2.evaluated_date; +----+-------------+----------------------+------+---------------+------+---------+------+------+----------------------------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+----------------------+------+---------------+------+---------+------+------+----------------------------------------------------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | ALL | NULL | NULL | NULL | NULL | 5 | NULL | | 1 | PRIMARY | p2 | ALL | NULL | NULL | NULL | NULL | 5 | Using where; Using join buffer (Block Nested Loop) | | 2 | DERIVED | product_cash_predict | ALL | NULL | NULL | NULL | NULL | 5 | Using temporary; Using filesort | +----+-------------+----------------------+------+---------------+------+---------+------+------+----------------------------------------------------+ END 致谢：问题提出者，同时也是本文校对者 @YH\n总结：虽然可能这只是 SQL 查询中的一个小知识点，但不经分析，直接使用，可能会给业务带来不必要的坑，正所谓磨刀不误砍柴工，对常用技术的深入理解应该成为一个技术人的日常习惯。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-10-31-mysql-max-function-and-groupby/","summary":"关于朋友随手抛出的一段 SQL，发现 MySQL 中关于 max()和 group by 联合使用中的一个坑，特此整理。\nYH:老铁们，这段 hql 对不对啊\n我扫了一眼，总觉得看着别扭，自己试着去掉字符串拼接，还原出 SQL 来看，依然感觉不对，然后自己试着写了查询，在本地建个表，造了些数据，用简化后的 SQL 做测试时， 当我定睛检查以下这句 SQL\nselect predictId, max(evaluateDate) evalDate, productId from productcashpredict group by productId; 抛出一个疑问，MySQL 是从后往前执行，先分组再求分组结果中 evaluateDate 最大的记录呢？还是先找出 evaluateDate 的最大记录，再分组呢？\n网上查了查，发现，都不是！这里有个坑！如果直接这么结合 max 和 group by 使用，查出的结果，除了求 max 的字段和分组条件 productId 字段，其他字段的值都是错的！\n首先我在本地验证了一下是不是的确如此\ndesc productcashpredict; predictId\tint(11)\tNO\tPRI\tauto_increment evaluateDate\tdatetime\tYES\ton update CURRENT_TIMESTAMP other\tvarchar(255)\tYES productId\tint(11)\tYES select * from productcashpredict +-----------+---------------------+-------+-----------+ | predictId | evaluateDate | other | productId | +-----------+---------------------+-------+-----------+ | 1 | 2017-10-31 18:14:37 | NULL | 10001 | | 2 | 2017-10-31 18:14:45 | NULL | 10002 | | 3 | 2017-10-31 18:14:59 | NULL | 10002 | | 4 | 2017-10-31 18:15:09 | NULL | 10003 | | 5 | 2017-10-31 18:15:22 | NULL | 10001 | +-----------+---------------------+-------+-----------+ select predictId, max(evaluateDate) evalDate, productId from productcashpredict group by productId; +-----------+---------------------+-----------+ | predictId | evalDate | productId | +-----------+---------------------+-----------+ | 1 | 2017-10-31 18:15:22 | 10001 | | 2 | 2017-10-31 18:14:59 | 10002 | | 4 | 2017-10-31 18:15:09 | 10003 | +-----------+---------------------+-----------+ 直接这样查的确是错的，看 predictId 可以看出","title":"关于mysql中max函数和groupby联合使用的坑"},{"content":"谷歌某大佬通过一行知识量包含极丰富的 js 代码实现了一个魔法小功能：给页面所有元素加一个彩色外边框\n[].forEach.call($$(\u0026#34;*\u0026#34;), function (a) { a.style.outline = \u0026#34;1px solid #\u0026#34; + (~~(Math.random() * (1 \u0026lt;\u0026lt; 24))).toString(16); }); 单行形式：\n[].forEach.call($$(\u0026#34;*\u0026#34;), function (a) { a.style.outline = \u0026#34;1px solid #\u0026#34; + (~~(Math.random() * (1 \u0026lt;\u0026lt; 24))).toString(16); }); 将其贴到 chrome 的 console 中即可看到效果\n代码解析 $$(\u0026#34;*\u0026#34;); document.querySelectorAll(\u0026#34;*\u0026#34;); document.all; 以上三种写法是相同效果，都相当于通过选择器的方式获取页面所有元素。第三种是较不规范的方式，不建议使用。$$是现代浏览器API的一部分，比如$$(\u0026lsquo;a\u0026rsquo;)可以获取页面所有的 a 标签元素\n接下来，通过上面选择器获取到的是一个 NodeList，是一种类似于数组 Array，但它并未实现很多 Array 的接口，所以不能使用$$(\u0026rsquo;*\u0026rsquo;).forEach 来遍历结果，类似的还有 arguments，也是类似于 Array，但并不是数组\n这时需要通过 call()或者 apply()可以使得非数组对象来调用数组的方法\n[].forEach.call($$(\u0026#34;*\u0026#34;), function (e) {}); 以上即实现了遍历页面的每一个元素，并可以将获得的非数组元素使用数组的遍历方法来取到每一个元素 e\na.style.outline = \u0026#34;1px solid #\u0026#34; + color; outline 是 CSS 的一个属性，它是在 CSS 盒模型以外，所以它不会影响元素的 size 以及元素在 larout 中的 position\ncolor = (~~(Math.random() * (1 \u0026lt;\u0026lt; 24))).toString(16); 1\u0026lt;\u0026lt;24 == 1左移24位 == 2^24 == 16777216 parseInt(\u0026#34;ffffff\u0026#34;, 16) == 16777215 = 16777216 - 1 = 2^24 - 1 Math.random()得到的是 0.0~1.0 之间的伪随机数\nMath.random() * (1\u0026laquo;24)得到 0.0~16777216.0 之间的随机浮点数\n~操作符(tlide operator)可将一个变量按位取反，使用~操作符可以得到浮点数的整数部分，此处用~~达到 parseInt 的效果\ntoString(16)可将变量转换为 16 进制的数\n综上：(~~(Math.random()*(1\u0026laquo;24)).toString(16))可以获得(000000,ffffff)之间的一种随机颜色\nEND 附上大佬的博客Addy Osmani并献上双膝\n以及本文学习源 http://arqex.com/939/learning-much-javascript-one-line-code\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-10-17-learn-from-addy-osmani-code/","summary":"谷歌某大佬通过一行知识量包含极丰富的 js 代码实现了一个魔法小功能：给页面所有元素加一个彩色外边框\n[].forEach.call($$(\u0026#34;*\u0026#34;), function (a) { a.style.outline = \u0026#34;1px solid #\u0026#34; + (~~(Math.random() * (1 \u0026lt;\u0026lt; 24))).toString(16); }); 单行形式：\n[].forEach.call($$(\u0026#34;*\u0026#34;), function (a) { a.style.outline = \u0026#34;1px solid #\u0026#34; + (~~(Math.random() * (1 \u0026lt;\u0026lt; 24))).toString(16); }); 将其贴到 chrome 的 console 中即可看到效果\n代码解析 $$(\u0026#34;*\u0026#34;); document.querySelectorAll(\u0026#34;*\u0026#34;); document.all; 以上三种写法是相同效果，都相当于通过选择器的方式获取页面所有元素。第三种是较不规范的方式，不建议使用。$$是现代浏览器API的一部分，比如$$(\u0026lsquo;a\u0026rsquo;)可以获取页面所有的 a 标签元素\n接下来，通过上面选择器获取到的是一个 NodeList，是一种类似于数组 Array，但它并未实现很多 Array 的接口，所以不能使用$$(\u0026rsquo;*\u0026rsquo;).forEach 来遍历结果，类似的还有 arguments，也是类似于 Array，但并不是数组\n这时需要通过 call()或者 apply()可以使得非数组对象来调用数组的方法\n[].forEach.call($$(\u0026#34;*\u0026#34;), function (e) {}); 以上即实现了遍历页面的每一个元素，并可以将获得的非数组元素使用数组的遍历方法来取到每一个元素 e\na.style.outline = \u0026#34;1px solid #\u0026#34; + color; outline 是 CSS 的一个属性，它是在 CSS 盒模型以外，所以它不会影响元素的 size 以及元素在 larout 中的 position","title":"从谷歌\"名猿\"Addy Osmani一行代码中学到的东西"},{"content":"如何使用 atom 编辑器实现 html 实时预览\natom 自带 markdown 实时预览插件，但当我想用 atom 进行进端开发并取代 webstorm 这样的收费 IDE 时，我发现基于文件进行操作的编辑器 atom 只能高亮显示 html、js 这样的文件，但不能实时显示进行调试，很不方便。\n于是上网查，结果都是很简略的方法，作为刚开始上手 atom 的新手，一时不理解，终于经过自己的折腾成功使用\n特此记录，以便为新手提供方便，节省这些不必要的查询时间。\n1、搜索插件\n2、安装插件\n3、修改快捷键\natom-html-preview 初始快捷键为 ctrl+p，于 atom 已有快捷键冲突，修改为 ctrl+F12，如下 点击 File-\u0026gt;Settings-\u0026gt;KeyBindings-\u0026gt;your keymap file 超链接-\u0026gt;在末尾添加\n\u0026#39;atom-text-editor\u0026#39;: \u0026#39;ctrl-F12\u0026#39;:\u0026#39;atom-html-preview:toggle\u0026#39; ","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-10-16-preview-html-using-atom-editor/","summary":"如何使用 atom 编辑器实现 html 实时预览\natom 自带 markdown 实时预览插件，但当我想用 atom 进行进端开发并取代 webstorm 这样的收费 IDE 时，我发现基于文件进行操作的编辑器 atom 只能高亮显示 html、js 这样的文件，但不能实时显示进行调试，很不方便。\n于是上网查，结果都是很简略的方法，作为刚开始上手 atom 的新手，一时不理解，终于经过自己的折腾成功使用\n特此记录，以便为新手提供方便，节省这些不必要的查询时间。\n1、搜索插件\n2、安装插件\n3、修改快捷键\natom-html-preview 初始快捷键为 ctrl+p，于 atom 已有快捷键冲突，修改为 ctrl+F12，如下 点击 File-\u0026gt;Settings-\u0026gt;KeyBindings-\u0026gt;your keymap file 超链接-\u0026gt;在末尾添加\n\u0026#39;atom-text-editor\u0026#39;: \u0026#39;ctrl-F12\u0026#39;:\u0026#39;atom-html-preview:toggle\u0026#39; ","title":"atom实现html实时预览"},{"content":"日常知识总结及记录，本次关于由搜索区块链这一关键词引发的关于“为什么要记博客”这一问题的思考\n比特币 区块链 博客 微博 比特币\u0026amp;区块链 昨天看了今年的云栖峰会，再次听到了今年听到最多的“区块链”技术，于是今天闲暇之余，想了解一下这个区块链究竟是个什么东西。看了半天，并没有像某些编程技术一样，能够快速理解大概意思，反倒是产生了更多的陌生词汇，比如拜占庭将军问题，不过一个熟悉的字眼“比特币”倒是快速映入眼帘，原来区块链技术是和比特币原理紧密联系在一起的。\n博客\u0026amp;微博 于是就想着，为了理解这种概念东西，就记篇博客以助理解吧，但看着看着，觉得不懂的概念越来越多，而且查到的资料感觉讲的都很详细，感觉自己写不出更加合理的解释。于是就想到，为什么要记博客这个东西。\n为什么要记博客呢，可能每个人的答案都不一样。我这个人在探究“为什么”之前，都喜欢搞清楚“是什么”，那么博客是什么呢（以下内容为个人理解），博客这个词是音译 blog 而来，那么 blog 又是什么呢，我们都知道，很多时候，我们都需要对所发生的一切事情有个记录，叫做日志（log），而程序世界这个东西更广为人知，计算机程序的每个行为如果有日志的记录，在发生异常情况或者我们需要观测系统运行情况的时候才有据可循。\n其实博客这个东西最初就是一种网络日志（web log），用来在 web 里记录一些东西而已，让日志这个东西不止停留于程序后台的日志服务器里，而成为像在线笔记本/日记本一样的东西，可以方便人们随时随地把自己想记录下来的东西放到 web 这个大世界里。\n后来由此衍生出微博（micro blog）这个东西，但我觉得微博并不是一种“微型博客”，所谓字数受限，内容短小简洁的博客，因为它本身的定位和运营使其完全脱离于博客而成为一种新兴的事务，我个人觉得它如今已然成为一种社交媒介。因为你想想，微博可以看作一种一定字数的网络日志吗？不止于此！如今微博的内容可谓百花齐放，可以是广告平台，可以是资源分享，抑或是明星的粉丝们关注明星日常生活点滴的一个统一途径。\n尾声 最后，回归本文，我为什么要记博客，其实我是本着博客最原始的功用——网络日志这个功能。因为我希望把我对于所读所想的东西做一个记录，以加深我对于知识的理解。因为书写博客的过程本身也是对于某些事物理解的一个梳理。\n我把人的大脑比作计算机的 CPU，而理解能力和表达能力分别相当于计算机的 I/O 设备（Input 输入、Output 输入），人类向外界展现其内部思考的媒介依赖于这两者。比如作家、教师，属于输出能力示范的人群，而读者、观众属于展现输入过程人群。如今我们借助于互联网这个第三次技术革命的产物，每天都在输入大量的数据，而与此同时我认识到，仅仅有输入，却没有输出，是很可悲的。首先，对于 CPU 来说，仅仅有输入，而没有输出，不算是一次成功的数据处理，人也一样，对知识的学习，若仅仅停留于摄入，而不能经过大脑的思考，做出相应的反馈输出，比如分享，那样未必是一件好事。\n分享知识不会像分苹果一样越分越少\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-10-12-talk-about-blog/","summary":"日常知识总结及记录，本次关于由搜索区块链这一关键词引发的关于“为什么要记博客”这一问题的思考\n比特币 区块链 博客 微博 比特币\u0026amp;区块链 昨天看了今年的云栖峰会，再次听到了今年听到最多的“区块链”技术，于是今天闲暇之余，想了解一下这个区块链究竟是个什么东西。看了半天，并没有像某些编程技术一样，能够快速理解大概意思，反倒是产生了更多的陌生词汇，比如拜占庭将军问题，不过一个熟悉的字眼“比特币”倒是快速映入眼帘，原来区块链技术是和比特币原理紧密联系在一起的。\n博客\u0026amp;微博 于是就想着，为了理解这种概念东西，就记篇博客以助理解吧，但看着看着，觉得不懂的概念越来越多，而且查到的资料感觉讲的都很详细，感觉自己写不出更加合理的解释。于是就想到，为什么要记博客这个东西。\n为什么要记博客呢，可能每个人的答案都不一样。我这个人在探究“为什么”之前，都喜欢搞清楚“是什么”，那么博客是什么呢（以下内容为个人理解），博客这个词是音译 blog 而来，那么 blog 又是什么呢，我们都知道，很多时候，我们都需要对所发生的一切事情有个记录，叫做日志（log），而程序世界这个东西更广为人知，计算机程序的每个行为如果有日志的记录，在发生异常情况或者我们需要观测系统运行情况的时候才有据可循。\n其实博客这个东西最初就是一种网络日志（web log），用来在 web 里记录一些东西而已，让日志这个东西不止停留于程序后台的日志服务器里，而成为像在线笔记本/日记本一样的东西，可以方便人们随时随地把自己想记录下来的东西放到 web 这个大世界里。\n后来由此衍生出微博（micro blog）这个东西，但我觉得微博并不是一种“微型博客”，所谓字数受限，内容短小简洁的博客，因为它本身的定位和运营使其完全脱离于博客而成为一种新兴的事务，我个人觉得它如今已然成为一种社交媒介。因为你想想，微博可以看作一种一定字数的网络日志吗？不止于此！如今微博的内容可谓百花齐放，可以是广告平台，可以是资源分享，抑或是明星的粉丝们关注明星日常生活点滴的一个统一途径。\n尾声 最后，回归本文，我为什么要记博客，其实我是本着博客最原始的功用——网络日志这个功能。因为我希望把我对于所读所想的东西做一个记录，以加深我对于知识的理解。因为书写博客的过程本身也是对于某些事物理解的一个梳理。\n我把人的大脑比作计算机的 CPU，而理解能力和表达能力分别相当于计算机的 I/O 设备（Input 输入、Output 输入），人类向外界展现其内部思考的媒介依赖于这两者。比如作家、教师，属于输出能力示范的人群，而读者、观众属于展现输入过程人群。如今我们借助于互联网这个第三次技术革命的产物，每天都在输入大量的数据，而与此同时我认识到，仅仅有输入，却没有输出，是很可悲的。首先，对于 CPU 来说，仅仅有输入，而没有输出，不算是一次成功的数据处理，人也一样，对知识的学习，若仅仅停留于摄入，而不能经过大脑的思考，做出相应的反馈输出，比如分享，那样未必是一件好事。\n分享知识不会像分苹果一样越分越少","title":"漫谈博客这东西——漫谈系列"},{"content":" Do each of things in a decent way. 软件工程专业最失败的是培养出两种人：一，是只会编程的人，二，是连编程都不会的人。 知而不改，恶莫大焉 Always be young, never be die.(保持年轻，绝不作咸鱼) 生活应该是两件事：IN And OUT，IN 指 INPUT（读书、学习和思考），OUT 指 OUTPUT（做事、工作和实践） 天妒英才，所以天才总会被凡人当白痴 因为他经历完了过程，得到了结果，再看过程，就感觉没什么了，但如果他没这个过程，得不到结果，站在起点再看，就会觉得这个过程很必要了 卓越的方式有很多种，唯独不应该是以健康为代价的那种 If you want to win, you got to know exactly what the rule is. 有意识地在细节之处刻意不同，就能在和别人差不多的生活中活出不一样的自己 Pure to complex is accessible, but complex back to pure is irreversible. 灵感是转瞬即逝的，所以才需要记录下来 别给自己设上限，才能知道自己的极限；而每次的挑战极限，都是在提高自己的上限 理论上你可以成为任何你想要成为的人，而最难的是成为你自己 拒绝命运的审判，而是主动撰写命运 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-09-22-some-personal-quotes/","summary":" Do each of things in a decent way. 软件工程专业最失败的是培养出两种人：一，是只会编程的人，二，是连编程都不会的人。 知而不改，恶莫大焉 Always be young, never be die.(保持年轻，绝不作咸鱼) 生活应该是两件事：IN And OUT，IN 指 INPUT（读书、学习和思考），OUT 指 OUTPUT（做事、工作和实践） 天妒英才，所以天才总会被凡人当白痴 因为他经历完了过程，得到了结果，再看过程，就感觉没什么了，但如果他没这个过程，得不到结果，站在起点再看，就会觉得这个过程很必要了 卓越的方式有很多种，唯独不应该是以健康为代价的那种 If you want to win, you got to know exactly what the rule is. 有意识地在细节之处刻意不同，就能在和别人差不多的生活中活出不一样的自己 Pure to complex is accessible, but complex back to pure is irreversible. 灵感是转瞬即逝的，所以才需要记录下来 别给自己设上限，才能知道自己的极限；而每次的挑战极限，都是在提高自己的上限 理论上你可以成为任何你想要成为的人，而最难的是成为你自己 拒绝命运的审判，而是主动撰写命运 ","title":"一些个人语录整理"},{"content":"从百度拇指医生某热心网友总结那里引用来，觉得写得很不错，有参考意义，特此记录下来\n”为什么每年九月份过敏鼻炎就严重“\n”因为天气冷热温差比较大。 因为是过敏鼻炎，也可能是你的过敏原在秋季比较丰富。具体你要去医院查过敏原。 我过敏性鼻炎，每天早上起来打喷嚏，流鼻涕，流眼泪，眼睛痒痛充血，如遇天气干燥就容易流鼻血，部分时候会引起头痛。过敏原比较悲催，很普遍， 甲醛、尘螨、灰尘、温度变化都比较敏感。 吃的药基本没什么用。 弄点抗过敏的药就可以了，我现在连喷剂都不太管用。以下是我经过很多测试得到的一些经验，效果挺好，但是也要自己注意保养。\n【忌口】辛辣、羊肉、海鲜、避免喝冰水\n【温度】要注意保暖。洗脸用温水，尽量喝温水。最好少吹空调\n【清洗鼻腔】因为会对某些物质过敏，因此每天清洗一下鼻腔就很有必要了。 每天自制生理盐水冲鼻子，配方： 500ML 38 度的温水+4.5g 无碘盐+4.5g 小苏打。 如果觉得麻烦也可以去淘宝买现成的洗鼻盐。 清洗鼻子的设备，淘宝也有卖的，一种是专门用于洗鼻子的洗鼻机。另一种是洗牙的机器，但是也有洗鼻的喷头。其实就是一个水泵往鼻子里打水，具体方法参见说明书吧。 控制水温 37-38 度才会舒服，太冷会呛到，太热会烫坏鼻粘膜，弄个专门测液体温度的温度计，这种温度计就是厨房用针式的那种。\n【坚持锻炼】再有就是坚持锻炼身体会有很大的帮助，提高自身的抵抗力最重要。我是打羽毛球和爬山，我们爬的都是野山，景区效果不好，爬山效果比较明显，山里空气很好。\n【避免的运动类型】不要游泳，不要下海。 游泳池水进入鼻腔没有好处。 下海游泳要禁止，会使体温降低，如果海水进入鼻腔会导致非常严重的过敏反应。 下海游泳本人亲身经历过，非常痛苦。\n【防止揉眼睛】 眼睛痒痛最麻烦的是夜里不自主的揉眼睛，这样会更严重得结膜炎。我的方法是购买一个 3M 的实验室防护眼镜。它周围是软的，相对还算舒服。有效避免自己揉眼睛，目前没有更好的方法，总不能把自己的手捆起来吧！\n【药物】对我而言基本没什么用。抗过敏药:氯雷他定或者扑尔敏。缓解眼睛：双氯芬酸钠滴眼液。喷剂：丙酸倍氯米松鼻喷雾剂（少用，只有特别难受的时候用用吧）。头痛只能吃点去痛片了。其他遵医嘱（其实大夫也没办法）\n关键时刻，网民的建议也是有效的，感谢互联网让同病相怜的人可以分享彼此之间的感受和应对措施。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-09-18-health-tip/","summary":"从百度拇指医生某热心网友总结那里引用来，觉得写得很不错，有参考意义，特此记录下来\n”为什么每年九月份过敏鼻炎就严重“\n”因为天气冷热温差比较大。 因为是过敏鼻炎，也可能是你的过敏原在秋季比较丰富。具体你要去医院查过敏原。 我过敏性鼻炎，每天早上起来打喷嚏，流鼻涕，流眼泪，眼睛痒痛充血，如遇天气干燥就容易流鼻血，部分时候会引起头痛。过敏原比较悲催，很普遍， 甲醛、尘螨、灰尘、温度变化都比较敏感。 吃的药基本没什么用。 弄点抗过敏的药就可以了，我现在连喷剂都不太管用。以下是我经过很多测试得到的一些经验，效果挺好，但是也要自己注意保养。\n【忌口】辛辣、羊肉、海鲜、避免喝冰水\n【温度】要注意保暖。洗脸用温水，尽量喝温水。最好少吹空调\n【清洗鼻腔】因为会对某些物质过敏，因此每天清洗一下鼻腔就很有必要了。 每天自制生理盐水冲鼻子，配方： 500ML 38 度的温水+4.5g 无碘盐+4.5g 小苏打。 如果觉得麻烦也可以去淘宝买现成的洗鼻盐。 清洗鼻子的设备，淘宝也有卖的，一种是专门用于洗鼻子的洗鼻机。另一种是洗牙的机器，但是也有洗鼻的喷头。其实就是一个水泵往鼻子里打水，具体方法参见说明书吧。 控制水温 37-38 度才会舒服，太冷会呛到，太热会烫坏鼻粘膜，弄个专门测液体温度的温度计，这种温度计就是厨房用针式的那种。\n【坚持锻炼】再有就是坚持锻炼身体会有很大的帮助，提高自身的抵抗力最重要。我是打羽毛球和爬山，我们爬的都是野山，景区效果不好，爬山效果比较明显，山里空气很好。\n【避免的运动类型】不要游泳，不要下海。 游泳池水进入鼻腔没有好处。 下海游泳要禁止，会使体温降低，如果海水进入鼻腔会导致非常严重的过敏反应。 下海游泳本人亲身经历过，非常痛苦。\n【防止揉眼睛】 眼睛痒痛最麻烦的是夜里不自主的揉眼睛，这样会更严重得结膜炎。我的方法是购买一个 3M 的实验室防护眼镜。它周围是软的，相对还算舒服。有效避免自己揉眼睛，目前没有更好的方法，总不能把自己的手捆起来吧！\n【药物】对我而言基本没什么用。抗过敏药:氯雷他定或者扑尔敏。缓解眼睛：双氯芬酸钠滴眼液。喷剂：丙酸倍氯米松鼻喷雾剂（少用，只有特别难受的时候用用吧）。头痛只能吃点去痛片了。其他遵医嘱（其实大夫也没办法）\n关键时刻，网民的建议也是有效的，感谢互联网让同病相怜的人可以分享彼此之间的感受和应对措施。","title":"每年九月份给自己的一份健康警告"},{"content":"写博客的好处在于，能够对所学、所做、所想之事有所记录，返璞归真，互联网花了那么多的精力将传统办公进化到无纸办公，人们从纸质书籍的阅读习惯变成了碎片化学习。\n能够在这样的环境中圈出自己的一亩三分田，经营自己的博客，对自己既是记录，也是肯定，还能在经营博客的过程中更加认识自己。\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-08-21-thinking/","summary":"写博客的好处在于，能够对所学、所做、所想之事有所记录，返璞归真，互联网花了那么多的精力将传统办公进化到无纸办公，人们从纸质书籍的阅读习惯变成了碎片化学习。\n能够在这样的环境中圈出自己的一亩三分田，经营自己的博客，对自己既是记录，也是肯定，还能在经营博客的过程中更加认识自己。","title":"关于写博客的一些想法"},{"content":"在 Vultr 上搭建 ss，包含最简版 centos7 安装过程中的各种坑解决\n检查是否安装 python 安装 pip pip install shadowsocks pip install M2Crypto M2Crypto 安装前置条件：安装 pcre，然后安装 swig(直接安装 pcre，去安装 swig 会提示 pcre 未安装，即使 pcre 已安装-\u0026gt;解决方案，安装 pcre-devel，在发现这个问题之前卡住很久) 安装 pcre-devel 后安装 swig，并配置环境变量（注意！）\n安装 M2Crypto，再次失败，需要安装 openssl（openssl 下载）下载安装\n再次失败，缺少 perl，至少 perl5，make 时间略长，make test 时间更长\n安装 openssl，make 时间略长\n在 M2Crypto 文件夹中拷贝 openssl 头文件(根据 Linux 架构位数区分，lsb_release -a 查看，若未安装，则需要 yum install -y redhat-lsb 进行安装)失败，需要 yum install openssl-devel\n再次失败，提示 /usr/include/openssl/opensslconf.h:36: Error: CPP #error \u0026ldquo;\u0026ldquo;This openssl-devel package does not work your architecture?\u0026rdquo;\u0026rdquo;. Use the -cpperraswarn option to continue swig processing. 解决方案：env SWIG_FEATURES=\u0026quot;-cpperraswarn -includeall -D**uname -m** -I/usr/include/openssl\u0026quot; python setup.py build 直接执行提示 python.h 无法找到，解决-\u0026gt;yum install python-devel（解决方案均来自 stackoverflow，国内博客很多都没有建设性意见，纯属浪费时间）\npip setup.py install-\u0026gt;pip list|grep M2Crypto（终于成功！）\n在/etc 下新增 ss.json 代理配置文件 { \u0026ldquo;server\u0026rdquo;:\u0026ldquo;serverip\u0026rdquo;, \u0026ldquo;server_port\u0026rdquo;:8388, \u0026ldquo;local_address\u0026rdquo;:\u0026ldquo;127.0.0.1\u0026rdquo;, \u0026ldquo;local_port\u0026rdquo;:1080, \u0026ldquo;password\u0026rdquo;:\u0026ldquo;password\u0026rdquo;, \u0026ldquo;timeout\u0026rdquo;:300, \u0026ldquo;method\u0026rdquo;:\u0026ldquo;aes-256-cfb\u0026rdquo; }\nssserver -c /etc/ss.json 启动代理\ndevel 包主要是头文件之类的，共开发用，而且一般会依赖相应的包，安装的时候会自动装上去。\ndevel 包含普通包，只比普通包多了头文件。动态链接库的话两种包都有。编译的时候如果需要用到这个库，那么需要安装这个库的 devel，因为需要头文件\n在 Linux 系统中都存在类似的问题，在安装特定安装包的过程中，其依赖某些第三方开发包，会曝出某些文件找不到的错误，一般情况下是需要安装依赖包的开发版本的。 这个规则应该是通用的。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-08-16-setup-ss-using-vultr-and-centos7/","summary":"\u003cp\u003e在 Vultr 上搭建 ss，包含最简版 centos7 安装过程中的各种坑解决\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col\u003e\n\u003cli\u003e检查是否安装 python\u003c/li\u003e\n\u003cli\u003e安装 pip\u003c/li\u003e\n\u003cli\u003epip install shadowsocks\u003c/li\u003e\n\u003cli\u003epip install M2Crypto\u003c/li\u003e\n\u003cli\u003eM2Crypto 安装前置条件：安装 pcre，然后安装 swig(直接安装 pcre，去安装 swig 会提示 pcre 未安装，即使 pcre 已安装-\u0026gt;解决方案，安装 pcre-devel，在发现这个问题之前卡住很久)\u003c/li\u003e\n\u003c/ol\u003e","title":"在Vultr上搭建ss，包含最简版centos7安装过程中的各种坑解决"},{"content":"关于 python 科学计算库 numpy 学习总结\n本文中部分 print 输出可能会报错，原因为 python3 的 print 通过函数方式使用，与 python2 中的 print 通过解释执行不同，需要使用 print()进行控制台打印\n安装 numpy python3 -m pip install -U pip 更新 pip pip install numpy\n安装方式 II pip install ipython ipython \u0026ndash;pylab\npylab 模式下会自动导入 SciPy,NumPy,Matplotlib 模块\n引入 numpy import numpy as py\n使用 numpy arange()函数用于创建同类型多维数组（homogeneous multidimensional array）\n用 arange 创建的数组使用 type()查看类型为 ndarray\nreshape()函数用于重新构造数组成为其他维度数组\n例如：np.arange(20).reshape(4,5)\n[[0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]\narrry 数组相关属性： ndim：维度 shape：各维度大小 size：元素个数 dtype：元素类型 dsize：元素占位大小\n生成特殊矩阵 全零矩阵：np.zeros()\n注意：ones()和 zeros()函数的第一个参数是一个指向数列的指针，不能直接是一个数列，例如上图报错情况\n全一矩阵：np.ones(d,dtype=int) 默认生成浮点型，可通过第二个参数指定元素数据类型\n随机数数组\nnp.random.rand(5)生成包含 5 个[0,1)区间的数的数组\n数组计算 a = np.array([1.0, 2],[2, 4]) a [[1. 2.] [ 2. 4.]] 由于数组是【同质】的，python 会自动将整型转换为浮点型\nnp.exp(a)：自然常数 e（约等于 2.7）的 a 次方\nnp.sqrt(a)：a 的开方\nnp.square(a)：a 的平方\nnp.power(a,3)：a 的 3 次方\na.sum()：所有元素之和\na.max()：最大元素\na.min()：最小元素\na.max(axis=1)：每行最大\na.min(axis=0)：每列最小\n数组与矩阵（matrix） 注意： 矩阵是二维数组，矩阵乘法相求左侧矩阵列数等于右侧矩阵行数 数组可以是任意正整数维数，乘法要求两侧数组行列数均相同 相互转换 数组转矩阵 np.asmatrix(a) np.mat(a)\n直接生成 np.matrix(\u0026lsquo;1.0 2.0;3.0 4.0\u0026rsquo;)\n生成指定长度的一维数组 np.linspace(0,2,9)：生成从 0 开始，到 2 结束，包含 9 个元素的等差数列\n数组元素访问 a = np.array([3.2, 1.5],[2.5, 4]) print a[0][1] 1.5 print a[0,1] 1.5 注意： 若 b=a 是将 b 和 a 同时指向同一个 array，若修改 a 或者 b 的某个元素，a 和 b 都会改变 若想 a 和 b 不会关联修改，则需要 b = a.copy()为 b 单独生成一份拷贝\na: [[0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]] a[: , [1,3]]：访问 a 的所有行的 2、4 列\n访问符合条件的元素 a[: , 2]a[: , 0] \u0026gt; 5]\n解释： a [x] [y]表示访问符合 x、y 条件的 a 的元素，[: , 2]表示取所有行的第 3 列，[a[: , 0] \u0026gt; 5]表示取第一列大于 5 的行（即第 3、4 行），最终即表示取第 3、4 行的第 3 列，即得结果 array([12, 17])这个“子”数组\nnumpy.where()查找符合条件的位置 例如：loc = np.where(a == 11) print loc (array([2]), array([1]))\n结果是一个表示坐标的元组，元组第一个数组表示查询结果的行坐标，第二个数组表示结果的列坐标 print a[loc[0][0], loc[1][0]] 11\n上式为通过位置反求元素 11 注意：where 求出的结果为元组，不能通过 loc[x,y]的方式获取元素（该获取方式为数组的方式，因为元组没有索引），只能通过 loc[x][y]的方式获取\n数组其他操作 矩阵转置 a = np.random.rand(2,4) a = np.transpose(a)将 a 数组转置 b = np.random.rand(2,4) b = np.mat(b) print b.T 转置矩阵 矩阵求逆 import numpy.linalg as nlg a = np.random.rand(2,2) a = np.mat(a) ia = nlg.inv(a) 得逆矩阵 print a \\* ia [[1. 0.] [ 0. 1.]] 特征值和特征向量 a = np.random.rand(3,3) eig_value, eig_vector = nlg.eig(a)\n拼接矩阵（使用场景：循环处理某些数据后的操作） 按列拼接两个向量成一个矩阵\nvstack hstack\n实例：\na = np.random.rand(2,2) b = np.random.rand(2,2) c = np.hstack([a,b]) 水平拼接 d = np.vstack([a,b]) 垂直拼接 缺失值 nan 作为缺失值的记录 通过 isnan 判定\na = np.random.rand(2,2) a[0, 1] = np.nan print (np.isnan(a)) nan_to_num 可用来将 nan 替换成 0 pandas 提供能指定 nan 替换值的函数\nprint(np.nan_to_num(a)) [[0.54266589 0. ] [ 0.92468339 0.70599254]] 更多 Numpy 函数见\nhttp://wiki.scipy.org/Numpy_Example_List http://docs.scipy.org/doc/numpy 参考文献\nhttps://uqer.io/community/share/54ca15f9f9f06c276f651a56 http://wiki.scipy.org/Tentative_NumPy_Tutorial Sheppard K. Introduction to Python for econometrics, statistics and data analysis. Self-published, University of Oxford, version, 2012, 2.\n本文最初发布于个人 CSDN 博客\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-08-15-python-numpy/","summary":"关于 python 科学计算库 numpy 学习总结\n本文中部分 print 输出可能会报错，原因为 python3 的 print 通过函数方式使用，与 python2 中的 print 通过解释执行不同，需要使用 print()进行控制台打印\n安装 numpy python3 -m pip install -U pip 更新 pip pip install numpy\n安装方式 II pip install ipython ipython \u0026ndash;pylab\npylab 模式下会自动导入 SciPy,NumPy,Matplotlib 模块\n引入 numpy import numpy as py\n使用 numpy arange()函数用于创建同类型多维数组（homogeneous multidimensional array）\n用 arange 创建的数组使用 type()查看类型为 ndarray\nreshape()函数用于重新构造数组成为其他维度数组\n例如：np.arange(20).reshape(4,5)\n[[0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]","title":"关于python科学计算库numpy学习总结"},{"content":"mysql 远端数据库与本地数据库间导入导出\n远程数据库导出 mysqldump -hxxx -uxxx -pxxx 数据库名 \u0026gt; 脚本名.sql sz 脚本名.sql（SecureCRT 将文件下载到本地） 本地数据库导入 若直接用 navicat 运行本脚本，失败 打开 cmd，进入本地数据库，mysql -uxxxx -pxxxx，use 创建好的数据库 source 脚本名.sql，可以将 2MB 以上的 sql 脚本导入 成功执行，完成远端数据库到本地的克隆 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-08-12-mysql-remote-and-local-data-export/","summary":"mysql 远端数据库与本地数据库间导入导出\n远程数据库导出 mysqldump -hxxx -uxxx -pxxx 数据库名 \u0026gt; 脚本名.sql sz 脚本名.sql（SecureCRT 将文件下载到本地） 本地数据库导入 若直接用 navicat 运行本脚本，失败 打开 cmd，进入本地数据库，mysql -uxxxx -pxxxx，use 创建好的数据库 source 脚本名.sql，可以将 2MB 以上的 sql 脚本导入 成功执行，完成远端数据库到本地的克隆 ","title":"mysql远端数据库与本地数据库间导入导出"},{"content":"rc.local 是 Linux 启动程序在 login 程序前执行的最后一个脚本，有的服务器中在 rc.local 中可能会有一句 touch /var/lock/subsys/local，这是干什么的呢，在百度中没找到，最终在Linuxquestions.org 论坛成功找到满意的解答。\ntouch 首先要了解 touch 这个命令是做什么用的，在此用于创建一个不存在的文件，详细了解请见Linux touch 命令\n解释 /var/lock/subsys/local 这个文件的存在证明 rc.local 这个脚本已经执行过了，目的在于避免这个脚本重复执行，除非这个文件不存在时，它才失效，也就是当系统关闭（shut down）时会发生，翻译的不是很好，原文是\nWhat this does is create a lock file that tells the system that \u0026rsquo;local\u0026rsquo; is up and running already. It prevents the script from being run twice, as it will fail until the lockfile is removed, which will happen when you shut down.\nTypically this is used with bigger services such as database servers and so forth to make sure they are not started twice.\n这样做的目的是用于一些大型服务，例如数据库服务器，以确保它不会启动两次的情况出现。 至于 touch 出的这个文件什么时候被读取以避免再次生成，论坛两哥们是这么解释的\nTo tell the truth I don\u0026rsquo;t think anything looks there. I have never seen a lock mechanism in place for the rc.local script. Like I was saying, usually it is only used for bigger services. However, it is usually checked by the script itself. If you have a look at one of your more complicated rc scripts you may see in the \u0026lsquo;start\u0026rsquo; function something like (pseudo code): Code:\nstart() { if /var/lock/subsys/myapp exists; then echo \u0026#34;myapp already started\u0026#34; exit else touch /var/lock/subsys/myapp /command/to/start/myapp fi } 也就是会在一个地方，会有类似与上面 start()这样的方法会去判断是否已经存在一个 local 文件，如果有就不重复创建，如果没有就创建一个，后面再读取的时候就不会去创建，以此避免系统重复启动。\n本文最初发布于个人 CSDN 博客\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-08-05-linux-rc-local-file/","summary":"rc.local 是 Linux 启动程序在 login 程序前执行的最后一个脚本，有的服务器中在 rc.local 中可能会有一句 touch /var/lock/subsys/local，这是干什么的呢，在百度中没找到，最终在Linuxquestions.org 论坛成功找到满意的解答。\ntouch 首先要了解 touch 这个命令是做什么用的，在此用于创建一个不存在的文件，详细了解请见Linux touch 命令\n解释 /var/lock/subsys/local 这个文件的存在证明 rc.local 这个脚本已经执行过了，目的在于避免这个脚本重复执行，除非这个文件不存在时，它才失效，也就是当系统关闭（shut down）时会发生，翻译的不是很好，原文是\nWhat this does is create a lock file that tells the system that \u0026rsquo;local\u0026rsquo; is up and running already. It prevents the script from being run twice, as it will fail until the lockfile is removed, which will happen when you shut down.\nTypically this is used with bigger services such as database servers and so forth to make sure they are not started twice.","title":"关于Linux启动文件rc.local的解惑"},{"content":" 关于 java 字符串 String 以及 Hashcode 的一些整理\nhashcode 即是对象地址的十进制形式，而 equals 方法即是在比较两个对象的 hashcode 是否相等\npackage com.test.wx.testequals; public class TestEquals { public static void testEquals() { String a = \u0026#34;a\u0026#34;; String b = \u0026#34;a\u0026#34;; boolean result = a.equals(b); System.out.println(result); // true System.out.println(a.hashCode() == b.hashCode()); // true } public static void testEqual() { String a = \u0026#34;a\u0026#34;; String b = \u0026#34;a\u0026#34;; if (a == b) { // true System.out.println(\u0026#34;true\u0026#34;); System.out.println(a.hashCode() == b.hashCode()); } else { System.out.println(\u0026#34;false\u0026#34;); } } public static void testEquals2() { String a = \u0026#34;a\u0026#34;; String b = a; // equals方法比较两个对象的hashcode,hashcode即对象的地址 System.out.println(a.equals(b)); // == 比较两个变量或者对象的值是否相等，equals比较两个对象的引用是否相等（是否指向同一个对象） System.out.println(a==b); } public static void normalTest() { int a = 12; String b = String.valueOf(a); } public static void testObjectHashcode() { User user1 = new User(1, \u0026#34;test\u0026#34;); User user2 = new User(2, \u0026#34;test\u0026#34;); System.out.println(\u0026#34;user1 toString: \u0026#34;+user1); System.out.println(\u0026#34;user1 hashcode: \u0026#34;+user1.hashCode()); // hashcode即是对象地址的十进制形式 System.out.println(Integer.valueOf(\u0026#34;659e0bfd\u0026#34;, 16)); System.out.println(user2); } public static void hexToDeciaml() { long a = 1021653256; System.out.println(Long.toHexString(a));\t//3ce53108 System.out.println(Integer.valueOf(\u0026#34;659e0bfd\u0026#34;, 16)); } public static void main(String[] args) { // testEquals(); // testEqual(); // testEquals2(); // hexToDeciaml(); testObjectHashcode(); } } 枚举 enum 整理\n枚举 enum 是一种类型，不是类，所以不能被实例化，一般用来定义集合常量\npackage com.test.wx.testenum; public class EnumTest { PrinterType printType; enum PrinterType { INKJET, DOTMATRIX, LASER }; public EnumTest(PrinterType pType) { printType = pType; } public static void main(String[] args) { // PrinterType pType = new PrinterType(); EnumTest enumTest = new EnumTest(PrinterType.LASER); System.out.println(enumTest.printType); } } ","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-02-08-java-basic-03/","summary":"关于 java 字符串 String 以及 Hashcode 的一些整理\nhashcode 即是对象地址的十进制形式，而 equals 方法即是在比较两个对象的 hashcode 是否相等\npackage com.test.wx.testequals; public class TestEquals { public static void testEquals() { String a = \u0026#34;a\u0026#34;; String b = \u0026#34;a\u0026#34;; boolean result = a.equals(b); System.out.println(result); // true System.out.println(a.hashCode() == b.hashCode()); // true } public static void testEqual() { String a = \u0026#34;a\u0026#34;; String b = \u0026#34;a\u0026#34;; if (a == b) { // true System.out.println(\u0026#34;true\u0026#34;); System.out.println(a.hashCode() == b.hashCode()); } else { System.","title":"java零碎知识点整理（3）"},{"content":"一些常用正则表达式的整理\n非打印字符 1. \\t (table)制表符 等价于\\x09和\\cl 2. \\n (line feed)换行符 等价于\\x0a和\\cJ 3. \\v (vertical)垂直制表符 等价于\\x0b和\\cK 4. \\f (form feed)换页符 等价于\\x0c和\\cL 5. \\r (rarriage return)回车符 等价于\\x0d和\\cM 6. \\s (str)匹配任何空白字符，包括空格、制表符、换页符等） 等价于[\\f\\n\\r\\t\\v] 7. \\S匹配任何非空白字符 等价于[^\\f\\n\\r\\t\\v] 特殊字符 1. ^ 表示匹配输入字符串的开始位置，若在方括号中使用，则表示不接受该字符集合（例如上述\\S的等价匹配） 2. $ 匹配输入字符串的结尾，若设置了RegExp对象的Multiline属性，则$也匹配\\n或\\r 3. ? 匹配前面的子表达式0-1次，或指明一个非贪婪限定符 4. + 匹配前面的子表达式1-n次 5. * 匹配前面的子表达式0-n次 6. . 匹配除换行符（\\n）外的任何单字符（相当于windows系统中的?） 7. () 标记一个子表达式的开始和结束位置，子表达式可供以后使用 8. [ 标记一个中括号表达式的开始（）用于字符集合 9. { 标记限定符表达式的开始 10. \\ 将下一个字符标记为特殊字符、或原义字符、或后向引用、或八进制转义符 上述所有特殊字符，若要匹配其本身，都需要在其前面加反斜杠来转义使用\n限定符 限定符表示给定组件出现多少次才能满足匹配\n1. * 0-n次 2. + 1-n次 3. ? 0-1次 4. {n} 确定的n次 5. {n,} 至少n次 6. {n,m} （逗号两个数之间不能有空格） 最少n次且最多m次 * + ? 限定符都是贪婪的，即尽可能多的匹配文字，在其后加一个?可实现非贪婪或最小匹配 例如：\u0026lt;h1\u0026gt;Chapter 1 - Introduction to Regular Expression \u0026lt;/h1\u0026gt; /\u0026lt;.*\u0026gt;/将匹配上述全部内容 /\u0026lt;.*?\u0026gt;/将只匹配\u0026lt;h1\u0026gt; 定位符 定位符用来描述字符串或单词的边界\n1. ^ 描述字符串开始位置 2. $ 描述字符串结束位置 3. \\b 描述单词的前或后边界 4. \\B 描述非单词边界 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-02-07-regexp/","summary":"一些常用正则表达式的整理\n非打印字符 1. \\t (table)制表符 等价于\\x09和\\cl 2. \\n (line feed)换行符 等价于\\x0a和\\cJ 3. \\v (vertical)垂直制表符 等价于\\x0b和\\cK 4. \\f (form feed)换页符 等价于\\x0c和\\cL 5. \\r (rarriage return)回车符 等价于\\x0d和\\cM 6. \\s (str)匹配任何空白字符，包括空格、制表符、换页符等） 等价于[\\f\\n\\r\\t\\v] 7. \\S匹配任何非空白字符 等价于[^\\f\\n\\r\\t\\v] 特殊字符 1. ^ 表示匹配输入字符串的开始位置，若在方括号中使用，则表示不接受该字符集合（例如上述\\S的等价匹配） 2. $ 匹配输入字符串的结尾，若设置了RegExp对象的Multiline属性，则$也匹配\\n或\\r 3. ? 匹配前面的子表达式0-1次，或指明一个非贪婪限定符 4. + 匹配前面的子表达式1-n次 5. * 匹配前面的子表达式0-n次 6. . 匹配除换行符（\\n）外的任何单字符（相当于windows系统中的?） 7. () 标记一个子表达式的开始和结束位置，子表达式可供以后使用 8. [ 标记一个中括号表达式的开始（）用于字符集合 9. { 标记限定符表达式的开始 10. \\ 将下一个字符标记为特殊字符、或原义字符、或后向引用、或八进制转义符 上述所有特殊字符，若要匹配其本身，都需要在其前面加反斜杠来转义使用\n限定符 限定符表示给定组件出现多少次才能满足匹配\n1. * 0-n次 2. + 1-n次 3.","title":"正则表达式——学习笔记"},{"content":"python 零碎知识点整理——注释\n单行注释 python 的单行注释用#，可在任意位置添加（单独一行或语句/表达式后面，python 是解释型语言，逐行按序解释代码）\n多行注释 多行注释使用三个单引号或双引号 这实际上是多行字符串的书写方式，并非 python 本身提倡的多行注释\n编码声明注释 出现在 python 脚本第一行或第二行（其他行则无效）的含有 coding:xxx 的注释被认为是对编码方式的声明，详见python 官方文档\n从 python3 开始，python 默认使用 utf-8 编码（python3 以前使用 ascii 编码）\n平台注释 使 python 程序运行在 windows 平台上，需要在 python 文件的最前面加上#!/usr/bin/python，这说明了程序用的环境的路径\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2017-02-07-python-comment/","summary":"python 零碎知识点整理——注释\n单行注释 python 的单行注释用#，可在任意位置添加（单独一行或语句/表达式后面，python 是解释型语言，逐行按序解释代码）\n多行注释 多行注释使用三个单引号或双引号 这实际上是多行字符串的书写方式，并非 python 本身提倡的多行注释\n编码声明注释 出现在 python 脚本第一行或第二行（其他行则无效）的含有 coding:xxx 的注释被认为是对编码方式的声明，详见python 官方文档\n从 python3 开始，python 默认使用 utf-8 编码（python3 以前使用 ascii 编码）\n平台注释 使 python 程序运行在 windows 平台上，需要在 python 文件的最前面加上#!/usr/bin/python，这说明了程序用的环境的路径","title":"python零碎知识点整理——注释"},{"content":" 构造器（构造方法）\n在类实例化时被调用，对实例对象进行初始化\npackage com.test.wx.testinit; public class Color { int red, green, blue; /** * 以下这个方法不是构造器，构造器没有“void”这个返回值 */ void Color() { red = 10; green = 10; blue = 10; } /** * 这才是正确的构造器，会在类实例化一个对象时被调用，对对象进行初始化 */ Color() { red = 10; green = 10; blue = 10; } void printColor() { System.out.println(\u0026#34;red:\u0026#34;+red+\u0026#34;green:\u0026#34;+green+\u0026#34;blue:\u0026#34;+blue); } public static void main(String[] args) { Color color = new Color(); color.printColor();\t// red:0green:0blue:0 } } 修饰符（关键字）\nfinal/abstract\nabstract 不能与 final 同时使用，abstract类为抽象类，包含抽象的方法待实现，需要其他类继承该类，对抽象方法进行具体实现，而final修饰的类表示该类不可被继承，二者相违背。\n","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-02-07-java-basic-02/","summary":"构造器（构造方法）\n在类实例化时被调用，对实例对象进行初始化\npackage com.test.wx.testinit; public class Color { int red, green, blue; /** * 以下这个方法不是构造器，构造器没有“void”这个返回值 */ void Color() { red = 10; green = 10; blue = 10; } /** * 这才是正确的构造器，会在类实例化一个对象时被调用，对对象进行初始化 */ Color() { red = 10; green = 10; blue = 10; } void printColor() { System.out.println(\u0026#34;red:\u0026#34;+red+\u0026#34;green:\u0026#34;+green+\u0026#34;blue:\u0026#34;+blue); } public static void main(String[] args) { Color color = new Color(); color.printColor();\t// red:0green:0blue:0 } } 修饰符（关键字）\nfinal/abstract\nabstract 不能与 final 同时使用，abstract类为抽象类，包含抽象的方法待实现，需要其他类继承该类，对抽象方法进行具体实现，而final修饰的类表示该类不可被继承，二者相违背。","title":"java零碎知识点整理（2）"},{"content":"字符串相关方法、数据类型转换、正则表达式\npackage com.test.wx.teststr; import java.util.regex.Matcher; import java.util.regex.Pattern; public class TestString { public static void intToString() { int i = 10; Integer j = 11; int k = 12; Integer l = 13; String iStr = String.valueOf(i); // String iStr2 = (String)j; // String iStr3 = (String)k; String iStr4 = String.valueOf(l); System.out.println(iStr); System.out.println(iStr4); } public static void indexOfTest() { String quote = \u0026#34;An *onion* a day keeps everyone away!\u0026#34;; int startBound = quote.indexOf(\u0026#34;*\u0026#34;); int endBound = quote.lastIndexOf(\u0026#34;*\u0026#34;); System.out.println(startBound+\u0026#34; \u0026#34;+endBound); System.out.println(quote.substring(startBound, endBound)); } public static void regexTest(String input) { /** * java中对反斜杠解释为转义符号 * 所以制定正则字符串时，要对反斜杠做转义处理 * \\d{n}表示n个数字，要多加一个\\以使\\d的反斜杠生效 * \\\\+匹配加号 * +在正则中有专属含义，表示匹配其前面的内容1-n次 * 若要匹配加号本身，需要对加号进行正则的转义处理（即加反斜杠）， * 若要表示转义，需要对反斜杠进行java的转义处理（即加反斜杠） */ String regex = \u0026#34;\\\\+\\\\d{2}-\\\\d{11}\u0026#34;;\t// true // String regex = \u0026#34;\u0026#34;; // String regex = \u0026#34;\\\\bcat\\\\b\u0026#34;; // String regex = \u0026#34;+\\d{2}-d{10}\u0026#34;; // String regex = \u0026#34;\\b+\\d{2}-d{10}\\b\u0026#34;; // String regex = \u0026#34;\u0026#34;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(input); boolean result = matcher.matches(); System.out.println(result); } public static void main(String[] args) { // intToString(); // indexOfTest(); regexTest(\u0026#34;+86-17355159636\u0026#34;);\t// true } } final 关键字修饰函数参数\npackage com.test.wx.testfinal; public class TestKwFinal { public static int i; public static void testBaseFinal() { i = 3; System.out.println(i); finalSet(i); System.out.println(i); } public static void testFinalReference() { User user = new User(); user.setId(1); user.setName(\u0026#34;Tom\u0026#34;); System.out.println(user.getId()+\u0026#34; \u0026#34;+user.getName()); finalRefSet(user); System.out.println(user.getId()+\u0026#34; \u0026#34;+user.getName()); } /** * 基本类型的值在方法内部不能被改变 * @param i */ public static void finalSet(final int i) { // i = 10; } /** * 所指向的引用未被改变，依然是User，但是引用的属性值可以被改变 * @param user */ public static void finalRefSet(final User user) { // user = new User(); user.setName(\u0026#34;Jerry\u0026#34;); } public static void main(String[] args) { // testBaseFinal(); testFinalReference(); } } ","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-02-07-java-basic-01/","summary":"字符串相关方法、数据类型转换、正则表达式\npackage com.test.wx.teststr; import java.util.regex.Matcher; import java.util.regex.Pattern; public class TestString { public static void intToString() { int i = 10; Integer j = 11; int k = 12; Integer l = 13; String iStr = String.valueOf(i); // String iStr2 = (String)j; // String iStr3 = (String)k; String iStr4 = String.valueOf(l); System.out.println(iStr); System.out.println(iStr4); } public static void indexOfTest() { String quote = \u0026#34;An *onion* a day keeps everyone away!\u0026#34;; int startBound = quote.","title":"java零碎知识点整理（1）"},{"content":"windows 删除“找不到该项目”的文件该怎么办\n编写一个自动删除脚本，内容如下：\n右键，新建文本文件 重命名为 del.bat 编辑内容：del /F /A /Q \\?%1（第一行） rd /S /Q \\?%1（第二行） 把要删除的文件直接拖到该脚本上即可删除\n原理\n方法采纳自百度经验删除文件时提示“找不到该项目”，怎么解决? del 为 windows 删除文件的命令，rd 为 windows 删除目录的命令，/F 为强制删除参数，/A 为根据文件属性删除文件，/Q 为安静删除模式参数（删除全局通配符时不需要确认），后面的\\?即为全局通配符（UNC），？表示一个字符，在此仅为\u0026quot;.\u0026quot;，即当前电脑 ","permalink":"https://barnett617.github.io/wilson-blog/notes/2017-02-06-windows-missing-file/","summary":"windows 删除“找不到该项目”的文件该怎么办\n编写一个自动删除脚本，内容如下：\n右键，新建文本文件 重命名为 del.bat 编辑内容：del /F /A /Q \\?%1（第一行） rd /S /Q \\?%1（第二行） 把要删除的文件直接拖到该脚本上即可删除\n原理\n方法采纳自百度经验删除文件时提示“找不到该项目”，怎么解决? del 为 windows 删除文件的命令，rd 为 windows 删除目录的命令，/F 为强制删除参数，/A 为根据文件属性删除文件，/Q 为安静删除模式参数（删除全局通配符时不需要确认），后面的\\?即为全局通配符（UNC），？表示一个字符，在此仅为\u0026quot;.\u0026quot;，即当前电脑 ","title":"windows删除“找不到该项目”的文件"},{"content":"IDEA2016 配置运行基于 Maven 的 Git 项目\n一、IDEA\u0026amp;Maven\u0026amp;Git 作用 IDEA（项目容器） Maven（管理 Jar 和项目打包） Git（版本控制） 二、从远程 clone git 项目 使用工具 clone 下 git 项目\n可能问题： 直接通过 git bash 上 git clone 时可能失败\n问题解决：使用 TortoiseGit（有时候 TortoiseGit 也可能失败，可能和 gitblit 服务器有关）。\n可能项目由多个 module 相互依赖\n从 Git 直接 clone 下的项目，未编译，即不含 target 或 out 文件夹（gitignore 中限制编译后的文件被 Git 管理）\n但有 pom.xml 文件（Idea 导入基于 Maven 的项目依赖该文件，即导入项目时需找到 pom.xml 文件）\n三、将 clone 到本地的 Maven 项目使用 IDEA 编辑（导入或打开） 如果一个项目有多个相互依赖的 module 组成（各自 module 分别有 pom.xml），则在 Idea 中依次导入已存在 module（不是新建 module）\n由多个 module 相互依赖组成的项目，会有一个是主 module\n或者通过 open 的方式（更快）找到 pom.xml（多个 module 使用同一个 module）\n！！！对于 Maven 项目，使用 IDEA 导入可能出现的情况：\n如果直接打开的 module 文件夹，而不是 pom.xml 文件，则不会生成 Maven 项目，这是 remove 了 module，会残余文件，若 delete 后，则从 git 上 clone 下的 module 文件夹中将没有了 pom.xml（因为刚才 delete 掉了），此时再看该 module 文件夹，git 已提示有文件被删除了（原因：IDEA 只是管理代码的 IDE，对于打开项目之后的操作都是对本地文件的操作，从 IDE 里删除了文件，也就是对本地文件进行删除）\n方式二：直接使用 Idea，project from Git\n四、IDEA 初始化配置 第零步：jdk\u0026amp;maven 配置\n第一步：Project Structure\nproject name SDK project compiler output 第二步：服务器配置 热部署（JRebel 可通过 VM 配置，给运行的容器 VM 参数 ） 第三部：fix artifacts，选择 war exploded\n五、启动项目 编译（build） 启动服务器 六、问题情况 导入 module 后，提示 is registered as a Git root, but no Git repositories were found there.点击 config，将项目添加 git，之后正常配置，即为正常\n启动 tomcat，debugger 端口被占用 java.net.SocketException \u0026ldquo;socket closed\u0026rdquo;\n七、问题情况 如果端口被占用情况反复出现，且已确认自己正确配置，那么重启电脑是最好的解决办法，其他的端口被占用情况类似（因为端口占用的问题浪费了几个小时都找不到原因，查了 stackoverflow，segementFault，看了各种博客，解决方法都不行，原来重启就解决了。。。俗话说：没有什么是重启电脑解决不了的，重启真是神技啊！）\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-27-config-idea-for-maven-projects-with-git/","summary":"IDEA2016 配置运行基于 Maven 的 Git 项目\n一、IDEA\u0026amp;Maven\u0026amp;Git 作用 IDEA（项目容器） Maven（管理 Jar 和项目打包） Git（版本控制） 二、从远程 clone git 项目 使用工具 clone 下 git 项目\n可能问题： 直接通过 git bash 上 git clone 时可能失败\n问题解决：使用 TortoiseGit（有时候 TortoiseGit 也可能失败，可能和 gitblit 服务器有关）。\n可能项目由多个 module 相互依赖\n从 Git 直接 clone 下的项目，未编译，即不含 target 或 out 文件夹（gitignore 中限制编译后的文件被 Git 管理）\n但有 pom.xml 文件（Idea 导入基于 Maven 的项目依赖该文件，即导入项目时需找到 pom.xml 文件）\n三、将 clone 到本地的 Maven 项目使用 IDEA 编辑（导入或打开） 如果一个项目有多个相互依赖的 module 组成（各自 module 分别有 pom.","title":"IDEA2016配置运行基于Maven的Git项目"},{"content":"Maven 学习\n一、什么是 Maven Apache Maven 是一个软件项目管理和综合工具，基于项目对象模型（POM——Project Object Model），Maven 可以从一个中心资料片管理项目构建，报告和文件。\nMaven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。\n二、核心 Maven 项目的结构和内容在一个 XML 文件中声明，pom.xml 项目对象模型（POM），这是整个 Maven 系统的基本单元。\n三、特性 Apache Maven 是一种创新的软件项目管理工具，提供了一个项目对象模型（POM）文件的新概念来管理项目的构建，相关性和文档。最强大的功能就是能够自动下载项目依赖库。\n四、安装配置 JDK（若未按照默认安装在 C 盘，则 PATH 中需要将 jdk 的 bin 目录放在PATH 开头） Maven 根目录（添加 M2_HOME、MAVEN_HOME 都指向 Maven 安装文件夹） 添加到环境变量（添加%M2_HOME%\\bin 到 PATH） 验证环境变量配置（mvn -version） 五、启用代理访问 若公司存在防火墙，并使用HTTP 代理服务器阻止用户直接连接到互联网（若使用代理，Maven 将无法下载任何依赖），则需要在 Maven 配置文件（setting.xml）中设置代理服务器，设置完成后保存（无需重启，Maven 是一个批处理文件，调用时会重新读取配置文件）\n六、本地仓库 默认本地存储文件夹为用户目录下到.m2 目录，可在配置文件（setting.xml）中修改默认仓库位置，并重新命名\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-20-maven-basic/","summary":"Maven 学习\n一、什么是 Maven Apache Maven 是一个软件项目管理和综合工具，基于项目对象模型（POM——Project Object Model），Maven 可以从一个中心资料片管理项目构建，报告和文件。\nMaven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。\n二、核心 Maven 项目的结构和内容在一个 XML 文件中声明，pom.xml 项目对象模型（POM），这是整个 Maven 系统的基本单元。\n三、特性 Apache Maven 是一种创新的软件项目管理工具，提供了一个项目对象模型（POM）文件的新概念来管理项目的构建，相关性和文档。最强大的功能就是能够自动下载项目依赖库。\n四、安装配置 JDK（若未按照默认安装在 C 盘，则 PATH 中需要将 jdk 的 bin 目录放在PATH 开头） Maven 根目录（添加 M2_HOME、MAVEN_HOME 都指向 Maven 安装文件夹） 添加到环境变量（添加%M2_HOME%\\bin 到 PATH） 验证环境变量配置（mvn -version） 五、启用代理访问 若公司存在防火墙，并使用HTTP 代理服务器阻止用户直接连接到互联网（若使用代理，Maven 将无法下载任何依赖），则需要在 Maven 配置文件（setting.xml）中设置代理服务器，设置完成后保存（无需重启，Maven 是一个批处理文件，调用时会重新读取配置文件）\n六、本地仓库 默认本地存储文件夹为用户目录下到.m2 目录，可在配置文件（setting.xml）中修改默认仓库位置，并重新命名","title":"Maven学习"},{"content":"ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在2015 年发布的，所以又称 ECMAScript 2015。\n一、ES6 简介 ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在2015 年发布的，所以又称 ECMAScript 2015。\n即 ES6 === ES2015\n二、ES6 转码器 Babel是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。（chrome 已支持 ES6 解释，亲测可用）大家可以选择自己习惯的工具来使用使用 Babel，具体过程可直接在Babel 官网查看：\n三、常用特性 let / const（与传统 var 对比） class / extends / super（面向对象） arrow functions（箭头函数） template string（模板字符串） destructing（解构） default（默认值） rest / arguments（函数参数） 四、特性详解 （1）let 与 var 类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。\nvar name = \u0026#34;tom\u0026#34;; while (true) { var name = \u0026#34;bar\u0026#34;; console.log(name); break; } console.log(name); bar bar\n使用 var 两次输出都是 bar，内层变量覆盖外层变量。这是因为 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n而 let 则实际上为 JavaScript 新增了块级作用域。用它所声明的变量，只在 let 命令所在的代码块内有效。\nlet name = \u0026#34;tom\u0026#34;; while (true) { let name = \u0026#34;bar\u0026#34;; console.log(name); break; } console.log(name); bar tom\n另外一个 var 带来的不合理场景就是用来计数的循环变量泄露为全局变量，如下\nvar a = []; for(var i=0; i\u0026lt;10; i++) { a[i] = function() { console.log(i); }; } a[5](); 10\n上面代码中，变量 i 是 var 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的 i 的值。而使用 let 则不会出现这个问题。\nvar a = []; for (let i = 0; i \u0026lt; 10; i++) { a[i] = function () { console.log(i); }; } a[5](); 5\n（2）const const 也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。\nconst PI = Math.PI PI = 23 VM1600:2 Uncaught TypeError: Assignment to constant variable.(…)(anonymous function) @ VM1600:2 当我们尝试去改变用 const 声明的常量时，浏览器就会报错。const 有一个很好的应用场景，就是当我们引用第三方库时声明的变量，用 const 来声明可以避免未来不小心重命名而导致出现 bug：\nconst monent = require(\u0026lsquo;moment\u0026rsquo;)\n（3）class/extends/super ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念。新的 class 写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。\nclass Animal { constructor() { this.type = \u0026#39;animal\u0026#39; } says(say) { console.log(this.type + \u0026#39;says\u0026#39; +say) } } let animal = new Animal() animal.says(\u0026#39;hello\u0026#39;) animalsayshello\nclass Cat extends Animal { constructor() { super() this.type = \u0026#39;cat\u0026#39; } } let cat = new Cat() cat.says(\u0026#39;hello\u0026#39;) catsayshello\n上面代码首先用class定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法。\n而this关键字则代表实例对象。简单地说，constructor 内定义的方法和属性是实例对象自己的，而 constructor 外定义的方法和属性则是所有实例对象可以共享的。\nClass 之间可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个 Cat 类，该类通过 extends 关键字，继承了 Animal 类的所有属性和方法。\nsuper关键字，它指代父类的实例（即父类的this 对象）。子类必须在 constructor 方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。\nES6 的继承机制，实质是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。\n（4）arrow function ES6 最最常用的一个新特性了，用它来写 function 比原来的写法要简洁清晰很多\nvar f = (i) =\u0026gt; i+1 var result = f(3) console.log(result) 4\n其实声明函数只需要（i）=\u0026gt;i + 1 这一句 ES6 的箭头函数功能强大，详情见Arrow Functions\n// ES5函数使用 function test(x, y) { x++; y--; return x + y; } var f1 = test(6, 7) console.log(f1) 13\n这里实际为 7+6，return 的时候 x 已经为 7，y 为 6，可自行调试观察\n// ES6 arrow functions var arrow = (x, y) =\u0026gt; {x++;y--;return x+y} var result2 = arrow(3, 9) console.log(result2) Arrow functions 还可以解决一个 ES5 中关于 this 的问题，JavaScript 语言的 this 对象一直是一个令人头痛的问题，在对象方法中使用 this，例如：\nclass Animal { constructor() { this.type = \u0026#39;animal\u0026#39; } says(say) { setTimeout(function() { console.log(this.type + \u0026#39; says \u0026#39; + say) }, 1000) } } var animal = new Animal() animal.says(\u0026#39;hi\u0026#39;) undefined says hi\n原因：setTimeout 中的 this 指向的是全局对象\n传统解决方法 1：将 this 传给 self,再用 self 来指代 this\nclass Animal { constructor() { this.type = \u0026#39;animal\u0026#39; } says(say) { var self = this setTimeout(function() { console.log(self.type + \u0026#39; says \u0026#39; + say) }, 1000) } } var animal = new Animal() animal.says(\u0026#39;hi\u0026#39;) 传统解决方法 2：使用 bind(this)\nclass Animal { constructor() { this.type = \u0026#39;animal\u0026#39; } says(say) { setTimeout(function() { console.log(this.type + \u0026#39; says \u0026#39; + say) }.bind(this), 1000) } } var animal = new Animal() animal.says(\u0026#39;hi\u0026#39;) 使用 arrow functions 解决\nclass Animal { constructor() { this.type = \u0026#39;animal\u0026#39; } says(say) { setTimeout( () =\u0026gt; { console.log(this.type + \u0026#39; says \u0026#39; + say) }, 1000) } } var animal = new Animal() animal.says(\u0026#39;hi\u0026#39;) 当我们使用箭头函数时，函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，它的 this 是继承外面的，因此内部的 this 就是外层代码块的 this。\n（5）template string 当我们要插入大段的html 内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; $(function() { var count = 5 var onSale = 3 $(\u0026#34;#result\u0026#34;).append( \u0026#34;There are \u0026lt;b\u0026gt;\u0026#34; + count + \u0026#34;\u0026lt;/b\u0026gt;\u0026#34; + \u0026#34; items in your basket,\u0026#34; + \u0026#34;\u0026lt;em\u0026gt;\u0026#34; + onSale + \u0026#34;\u0026lt;/em\u0026gt; are on sale!\u0026#34; ); }) testThere are 5 items in your basket,3 are on sale!\n要用一堆的\u0026rsquo;+\u0026lsquo;号来连接文本与变量，而使用 ES6 的新特性**模板字符串``**后，我们可以直接这么来写\n$(function() { var count = 5 var onSale = 3 $(\u0026#34;#result\u0026#34;).append(` There are \u0026lt;b\u0026gt;${count}\u0026lt;/b\u0026gt; items in your basket, \u0026lt;em\u0026gt;${onSale}\u0026lt;/em\u0026gt; are on sale! `); }) test There are 5 items in your basket, 3 are on sale!\n非一般的简洁\n用反引号（\\）（键盘 ESC 下方）来标识起始，用${}（类似于 JavaEE 的 EL 表达式）来引用变量，而且所有的空格和缩进都会被保留在输出之中\n（6）destructing ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）\n// ES5 let cat = \u0026#34;tom\u0026#34;; let mouse = \u0026#34;terry\u0026#34;; let zoo = { cat: cat, mouse: mouse }; console.log(zoo); Object {cat: \u0026ldquo;tom\u0026rdquo;, mouse: \u0026ldquo;terry\u0026rdquo;}\n// ES6 let zoo2 = { cat, mouse }; console.log(zoo2); Object {cat: \u0026ldquo;tom\u0026rdquo;, mouse: \u0026ldquo;terry\u0026rdquo;}\nlet dog = { type: \u0026#34;animal\u0026#34;, num: 6 }; let { type, num } = dog; console.log(type, num); animal 6\n（7）default // ES5 function animal(type) { type = type || \u0026#34;cat\u0026#34;; console.log(type); } animal(); animal(\u0026#34;dog\u0026#34;); cat dog\n调用方法时若不加参数则使用默认值\n// ES6 function animal(type = \u0026#34;cat\u0026#34;) { console.log(type); } animal(); animal(\u0026#34;dog\u0026#34;); cat dog\n（8）rest // ES6 rest function animals(...types) { console.log(types); } animals(\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;fish\u0026#34;); [\u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;fish\u0026rdquo;]\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-es6-learning/","summary":"ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在2015 年发布的，所以又称 ECMAScript 2015。\n一、ES6 简介 ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在2015 年发布的，所以又称 ECMAScript 2015。\n即 ES6 === ES2015\n二、ES6 转码器 Babel是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。（chrome 已支持 ES6 解释，亲测可用）大家可以选择自己习惯的工具来使用使用 Babel，具体过程可直接在Babel 官网查看：\n三、常用特性 let / const（与传统 var 对比） class / extends / super（面向对象） arrow functions（箭头函数） template string（模板字符串） destructing（解构） default（默认值） rest / arguments（函数参数） 四、特性详解 （1）let 与 var 类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。\nvar name = \u0026#34;tom\u0026#34;; while (true) { var name = \u0026#34;bar\u0026#34;; console.","title":"ECMAScript6(ECMAScript2015)学习笔记"},{"content":"Java 基础算法（插入、选择、冒泡、快排）\n一、直接插入排序 1、原理 从待排序的数中选出一个来，插入到前面的合适位置。\n2、适用场景 基本有序的数据\n3、代码实现 static int data[] = {12, 6, 17, 108, 97, 93, 256, 1024}; public static void insertSort() { int tmp, i = 0; // 遍历数组 for(int j = 0; j\u0026lt;data.length; j++) { // 依次取出每个数放入tmp tmp = data[j]; // 将取出的数与之前面一个比较 i = j - 1; // 若小于前面一个数，则将前面一个数后移（覆盖取出来的这个数的位置） while(i \u0026gt;= 0 \u0026amp;\u0026amp; tmp \u0026lt; data[i]) { data[i+1] = data[i]; // 继续和再前面一个数比较 i--; } // 将取出的数插入 data[i+1] = tmp; System.out.println(); print(); } } 二、选择排序 1、原理 与直接插入排序正好相反，选择排序是从待排序的数中选出最小的放在已经排好的后面，这个算法选数耗时\n2、代码实现 static int data[] = {12, 6, 17, 108, 97, 93, 256, 1024}; public static void selectSort() { // i, j, k未初始化 int i, j, k, tmp = 0; // 遍历数组，从i开始的length-1个数 for(i=0; i\u0026lt;data.length-1; i++) { // 设置k的值和i一致 k = i; // 遍历数组，从i+1开始的length-1个数 for(j=i+1; j\u0026lt;data.length; j++) { // 如果后一个数比前面一个数小 if(data[j] \u0026lt; data[k]) { // 则把后一个数的坐标赋予k（保持k坐标的数为当前轮最小数） k = j; } } // 若发生后一个数比前一个数小的情况，则交换 if(k != i) { // 交换 tmp = data[i]; data[i] = data[k]; data[k] = tmp; System.out.println(); print(); } } } 三、冒泡排序 1、原理 小的数一点一点向前起泡，最终有序。\n2、代码实现 static int data[] = {12, 6, 17, 108, 97, 93, 256, 1024}; public static void bubbleSort() { int i, j, tmp = 0; // 遍历从i开始的length-1个数 for(i=0; i\u0026lt;data.length - 1; i++) { // 依次比较相邻两个数 for(j=data.length - 1; j\u0026gt;i; i--) { // 若后者小于前者，则换位 if(data[j] \u0026lt; data[j-1]) { tmp = data[j]; data[j] = data[j-1]; data[j-1] = tmp; } } } } 四、快速排序 1、原理 设置两个指针：i 和 j，分别指向第一个和最后一个，i 像后移动，j 向前移动，选第一个数为标准（一般这样做，当然快排的关键就是这个“标准”的选取），从后面开始，找到第一个比标准小的数，互换位置，然后再从前面，找到第一个比标准大的数，互换位置，第一趟的结果就是标准左边的都小于标准，右边的都大于标准（但不一定有序），分成两拨后，继续递归的使用上述方法，最终有序！\n2、适用场景 基本无序的数据\n3、代码实现 public static void quickSort(int data[], int start, int end) { int i, j; i = start; j = end; if((data == null) || (data.length == 0)) { return; } while(i \u0026lt; j) { // 以start下标的数据为key，从右向左依次扫描 while(i \u0026lt; j \u0026amp;\u0026amp; data[i] \u0026lt;= data[j]) { j--; } // 找出第一个比key小的，交换位置 if(i \u0026lt; j) { int temp = data[i]; data[i] = data[j]; data[j] = temp; } while(i \u0026lt; j \u0026amp;\u0026amp; data[i] \u0026lt; data[j]) { // 左侧扫描（此时a[j]存着key的值） i++; } // 找出第一个比key大的，交换位置 if(i \u0026lt; j) { int temp = data[i]; data[i] = data[j]; data[j] = temp; } } // 递归调用，把key前面的完成排序 if(i-start \u0026gt; 1) { quickSort(data, 0, i-1); } // 递归调用，把key后面的完成排序 if(end-j \u0026gt; 1) { quickSort(data, j+1, end); } } ","permalink":"https://barnett617.github.io/wilson-blog/notes/2016-12-15-java-basic-sort-algorithms/","summary":"Java 基础算法（插入、选择、冒泡、快排）\n一、直接插入排序 1、原理 从待排序的数中选出一个来，插入到前面的合适位置。\n2、适用场景 基本有序的数据\n3、代码实现 static int data[] = {12, 6, 17, 108, 97, 93, 256, 1024}; public static void insertSort() { int tmp, i = 0; // 遍历数组 for(int j = 0; j\u0026lt;data.length; j++) { // 依次取出每个数放入tmp tmp = data[j]; // 将取出的数与之前面一个比较 i = j - 1; // 若小于前面一个数，则将前面一个数后移（覆盖取出来的这个数的位置） while(i \u0026gt;= 0 \u0026amp;\u0026amp; tmp \u0026lt; data[i]) { data[i+1] = data[i]; // 继续和再前面一个数比较 i--; } // 将取出的数插入 data[i+1] = tmp; System.","title":"Java基础算法（插入、选择、冒泡、快排）"},{"content":"原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。\n一、原型模式（Prototype） /** * 原型类，实现可复制接口 * @author barnett * */ public class Prototype implements Cloneable { /** * 复制方法，调用父类的复制方法 */ public Object clone() throws CloneNotSupportedException { Prototype prototype = (Prototype) super.clone(); return prototype; } } 很简单，一个原型类，只需要实现Cloneable接口，覆写 clone 方法，此处 clone 方法可以改成任意的名称，因为 Cloneable 接口是个空接口，你可以任意定义实现类的方法名，如 cloneA 或者 cloneB。\n因为此处的重点是 super.clone()这句话，super.clone()调用的是 Object 的 clone()方法，而在 Object 类中，clone()是 native 的。\n二、深浅复制 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。\n深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。\npublic class PrototypeDeepAndThinClone implements Cloneable, Serializable { private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; // 浅复制 public Object clone() throws CloneNotSupportedException { Prototype prototype = (Prototype) super.clone(); return prototype; } // 深复制 public Object deepClone() throws IOException, ClassNotFoundException { // 写入当前对象的二进制流 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 读出二进制流产生的新对象 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); } public String getString() { return string; } public void setString(String string) { this.string = string; } public SerializableObject getObj() { return obj; } public void setObj(SerializableObject obj) { this.obj = obj; } } class SerializableObject implements Serializable { private static final long serialVersionUID = 1L; } 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-06/","summary":"原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。\n一、原型模式（Prototype） /** * 原型类，实现可复制接口 * @author barnett * */ public class Prototype implements Cloneable { /** * 复制方法，调用父类的复制方法 */ public Object clone() throws CloneNotSupportedException { Prototype prototype = (Prototype) super.clone(); return prototype; } } 很简单，一个原型类，只需要实现Cloneable接口，覆写 clone 方法，此处 clone 方法可以改成任意的名称，因为 Cloneable 接口是个空接口，你可以任意定义实现类的方法名，如 cloneA 或者 cloneB。\n因为此处的重点是 super.clone()这句话，super.clone()调用的是 Object 的 clone()方法，而在 Object 类中，clone()是 native 的。\n二、深浅复制 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。\n深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。\npublic class PrototypeDeepAndThinClone implements Cloneable, Serializable { private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; // 浅复制 public Object clone() throws CloneNotSupportedException { Prototype prototype = (Prototype) super.","title":"可复用面向对象软件基础——设计模式（六）之原型模式"},{"content":"工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的。\n代码实现 /** * 发送接口，有一个发送方法待实现 * @author barnett * */ public interface Sender { public void send(); } /** * 2、邮件发送类，实现发送接口，实现其发送方法，用以发送邮件 * @author barnett * */ public class MailSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am MailSender!\u0026#34;); } } /** * 短信发送类，实现了发送接口的发送方法，用以发送短信 * @author barnett * */ public class SmsSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am SmsSender!\u0026#34;); } } /** * 3、建造者类 * @author barnett * */ public class Builder { // 用以存储生产出的多个发送器 private List\u0026lt;Sender\u0026gt; list = new ArrayList\u0026lt;Sender\u0026gt;(); /** * 用于生产邮件发送器，当该方法被调用时会生产多个邮件发送器放入集合 * @param count\t生产个数 */ public void produceMailSender(int count) { for(int i=0; i\u0026lt;count; i++) { list.add(new MailSender()); } for(Sender sender : list) { sender.send(); } } public void produceSmsSender(int count)\t{ for(int i=0; i\u0026lt;count; i++) { list.add(new SmsSender()); } } } /** * 4、测试类 * @author barnett * */ public class Test { public static void main(String[] args) { // 实例化一个建造者 Builder builder = new Builder(); // 传入参数，委派建造者生产多个产品并放入集合 builder.produceMailSender(5); } } 与工厂模式对比 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象的多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-05/","summary":"工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的。\n代码实现 /** * 发送接口，有一个发送方法待实现 * @author barnett * */ public interface Sender { public void send(); } /** * 2、邮件发送类，实现发送接口，实现其发送方法，用以发送邮件 * @author barnett * */ public class MailSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am MailSender!\u0026#34;); } } /** * 短信发送类，实现了发送接口的发送方法，用以发送短信 * @author barnett * */ public class SmsSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am SmsSender!\u0026#34;); } } /** * 3、建造者类 * @author barnett * */ public class Builder { // 用以存储生产出的多个发送器 private List\u0026lt;Sender\u0026gt; list = new ArrayList\u0026lt;Sender\u0026gt;(); /** * 用于生产邮件发送器，当该方法被调用时会生产多个邮件发送器放入集合 * @param count\t生产个数 */ public void produceMailSender(int count) { for(int i=0; i\u0026lt;count; i++) { list.","title":"可复用面向对象软件基础——设计模式（五）之建造者模式"},{"content":"单例对象（Singleton）是一种常用的设计模式。在 Java 应用中，单例对象能保证在一个 JVM 中，该对象只有一个实例存在。\n单例模式优势 某些类创建繁琐，对于一些大型对象，系统开销大 省去 new 操作符，降低系统内存使用频率，减轻 GC 压力 保证某些核心类独立控制系统整个流程（控制其不可实例多个） 简版单例类 public class Singleton { // 持有私有静态实例，防止被引用，此处赋值为null，目的为实现延迟加载 private static Singleton instance = null; // 私有构造方法，防止被实例化 private Singleton() { } // 静态工厂方法 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } // 如果该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() { return instance; } } 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对 getInstance 方法加synchronized关键字，如下：\n// 静态工厂方法 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } 但是，synchronized 关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用 getInstance()，都要对对象上锁。\n// 静态工厂方法 public static Singleton getInstance() { if(instance == null) { synchronized (instance) { if(instance == null) { instance = new Singleton(); } } } return instance; } 似乎解决了之前提到的问题，将 synchronized 关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在 instance 为 null，并创建对象的时候才需要加锁，性能有一定的提升。\n但是，这样的情况，还是有可能有问题的，看下面的情况：在 Java 指令中创建对象和赋值操作是分开进行的，也就是说 instance = new Singleton();语句是分两步执行的。\n但是 JVM 并不保证这两个操作的先后顺序，也就是说有可能 JVM 会为新的 Singleton 实例分配空间，然后直接赋值给 instance 成员，然后再去初始化这个 Singleton 实例。这样就可能出错了。\n我们以 A、B 两个线程为例： 1\u0026gt;A、B 线程同时进入了第一个 if 判断 2\u0026gt;A 首先进入 synchronized 块，由于 instance 为 null，所以它执行 instance = new Singleton(); 3\u0026gt;由于 JVM 内部的优化机制，JVM 先画出了一些分配给 Singleton 实例的空白内存，并赋值给instance 成员（注意此时 JVM 没有开始初始化这个实例），然后 A 离开了 synchronized 块。 4\u0026gt;B 进入 synchronized 块，由于 instance 此时不是 null，因此它马上离开了 synchronized 块并将结果返回给调用该方法的程序。 5\u0026gt;此时 B 线程打算使用 Singleton 实例，却发现它没有被初始化，于是错误发生了。\n所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：\n内部类维护单例 实际情况是，单例模式使用内部类来维护单例的实现，JVM 内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。\n这样当我们第一次调用 getInstance 的时候，JVM 能够帮我们保证 instance 只被创建一次，并且会保证把赋值给 instance 的内存初始化完毕，这样我们就不用担心上面的问题。\n同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。\n其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。\n所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。\npublic class Singleton { // 私有构造方法，防止被实例化 private Singleton() { } // 使用内部类维护单例 private static class SingletonFactory { private static Singleton instance = new Singleton(); } // 获取实例 public static Singleton getInstance() { return SingletonFactory.instance; } // 若该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() { return getInstance(); } } 单独为创建加 Synchronized 也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和 getInstance()分开，单独为创建加 synchronized 关键字，也是可以的：\npublic class SingletonTest { private static SingletonTest instance = null; private SingletonTest() { } private static synchronized void syncInit() { if(instance == null) { instance = new SingletonTest(); } } public static SingletonTest getInstance() { if(instance == null) { syncInit(); } return instance; } } ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-04/","summary":"单例对象（Singleton）是一种常用的设计模式。在 Java 应用中，单例对象能保证在一个 JVM 中，该对象只有一个实例存在。\n单例模式优势 某些类创建繁琐，对于一些大型对象，系统开销大 省去 new 操作符，降低系统内存使用频率，减轻 GC 压力 保证某些核心类独立控制系统整个流程（控制其不可实例多个） 简版单例类 public class Singleton { // 持有私有静态实例，防止被引用，此处赋值为null，目的为实现延迟加载 private static Singleton instance = null; // 私有构造方法，防止被实例化 private Singleton() { } // 静态工厂方法 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } // 如果该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() { return instance; } } 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对 getInstance 方法加synchronized关键字，如下：\n// 静态工厂方法 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } 但是，synchronized 关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用 getInstance()，都要对对象上锁。","title":"可复用面向对象软件基础——设计模式（四）之单例模式"},{"content":"一、工厂方法模式缺陷 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须修改工厂类，这违背了设计模式六大原则第一条闭包原则。\n所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。\n二、抽象工厂模式实现 /** * 1、邮寄接口，有一个抽象邮寄方法待实现 * @author barnett * */ public interface Sender { public void send(); } /** * 2、实现类，邮件邮寄类实现邮寄接口，实现其邮寄的方法 * @author barnett * */ public class MailSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am MailSender!\u0026#34;); } } /** * 短信邮寄类实现邮寄接口，实现其邮寄方法 * @author barnett * */ public class SmsSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am SmsSender!\u0026#34;); } } /** * 3、提供器接口，返回邮寄对象，其生产方法待实现 * 工厂依靠实现该接口，生产产品（Sender） * @author barnett * */ public interface Provider { public Sender produce(); } /** * 4、工厂，邮件邮寄工厂，负责专门生产邮件邮寄实例 * @author barnett * */ public class SendMailFactory implements Provider { @Override public Sender produce() { return new MailSender(); } } /** * 短信邮寄工厂，专门生产短信邮寄实例 * @author barnett * */ public class SendSmsFactory implements Provider { @Override public Sender produce() { return new SmsSender(); } } /** * 5、测试类 * @author barnett * */ public class Test { public static void main(String[] args) { // 实例一个邮件工厂(因其实现了提供器接口，可返回一个具有专门生产某种产品生产方法的实例） Provider provider = new SendMailFactory(); // 通过该实例生产产品 Sender sender = provider.produce(); // 调用产品的方法 sender.send(); // 实例生产另一种产品的工厂 SendSmsFactory factory = new SendSmsFactory(); Sender sender2 = factory.produce(); sender2.send(); } } 三、抽象工厂模式优势 若想生产新的产品，只需一个实现类，实现 Sender 接口，再创建一个专门用于生产该产品的工厂类，实现 Provider 接口，这样一来，无需改动原有代码，拓展性好。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-03/","summary":"一、工厂方法模式缺陷 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须修改工厂类，这违背了设计模式六大原则第一条闭包原则。\n所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。\n二、抽象工厂模式实现 /** * 1、邮寄接口，有一个抽象邮寄方法待实现 * @author barnett * */ public interface Sender { public void send(); } /** * 2、实现类，邮件邮寄类实现邮寄接口，实现其邮寄的方法 * @author barnett * */ public class MailSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am MailSender!\u0026#34;); } } /** * 短信邮寄类实现邮寄接口，实现其邮寄方法 * @author barnett * */ public class SmsSender implements Sender { @Override public void send() { System.out.println(\u0026#34;I am SmsSender!\u0026#34;); } } /** * 3、提供器接口，返回邮寄对象，其生产方法待实现 * 工厂依靠实现该接口，生产产品（Sender） * @author barnett * */ public interface Provider { public Sender produce(); } /** * 4、工厂，邮件邮寄工厂，负责专门生产邮件邮寄实例 * @author barnett * */ public class SendMailFactory implements Provider { @Override public Sender produce() { return new MailSender(); } } /** * 短信邮寄工厂，专门生产短信邮寄实例 * @author barnett * */ public class SendSmsFactory implements Provider { @Override public Sender produce() { return new SmsSender(); } } /** * 5、测试类 * @author barnett * */ public class Test { public static void main(String[] args) { // 实例一个邮件工厂(因其实现了提供器接口，可返回一个具有专门生产某种产品生产方法的实例） Provider provider = new SendMailFactory(); // 通过该实例生产产品 Sender sender = provider.","title":"可复用面向对象软件基础——设计模式（三）之抽象工厂模式"},{"content":"一、工厂方法模式分类（3 种） 普通工厂模式 多个工厂方法模式 静态工厂方法模式 二、工厂方法模式详解 （1）普通工厂模式 普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。\n// 1、创建不同产品的共同接口 public interface Sender { /** * 邮寄接口中有一个邮寄方法待实现 */ public void Send(); } /** * 2、（实现类）邮件邮寄类实现了邮寄接口，实现其邮寄的抽象方法 * @author barnett */ public class MailSender implements Sender { @Override public void Send() { System.out.println(\u0026#34;I am MailSender!\u0026#34;); } } /** * 短信邮寄类实现了邮寄接口，实现其邮寄的抽象方法 * @author barnett * */ public class SmsSender implements Sender { @Override public void Send() { System.out.println(\u0026#34;I am SmsSender!\u0026#34;); } } /** * 3、工厂类，负责多次制造产品（new出复用的类） * @author barnett */ public class SendFactory { /** * 工厂类中的生产方法 * @param type\t输入要生产的产品类型 * @return\t返回一个产品 */ public Sender produce(String type) { if(\u0026#34;mail\u0026#34;.equals(type)) { return new MailSender(); } else if(\u0026#34;sms\u0026#34;.equals(type)) { return new SmsSender(); } else { System.out.println(\u0026#34;请输入正确的类型！\u0026#34;); return null; } } } /** * 4、测试类，实例一个工厂，生产多个产品 * @author barnett * */ public class FactoryTest { public static void main(String[] args) { // 创建一个工厂（可多次生产） SendFactory factory = new SendFactory(); // 使用工厂按照要求生产相应产品 Sender sender = factory.produce(\u0026#34;sms\u0026#34;); // 调用产品的方法 sender.Send(); Sender sender2 = factory.produce(\u0026#34;mail\u0026#34;); sender2.Send(); } } 工厂优势 1、 实例出一个工厂，再生产工厂内可以生产的产品，则只需要调用工厂的生产方法，通过传入不同的参数，生产不同的产品 2、传统方式则每次要生产一个产品时都需要实例化，然后调用生产方法 3、这样一来，要生产产品时，无需了解内部细节，交由工厂管理，节省资源\n（2）多个工厂方法模式 多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象\n而多个工厂方法模式是提供多个工厂方法，分别创建对象。\n/** * 工厂类，负责多次制造产品 * @author barnett * */ public class MultiMethodSendFactory { /** * 专门生产邮件邮寄器的方法 * @return */ public Sender produceMail() { return new MailSender(); } /** * 专门生产短信邮寄器的方法 * @return */ public Sender produceSms() { return new SmsSender(); } } /** * 测试类，实例一个工厂，生产多个产品 * @author barnett * */ public class MultiMethodFactoryTest { public static void main(String[] args) { // 创建一个工厂（可多次生产） MultiMethodSendFactory factory = new MultiMethodSendFactory(); // 根据不同的需求调用不同的方法 Sender mailSender = factory.produceMail(); mailSender.Send(); Sender smsSender = factory.produceSms(); smsSender.Send(); } } （3）静态工厂方法模式 将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。\n/** * 工厂类，负责多次制造产品 * @author barnett */ public class StaticMethodSendFactory { /** * 专门生产邮件邮寄器的方法 * @return */ public static Sender produceMail() { return new MailSender(); } /** * 专门生产短信邮寄器的方法 * @return */ public static Sender produceSms() { return new SmsSender(); } } /** * 测试类，直接调用工厂中的静态方法，生产产品 * @author barnett */ public class StaticMethodFactoryTest { public static void main(String[] args) { Sender mailSender = StaticMethodSendFactory.produceMail(); mailSender.Send(); Sender smsSender = StaticMethodSendFactory.produceSms(); smsSender.Send(); } } ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-02/","summary":"一、工厂方法模式分类（3 种） 普通工厂模式 多个工厂方法模式 静态工厂方法模式 二、工厂方法模式详解 （1）普通工厂模式 普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。\n// 1、创建不同产品的共同接口 public interface Sender { /** * 邮寄接口中有一个邮寄方法待实现 */ public void Send(); } /** * 2、（实现类）邮件邮寄类实现了邮寄接口，实现其邮寄的抽象方法 * @author barnett */ public class MailSender implements Sender { @Override public void Send() { System.out.println(\u0026#34;I am MailSender!\u0026#34;); } } /** * 短信邮寄类实现了邮寄接口，实现其邮寄的抽象方法 * @author barnett * */ public class SmsSender implements Sender { @Override public void Send() { System.out.println(\u0026#34;I am SmsSender!\u0026#34;); } } /** * 3、工厂类，负责多次制造产品（new出复用的类） * @author barnett */ public class SendFactory { /** * 工厂类中的生产方法 * @param type\t输入要生产的产品类型 * @return\t返回一个产品 */ public Sender produce(String type) { if(\u0026#34;mail\u0026#34;.","title":"可复用面向对象软件基础——设计模式（二）之工厂方法模式"},{"content":"一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类\n（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。\nLSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。\n（3）依赖倒转原则 这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n（4）接口隔离原则 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思。\n从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。\n（5）迪米特法则（最少知道原则） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。\n（6）合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承。\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-12-15-design-pattern-01/","summary":"一、设计模式特点 反复使用 分类编目 经验总结 二、设计模式宗旨 代码重用 使代码易于理解 保证代码可靠性 三、设计模式分类（23+2） 创建型（5 种） 结构型（7 种） 行为型（11 种） 其他（2 种） （1）创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 （2）结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 （3）行为型模式 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 （4）其他 并发型模式 线程池模式 四、设计模式原则（6 项） 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 五、原则详解 （1）开闭原则 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。目的在于使程序的扩展性好，易于维护和升级。所以需要使用到接口和抽象类\n（2）里氏代换原则 里氏代换原则（LSP）是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。","title":"可复用面向对象软件基础——设计模式（一）之总览"},{"content":"摘要 本系统为本人学习 SSH 三大框架时所做的整合实例，系统角色包括普通用户和管理员两种，首页有管理员登录入口链接。系统功能主要包括管理员对用户的基本增、删、改、查和分页显示用户信息等。\n系统环境 本系统使用 eclipse+mysql+jdk1.8+tomcat8 进行开发 框架使用 struts2+hibernate3+spring3 页面展示 首页一开始没考虑屏幕分辨率和比例问题以及浏览器的兼容问题，后该用 bootstrap 简单模板，达到兼容旧版 IE 浏览器效果，并且为响应式布局，屏幕可任意缩放。 注册页面采用 angularJS 前端框架实现客户端表单验证 日期使用jedate.js控件 注册成功提示（后台为新注册用户分配三个随机邀请码用于邀请其他用户注册本系统） 个人主页使用 easyui 框架 管理员首页（可分页显示用户） 添加用户 核心代码解析 1、随机邀请码生成 使用 UUID 并将其切片，取前八位作为验证码（本算法尚不成熟，在大量使用后可能出现重复）\npublic static String[] codeMaker() { String[] code = new String[3]; for (int i=0; i\u0026lt;3; i++) { code[i] = UUID.randomUUID().toString().substring(0,8).toUpperCase(); } return code; } 2、登录验证 action 层 public String login() { User existUser = userService.login(user); if (existUser == null) { this.addActionError(\u0026#34;用户名或密码错误\u0026#34;); return INPUT; } else { ActionContext.getContext().getSession().put(\u0026#34;currUser\u0026#34;, existUser); return SUCCESS; } } service 层 拿到从表单提交并封装到实体的 user 对象，将其作为参数传递给数据库，调用 dao 层函数，核对相应用户名和密码是否存在并一致 @Override /** * 业务层登陆的方法 */ public User login(User user) { User existUser = userDao.findByUsernameAndPassword(user); return existUser; } dao 层 使用 hibernate 模板方法查询相应对象，若查到则返回对象，用于 action 层作处理 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override /** * dao中根据用户名和密码查询用户的方法 */ public User findByUsernameAndPassword(User user) { String hql = \u0026#34;from User where username = ? and password = ?\u0026#34;; List\u0026lt;User\u0026gt; list = this.getHibernateTemplate().find(hql, user.getUsername(), user.getPassword()); if (list.size() \u0026gt; 0) { return list.get(0); } return null; } view 层 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cc\u0026#34; class=\u0026#34;easyui-layout\u0026#34; fit=\u0026#34;true\u0026#34; style=\u0026#34;width:100%;height:100%;\u0026#34;\u0026gt; \u0026lt;div region=\u0026#34;west\u0026#34; split=\u0026#34;true\u0026#34; title=\u0026#34;菜单\u0026#34; style=\u0026#34;width:200px;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aa\u0026#34; class=\u0026#34;easyui-accordion\u0026#34; fit=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;div title=\u0026#34;功能导航\u0026#34; selected=\u0026#34;true\u0026#34; style=\u0026#34;overflow:auto;padding:10px;\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;tab\u0026#34; style=\u0026#34;border: 1px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;user_info\u0026#34;\u0026gt;个人信息\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tab\u0026#34; style=\u0026#34;border: 1px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;user_invite\u0026#34;\u0026gt;已邀请人的信息\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tab\u0026#34; style=\u0026#34;border: 1px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;user_code\u0026#34;\u0026gt;邀请码信息\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div region=\u0026#34;center\u0026#34; title=\u0026#34;主界面\u0026#34; style=\u0026#34;padding:5px;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;welcome\u0026#34; class=\u0026#34;tab\u0026#34;\u0026gt; \u0026lt;span\u0026gt;欢迎你，${currUser.name }\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; \u0026lt;a href=\u0026#34;${ctx }/index.jsp\u0026#34;\u0026gt;退出系统\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;tt\u0026#34; class=\u0026#34;easyui-tabs\u0026#34; fit=\u0026#34;true\u0026#34; style=\u0026#34;width:500px;height:250px;\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 3、分页显示 action 层 public String findAll() { PageBean\u0026lt;User\u0026gt; pageBean = adminService.findAll(currPage); List\u0026lt;User\u0026gt; list = pageBean.getList(); ActionContext.getContext().getValueStack().push(pageBean); ActionContext.getContext().getSession().put(\u0026#34;users\u0026#34;, list); return \u0026#34;findAll\u0026#34;; } 实体层 private int currPage;\t//当前页 private int pageSize;\t//每页显示记录数 private int totalCount;\t//总记录 private int totalPage;\t//总页数 private List\u0026lt;T\u0026gt; list;\t//封装实体 业务层 // 分页查询所有用户 @Override public PageBean\u0026lt;User\u0026gt; findAll(int currPage) { PageBean\u0026lt;User\u0026gt; pageBean = new PageBean\u0026lt;User\u0026gt;(); // 封装pageBean pageBean.setCurrPage(currPage);\t// 当前页数 int pageSize = 10; pageBean.setPageSize(pageSize);\t// 每页记录数 int totalCount = adminDao.findCount(); pageBean.setTotalCount(totalCount);\t// 总记录数 double tc = totalCount;\t// 总页数 Double num = Math.ceil(tc / pageSize); pageBean.setTotalPage(num.intValue()); int begin = (currPage - 1) * pageSize;\t// 每页开始的记录索引 List\u0026lt;User\u0026gt; list = adminDao.findByPage(begin,pageSize);\t// list用来封装用户集合 pageBean.setList(list); return pageBean; } dao 层 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override public List\u0026lt;User\u0026gt; findAll() { String hql = \u0026#34;select * from User where uid != 1\u0026#34;; List\u0026lt;User\u0026gt; list = this.getHibernateTemplate().find(hql); if (list.size() \u0026gt; 0) { return list; } return null; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override public int findCount() { String hql = \u0026#34;select count(*) from User\u0026#34;; List\u0026lt;Long\u0026gt; list = this.getHibernateTemplate().find(hql); if(list.size() \u0026gt; 0) { return list.get(0).intValue(); } return 0; } /** * 分页函数 */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override public List\u0026lt;User\u0026gt; findByPage(int begin, int pageSize) { DetachedCriteria criteria = DetachedCriteria.forClass(User.class); List\u0026lt;User\u0026gt; list = this.getHibernateTemplate().findByCriteria(criteria, begin, pageSize); return list; } view 层 \u0026lt;div id=\u0026#34;page\u0026#34; align=\u0026#34;left\u0026#34; class=\u0026#34;font\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;0\u0026#34; cellspacing=\u0026#34;0\u0026#34; cellpadding=\u0026#34;0\u0026#34; width=\u0026#34;500px\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;span\u0026gt;第\u0026lt;s:property value=\u0026#34;currPage\u0026#34; /\u0026gt;/\u0026lt;s:property value=\u0026#34;totalPage\u0026#34; /\u0026gt;页\u0026lt;/span\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;span\u0026gt; 总记录数：\u0026lt;s:property value=\u0026#34;totalCount\u0026#34; /\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; 每页显示：\u0026lt;s:property value=\u0026#34;pageSize\u0026#34; /\u0026gt; \u0026lt;/span\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;span\u0026gt; \u0026lt;s:if test=\u0026#34;currPage != 1\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${ctx }/admin_findAll?currPage=1\u0026#34;\u0026gt;[首页]\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;a href=\u0026#34;${ctx }/admin_findAll?currPage=\u0026lt;s:property value=\u0026#34;currPage-1\u0026#34;/\u0026gt;\u0026#34;\u0026gt;[上一页]\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/s:if\u0026gt; \u0026lt;s:if test=\u0026#34;currPage != totalPage\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${ctx }/admin_findAll?currPage=\u0026lt;s:property value=\u0026#34;currPage+1\u0026#34;/\u0026gt;\u0026#34;\u0026gt;[下一页]\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;a href=\u0026#34;${ctx }/admin_findAll?currPage=\u0026lt;s:property value=\u0026#34;totalPage\u0026#34;/\u0026gt;\u0026#34;\u0026gt;[尾页]\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/s:if\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-11-02-ssh-web-05/","summary":"摘要 本系统为本人学习 SSH 三大框架时所做的整合实例，系统角色包括普通用户和管理员两种，首页有管理员登录入口链接。系统功能主要包括管理员对用户的基本增、删、改、查和分页显示用户信息等。\n系统环境 本系统使用 eclipse+mysql+jdk1.8+tomcat8 进行开发 框架使用 struts2+hibernate3+spring3 页面展示 首页一开始没考虑屏幕分辨率和比例问题以及浏览器的兼容问题，后该用 bootstrap 简单模板，达到兼容旧版 IE 浏览器效果，并且为响应式布局，屏幕可任意缩放。 注册页面采用 angularJS 前端框架实现客户端表单验证 日期使用jedate.js控件 注册成功提示（后台为新注册用户分配三个随机邀请码用于邀请其他用户注册本系统） 个人主页使用 easyui 框架 管理员首页（可分页显示用户） 添加用户 核心代码解析 1、随机邀请码生成 使用 UUID 并将其切片，取前八位作为验证码（本算法尚不成熟，在大量使用后可能出现重复）\npublic static String[] codeMaker() { String[] code = new String[3]; for (int i=0; i\u0026lt;3; i++) { code[i] = UUID.randomUUID().toString().substring(0,8).toUpperCase(); } return code; } 2、登录验证 action 层 public String login() { User existUser = userService.login(user); if (existUser == null) { this.","title":"基于SSH三大框架的员工管理系统"},{"content":"flowchat st=\u0026gt;start: localhost:8080/项目名 e=\u0026gt;end: 访问结束 fir=\u0026gt;: web.xml op=\u0026gt;operation: 我的操作 cond=\u0026gt;condition: 确认？ st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;op ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-11-02-ssh-web-04/","summary":"flowchat st=\u0026gt;start: localhost:8080/项目名 e=\u0026gt;end: 访问结束 fir=\u0026gt;: web.xml op=\u0026gt;operation: 我的操作 cond=\u0026gt;condition: 确认？ st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;op ","title":"基于SSH的员工管理系统（四）——项目流程"},{"content":"1. Web 项目入口——web.xml \u0026lt;!-- spring核心监听器 --\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;!-- ctrl+shift+T:contextLoaderListener监听器全路径 --\u0026gt; \u0026lt;!-- 默认情况会加载WEB-INF中的配置文件 --\u0026gt; \u0026lt;!-- 配置全局初始化参数：设置为加载classes中的配置文件 --\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;!-- struts核心过滤器（与传统servlet配置类似） --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;!-- ctrl+shift+T:strutsPrepareAndExecuteFilter --\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;display-name\u0026gt;ssh\u0026lt;/display-name\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; 2. struts 配置文件——struts.xml \u0026lt;struts\u0026gt; \u0026lt;package name=\u0026#34;ssh\u0026#34; extends=\u0026#34;struts-default\u0026#34;\u0026gt; \u0026lt;action name=\u0026#34;user_*\u0026#34; class=\u0026#34;userAction\u0026#34; method=\u0026#34;{1}\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;input\u0026#34;\u0026gt;/index.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;success\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/jsp/layout.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;info\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/jsp/myinfo.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;invi\u0026#34;\u0026gt;/jsp/invi.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;regSuccess\u0026#34;\u0026gt;/jsp/regSuccess1.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;getCodes\u0026#34;\u0026gt;/jsp/mycode.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;toHome\u0026#34;\u0026gt;/jsp/layout.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;linkPersion\u0026#34;\u0026gt;/jsp/otherInfo.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;update\u0026#34;\u0026gt;/jsp/updateUser.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;updateSucc\u0026#34; type=\u0026#34;redirectAction\u0026#34;\u0026gt;admin_findAll\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;del\u0026#34; type=\u0026#34;redirectAction\u0026#34;\u0026gt;admin_findAll\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;add\u0026#34;\u0026gt;/jsp/addUser.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;addSucc\u0026#34; type=\u0026#34;redirectAction\u0026#34;\u0026gt;admin_findAll\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;action name=\u0026#34;admin_*\u0026#34; class=\u0026#34;adminAction\u0026#34; method=\u0026#34;{1}\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;input\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/index.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;findAll\u0026#34;\u0026gt;/jsp/adminHome.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;success\u0026#34;\u0026gt;/jsp/adminHome.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;action name=\u0026#34;group_*\u0026#34; class=\u0026#34;groupAction\u0026#34; method=\u0026#34;{1}\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;findGroup\u0026#34;\u0026gt;/jsp/groupList.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;addSucc\u0026#34;\u0026gt;/jsp/groupList.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;add\u0026#34;\u0026gt;/jsp/addList.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;action name=\u0026#34;registerPre\u0026#34; class=\u0026#34;registerPreAction\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;success\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/jsp/register.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt; \u0026lt;/struts\u0026gt; 3. hibernate 配置文件（在 ssh 整合中该配置文件可省略） 4. hibernate 映射文件——User.hbm.xml（与实体属性名称相对应，在启动服务器后会自动生成表） User(用户实体)\n\u0026lt;hibernate-mapping\u0026gt; \u0026lt;class name=\u0026#34;com.barrnet.ssh.domain.User\u0026#34; table=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;id name=\u0026#34;uid\u0026#34; column=\u0026#34;uid\u0026#34;\u0026gt; \u0026lt;generator class=\u0026#34;native\u0026#34; /\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;property name=\u0026#34;selfCode\u0026#34; column=\u0026#34;selfCode\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; column=\u0026#34;username\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; column=\u0026#34;password\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34; length=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;phone\u0026#34; column=\u0026#34;phone\u0026#34; length=\u0026#34;13\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;idCard\u0026#34; column=\u0026#34;idCard\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;birthday\u0026#34; type=\u0026#34;date\u0026#34; column=\u0026#34;birthday\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;joinDate\u0026#34; type=\u0026#34;date\u0026#34; column=\u0026#34;joinDate\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;fcode1\u0026#34; column=\u0026#34;fcode1\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;fcode2\u0026#34; column=\u0026#34;fcode2\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;fcode3\u0026#34; column=\u0026#34;fcode3\u0026#34; length=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;islead\u0026#34; column=\u0026#34;islead\u0026#34; length=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;groupnum\u0026#34; column=\u0026#34;groupnum\u0026#34; length=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;floornum\u0026#34; column=\u0026#34;floornum\u0026#34; length=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;many-to-one name=\u0026#34;group\u0026#34; class=\u0026#34;com.barrnet.ssh.domain.Group\u0026#34; column=\u0026#34;fgid\u0026#34; /\u0026gt; \u0026lt;/class\u0026gt; \u0026lt;/hibernate-mapping\u0026gt; 实体属性\nprivate int uid;\t//唯一标识 private String selfCode;\t//注册码 private String username;\t//登陆用户名 private String password;\t//登陆密码 private String name;\t//真实姓名 private String sex;\t//性别 private String phone;\t//手机号 private String idCard;\t//身份证号 private Date birthday;\t//出生日期 private Date joinDate;\t//注册时间 private String fcode1;\t//邀请码1 private String fcode2;\t//邀请码2 private String fcode3;\t//邀请码3 private String islead;\t//是否组长 private String groupnum;\t//组号 private String floornum;\t//层号 private Group group; 生成表\nAdmin(管理员实体)\n\u0026lt;hibernate-mapping\u0026gt; \u0026lt;class name=\u0026#34;com.barrnet.ssh.domain.Group\u0026#34; table=\u0026#34;ggroup\u0026#34;\u0026gt; \u0026lt;id name=\u0026#34;gid\u0026#34; column=\u0026#34;gid\u0026#34;\u0026gt; \u0026lt;generator class=\u0026#34;native\u0026#34;/\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;property name=\u0026#34;gno\u0026#34; column=\u0026#34;gno\u0026#34; length=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gcount\u0026#34; column=\u0026#34;gcount\u0026#34; length=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;set name=\u0026#34;users\u0026#34;\u0026gt; \u0026lt;key column=\u0026#34;fgid\u0026#34;/\u0026gt; \u0026lt;one-to-many class=\u0026#34;com.barrnet.ssh.domain.User\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/class\u0026gt; \u0026lt;/hibernate-mapping\u0026gt; 实体属性\nprivate int aid;\t//唯一标识 private String username;\t//登陆用户名 private String password;\t//登陆密码 private String level;\t//管理员等级（用以区分普通管理员和超级管理员） 生成表\n5. spring 配置文件——application.context.xml(启动服务器时加载 spring 核心配置文件) \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; \u0026lt;!-- 引入外部属性文件 --\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34; /\u0026gt; \u0026lt;!-- 配置c3p0连接池 --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driverClass}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置hibernate --\u0026gt; \u0026lt;bean id=\u0026#34;sessionFactory\u0026#34; class=\u0026#34;org.springframework.orm.hibernate3.LocalSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;!-- 注入连接池 --\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;!-- 配置hibernate属性 --\u0026gt; \u0026lt;property name=\u0026#34;hibernateProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.dialect\u0026#34;\u0026gt;org.hibernate.dialect.MySQLDialect\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.show_sql\u0026#34;\u0026gt;true\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.format_sql\u0026#34;\u0026gt;true\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt;update\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- 加载hibernate映射文件 --\u0026gt; \u0026lt;property name=\u0026#34;mappingResources\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;com/barrnet/ssh/domain/User.hbm.xml\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;com/barrnet/ssh/domain/Admin.hbm.xml\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;com/barrnet/ssh/domain/Group.hbm.xml\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置Action的类 --\u0026gt; \u0026lt;bean id=\u0026#34;userAction\u0026#34; class=\u0026#34;com.barrnet.ssh.action.UserAction\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userService\u0026#34; ref=\u0026#34;userService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;adminAction\u0026#34; class=\u0026#34;com.barrnet.ssh.action.AdminAction\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminService\u0026#34; ref=\u0026#34;adminService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;groupAction\u0026#34; class=\u0026#34;com.barrnet.ssh.action.GroupAction\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;groupService\u0026#34; ref=\u0026#34;groupService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;registerPreAction\u0026#34; class=\u0026#34;com.barrnet.ssh.action.RegisterPreAction\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置业务层的类 --\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.barrnet.ssh.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;adminService\u0026#34; class=\u0026#34;com.barrnet.ssh.service.impl.AdminServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminDao\u0026#34; ref=\u0026#34;adminDao\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;groupService\u0026#34; class=\u0026#34;com.barrnet.ssh.service.impl.GroupServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;groupDao\u0026#34; ref=\u0026#34;groupDao\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置dao的类 --\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.barrnet.ssh.dao.impl.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;adminDao\u0026#34; class=\u0026#34;com.barrnet.ssh.dao.impl.AdminDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;groupDao\u0026#34; class=\u0026#34;com.barrnet.ssh.dao.impl.GroupDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置事务管理 --\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.orm.hibernate3.HibernateTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 开启注解事务 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-11-02-ssh-web-03/","summary":"1. Web 项目入口——web.xml \u0026lt;!-- spring核心监听器 --\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;!-- ctrl+shift+T:contextLoaderListener监听器全路径 --\u0026gt; \u0026lt;!-- 默认情况会加载WEB-INF中的配置文件 --\u0026gt; \u0026lt;!-- 配置全局初始化参数：设置为加载classes中的配置文件 --\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;!-- struts核心过滤器（与传统servlet配置类似） --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;!-- ctrl+shift+T:strutsPrepareAndExecuteFilter --\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;display-name\u0026gt;ssh\u0026lt;/display-name\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; 2. struts 配置文件——struts.xml \u0026lt;struts\u0026gt; \u0026lt;package name=\u0026#34;ssh\u0026#34; extends=\u0026#34;struts-default\u0026#34;\u0026gt; \u0026lt;action name=\u0026#34;user_*\u0026#34; class=\u0026#34;userAction\u0026#34; method=\u0026#34;{1}\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;input\u0026#34;\u0026gt;/index.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;success\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/jsp/layout.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;info\u0026#34; type=\u0026#34;redirect\u0026#34;\u0026gt;/jsp/myinfo.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;invi\u0026#34;\u0026gt;/jsp/invi.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;regSuccess\u0026#34;\u0026gt;/jsp/regSuccess1.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;getCodes\u0026#34;\u0026gt;/jsp/mycode.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;toHome\u0026#34;\u0026gt;/jsp/layout.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;linkPersion\u0026#34;\u0026gt;/jsp/otherInfo.jsp\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026#34;update\u0026#34;\u0026gt;/jsp/updateUser.","title":"基于SSH的员工管理系统（三）——配置文件"},{"content":"本节将关于本项目所需导入的 jar 包进行逐一解释，基本适用于普通的 Struts2+Hibernate3+Spring3 的项目， 此为相对较老的组合版本，若使用 Hibernate4 或 Mybatis 等其他较新框架，请自行查阅相关资料。\n1、struts2 基础必备包（解压 blank.war 可得） 本项目使用 struts2.3.4.1 附加 Jar 解释：\nstruts2-convention-plugin-2.3.4.1.jar——支持 struts2 的注解开发 struts2-spring-plugin-2.3.4.1.jar——用于整合 spring 2、hibernate3 基础必备包 本项目使用 hibernate3.3.1 根路径 hibernate3.jar——核心 jar 包 required 目录所有 jar 包 hibernate 日志记录——slf4j-log4j.jar 数据库驱动包——mysql-connector-java.jar（本项目使用 mysql 数据库） 3、spring 基础必备包 本项目使用 spring3.2.2 spring 基本 jar 包包括\nIoC 开发 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar com.springsource.org.apache.log4j.jar——作日志记录 com.springsource.org.apache.commons.logging.jar——日志整合，不作具体日志记录，用于整合其他日志系统 AOP spring-aop.jar spring-aspect.jar——整合 aspect com.spinrgsource.org.aopalliance.jar——aop 联盟 com.springsource.org.aspectj.weaver.jar 其他 spring-tx.jar——事务管理 spring-jdbc.jar——jdbc 模板 spring-orm.jar——整合 hibernate spring-web.jar——整合 web 项目 spring-test.jar——整合 JUnit 单元测试 c3p0.jar——c3p0 连接池 在实际开发中，一开始的 jar 包导入环节总是没有清晰的头绪，原因就在于实际开发经验不足，对框架理解不够，此处就体现出阅读框架源码的重要性。\n“框架官网文档就是学习框架的最好资料” 与君共勉\nstruts 官方文档 hibernate 官方文档 spring 官方文档 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-11-02-ssh-web-02/","summary":"本节将关于本项目所需导入的 jar 包进行逐一解释，基本适用于普通的 Struts2+Hibernate3+Spring3 的项目， 此为相对较老的组合版本，若使用 Hibernate4 或 Mybatis 等其他较新框架，请自行查阅相关资料。\n1、struts2 基础必备包（解压 blank.war 可得） 本项目使用 struts2.3.4.1 附加 Jar 解释：\nstruts2-convention-plugin-2.3.4.1.jar——支持 struts2 的注解开发 struts2-spring-plugin-2.3.4.1.jar——用于整合 spring 2、hibernate3 基础必备包 本项目使用 hibernate3.3.1 根路径 hibernate3.jar——核心 jar 包 required 目录所有 jar 包 hibernate 日志记录——slf4j-log4j.jar 数据库驱动包——mysql-connector-java.jar（本项目使用 mysql 数据库） 3、spring 基础必备包 本项目使用 spring3.2.2 spring 基本 jar 包包括\nIoC 开发 spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar com.springsource.org.apache.log4j.jar——作日志记录 com.springsource.org.apache.commons.logging.jar——日志整合，不作具体日志记录，用于整合其他日志系统 AOP spring-aop.jar spring-aspect.jar——整合 aspect com.spinrgsource.org.aopalliance.jar——aop 联盟 com.springsource.org.aspectj.weaver.jar 其他 spring-tx.jar——事务管理 spring-jdbc.jar——jdbc 模板 spring-orm.jar——整合 hibernate spring-web.","title":"基于SSH的员工管理系统（二）——lib 导入各 jar 包详解"},{"content":"本项目是使用 Struts2+Hibernate3+Spring3,基于 MVC 开发模式的一个简单实例，第一篇先建立项目总体包结构，后续将详细解释项目细节。\n1、整体包结构 2、action 包 3、domain 实体包 4、service 层 5、dao 层 6、util 工具包 7、页面层 ","permalink":"https://barnett617.github.io/wilson-blog/posts/2016-11-02-ssh-web-01/","summary":"本项目是使用 Struts2+Hibernate3+Spring3,基于 MVC 开发模式的一个简单实例，第一篇先建立项目总体包结构，后续将详细解释项目细节。\n1、整体包结构 2、action 包 3、domain 实体包 4、service 层 5、dao 层 6、util 工具包 7、页面层 ","title":"基于SSH的员工管理系统（一）——包结构"},{"content":"（一）AWT（abstract window toolkit，抽象窗口工具包）\n特点：\n（1）重量级控件\n（2）利用操作系统所提供的图形库\n（3）简单、高效\n（4）运行速度快\n（5）基于系统（调用系统 UI）\n（6）消耗资源\n（7）难以跨平台\n功能：\n（1）Canvas 组件：画布，可实现动画操作\n（2）TextArea:文本域\n（3）单行文本域中回车会激发 ActionEvent\n（4）CheckBoxGroup 实现单选框\n（5）单元框和复选框都使用 CheckBox 实现\n（6）菜单：new MenuBar()，MenuBar 表示菜单条，菜单每一项为 MenuItem(一般级联菜单不应超过 3 级)\n应用：嵌入式应用\n目标平台的硬件资源非常有限，同时应用程序运行速度是项目中至关重要的因素\n（二）swing:\n特点：\n（1）轻量级控件\n（2）100%JAVA 代码实现（Swing 为 JAVA 自身组件）\n（3）与底层系统无关\n（4）基于 AWT\n（5）运行速度慢\n应用：基于 PC 或工作站的标准 Java 应用\n硬件资源对应用程序所造成的限制往往不是项目中的关键因素，通过牺牲速度来实现应用程序的功能\n（三）SWT:\n特点：\n（1）未通过 JAVA 虚拟机操作，直接调用 Windows GDI 和 Shell（通过 JNI 方法调用完成）\n（2）基于 SWT 实现的 Eclipse 界面速度快、效率高，比 Swing 美观\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2015-12-23-java-ui/","summary":"（一）AWT（abstract window toolkit，抽象窗口工具包）\n特点：\n（1）重量级控件\n（2）利用操作系统所提供的图形库\n（3）简单、高效\n（4）运行速度快\n（5）基于系统（调用系统 UI）\n（6）消耗资源\n（7）难以跨平台\n功能：\n（1）Canvas 组件：画布，可实现动画操作\n（2）TextArea:文本域\n（3）单行文本域中回车会激发 ActionEvent\n（4）CheckBoxGroup 实现单选框\n（5）单元框和复选框都使用 CheckBox 实现\n（6）菜单：new MenuBar()，MenuBar 表示菜单条，菜单每一项为 MenuItem(一般级联菜单不应超过 3 级)\n应用：嵌入式应用\n目标平台的硬件资源非常有限，同时应用程序运行速度是项目中至关重要的因素\n（二）swing:\n特点：\n（1）轻量级控件\n（2）100%JAVA 代码实现（Swing 为 JAVA 自身组件）\n（3）与底层系统无关\n（4）基于 AWT\n（5）运行速度慢\n应用：基于 PC 或工作站的标准 Java 应用\n硬件资源对应用程序所造成的限制往往不是项目中的关键因素，通过牺牲速度来实现应用程序的功能\n（三）SWT:\n特点：\n（1）未通过 JAVA 虚拟机操作，直接调用 Windows GDI 和 Shell（通过 JNI 方法调用完成）\n（2）基于 SWT 实现的 Eclipse 界面速度快、效率高，比 Swing 美观","title":"三大GUI库——AWT、swing、SWT"},{"content":"override(覆盖)=重写\n对象：方法\n解释：重写一个方法，以实现不同的功能\n用于：子类继承父类的方法，重写（重现实现=继承+写新方法）父类的方法\n规则：\n1、参数列表相同，否则为重载而非重写\n2、访问修饰符大于被重写方法（public \u0026gt; protected \u0026gt; default \u0026gt; private）\n3、返回值（与被重写方法）相同\n4、所抛异常（与被重写方法）相同\n5、被重写方法不能为 private，否则在其子类中只是新定义了一个方法，并未对其进行重写\n6、静态方法不能被重写为非静态方法（否则编译出错）\noverload(重载)\n解释：在一个类内实现若干重载方法，方法名相同而参数形式不同\n参数形式不同包括：\n1、参数类型不同\n2、参数个数不同\n3、参数顺序不同（参数类型不同的同时）\n用于：在一个类内实现若干同名方法\n规则：\n1、使用重载只能 通过相同方法名和不同的参数形式实现\n2、不能通过访问权限、返回类型、抛出的异常进行重载\n3、方法的异常类型和数目不会对重载造成影响\n","permalink":"https://barnett617.github.io/wilson-blog/posts/2015-12-23-override-vs-overload/","summary":"override(覆盖)=重写\n对象：方法\n解释：重写一个方法，以实现不同的功能\n用于：子类继承父类的方法，重写（重现实现=继承+写新方法）父类的方法\n规则：\n1、参数列表相同，否则为重载而非重写\n2、访问修饰符大于被重写方法（public \u0026gt; protected \u0026gt; default \u0026gt; private）\n3、返回值（与被重写方法）相同\n4、所抛异常（与被重写方法）相同\n5、被重写方法不能为 private，否则在其子类中只是新定义了一个方法，并未对其进行重写\n6、静态方法不能被重写为非静态方法（否则编译出错）\noverload(重载)\n解释：在一个类内实现若干重载方法，方法名相同而参数形式不同\n参数形式不同包括：\n1、参数类型不同\n2、参数个数不同\n3、参数顺序不同（参数类型不同的同时）\n用于：在一个类内实现若干同名方法\n规则：\n1、使用重载只能 通过相同方法名和不同的参数形式实现\n2、不能通过访问权限、返回类型、抛出的异常进行重载\n3、方法的异常类型和数目不会对重载造成影响","title":"重写与重载的区别"},{"content":"","permalink":"https://barnett617.github.io/wilson-blog/tags/","summary":"","title":"按标签分类"},{"content":"前滴滴前端工程师，目前在 MG 负责核心模块维护及架构升级。\n技术栈 Vue.js TypeScript Webpack 负责过 基于 Web Vitals 的首帧加载及使用卡顿优化（包括资源体积、数量和加载时序等优化） 基于 eslint-plugin-import 的模块循环依赖治理 状态管理库迁移 Vuex -\u0026gt; Pinia 组件范式迁移 vue class component -\u0026gt; composition api 基于 Sentry 的线上报错监控及治理 人生哲学 追求内心的宁静、自洽，更加笃定\n","permalink":"https://barnett617.github.io/wilson-blog/about/","summary":"前滴滴前端工程师，目前在 MG 负责核心模块维护及架构升级。\n技术栈 Vue.js TypeScript Webpack 负责过 基于 Web Vitals 的首帧加载及使用卡顿优化（包括资源体积、数量和加载时序等优化） 基于 eslint-plugin-import 的模块循环依赖治理 状态管理库迁移 Vuex -\u0026gt; Pinia 组件范式迁移 vue class component -\u0026gt; composition api 基于 Sentry 的线上报错监控及治理 人生哲学 追求内心的宁静、自洽，更加笃定","title":"关于我"}]